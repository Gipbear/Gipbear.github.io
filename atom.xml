<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Grizzly&#39;s daily</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-01-10T12:27:45.754Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Grizzly</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数组解题技巧3——二分查找 - 数组 - leetcode题解 - 二分查找 - 双指针 - c++</title>
    <link href="http://example.com/2022/01/10/%E6%95%B0%E7%BB%84%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A73%E2%80%94%E2%80%94%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>http://example.com/2022/01/10/%E6%95%B0%E7%BB%84%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A73%E2%80%94%E2%80%94%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</id>
    <published>2022-01-10T11:18:35.000Z</published>
    <updated>2022-01-10T12:27:45.754Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是关于问题有序数组的二分查找问题，1.查找一个元素；2.查找区间全元素。</p><p>涉及 leetcode 的<a href="https://leetcode-cn.com/problems/binary-search/">704. 二分查找</a>和<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a>。</p></blockquote><span id="more"></span><h2 id="二分查找">二分查找</h2><h3 id="题目1">题目1</h3><p>首先来看题目<a href="https://leetcode-cn.com/problems/binary-search/">704. 二分查找</a>：给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><p>示例1：</p><blockquote><p>输入：nums = [-1,0,3,5,9,12], target = 9</p><p>输出：4</p></blockquote><p>示例2：</p><blockquote><p>输入：nums = [-1,0,3,5,9,12], target = 2</p><p>输出：-1</p></blockquote><h3 id="理解一下1">理解一下1</h3><p>题目的大概意思就是：在有序数组<code>nums</code>中找出与<code>target</code>相同的元素的索引位置。</p><p>直接遍历的时间复杂度是O(n)，而这里是<strong>有序数组</strong>，那么就可以使用二分查找，由此时间复杂度为O(log n)。</p><p>基本的思路是：</p><ol type="1"><li>约束查找区间左索引指针<code>left</code>和右索引指针<code>right</code>，获得中间索引指针<code>mid</code>；</li><li>判断<code>mid</code>指向的元素与<code>target</code>的大小：<ol type="1"><li>等于<code>target</code>：返回该<code>mid</code>索引；</li><li>大于<code>target</code>：说明在左侧，<code>right</code>向左收缩；</li><li>小于<code>target</code>：说明在右侧，<code>left</code>向右收缩；</li></ol></li></ol><h3 id="解题1">解题1</h3><p>需要注意的是right和left是<strong>闭区间</strong>，并且while循环中使用的是<span class="math inline">\(\leq\)</span>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>()<span class="number">-1</span>; <span class="comment">// 右侧需要减一</span></span><br><span class="line">    <span class="comment">// 计算 mid 时需要防止太大溢出</span></span><br><span class="line">    <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left = mid +<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找元素区间">查找元素区间</h2><h3 id="题目2">题目2</h3><p>首先来看题目<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a>：给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回[-1, -1]。</p><p>示例1：</p><blockquote><p>输入：nums = [5,7,7,8,8,10], target = 8</p><p>输出：[3,4]</p></blockquote><p>示例2：</p><blockquote><p>输入：nums = [5,7,7,8,8,10], target = 6</p><p>输出：[-1,-1]</p></blockquote><h3 id="理解一下2">理解一下2</h3><p>这道题目是想要寻找等于target的所有元素，由于是<strong>有序数组</strong>，所以由一个<strong>区间</strong>表示。主要的问题在于如何寻找到区间的<strong>左右边界</strong>。</p><p>这里有两个思路，都是利用<strong>二分查找</strong>。</p><h3 id="解题2.1">解题2.1</h3><ol type="1"><li>按照普通的二分查找，找到寻找一个等于target的元素位置；</li><li>若未找到则flag置为false；</li><li>若找到了，那么向左右依次寻找临界点即可。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)&#123;  <span class="comment">// 此处判断元素相等则跳出循环</span></span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        left = mid;</span><br><span class="line">        right = mid;</span><br><span class="line">        <span class="keyword">while</span>(--left &gt;= <span class="number">0</span> &amp;&amp; nums[left] == target);</span><br><span class="line">        <span class="keyword">while</span>(++right &lt; nums.<span class="built_in">size</span>() &amp;&amp; nums[right] == target);</span><br><span class="line">        <span class="keyword">return</span> &#123;++left, --right&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题解2.2">题解2.2</h3><p>与方法一不同，直接去寻找左右端点。</p><p>需要修改的地方仅仅是在<strong>二分查找相等</strong>时和<strong>收缩边界</strong>的情况<strong>统一</strong>起来，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="built_in">leftRange</span>(nums, target);</span><br><span class="line">    <span class="keyword">if</span>(left == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="built_in">rightRange</span>(nums, target);</span><br><span class="line">    <span class="keyword">return</span> &#123;left, right&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">leftRange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;  <span class="comment">// 右侧向左侧收缩，找到左端点</span></span><br><span class="line">        &#125;</span><br><span class="line">        mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= nums.<span class="built_in">size</span>() || nums[left] != target)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rightRange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;  <span class="comment">// 左侧向右侧收缩，找到右端点</span></span><br><span class="line">        &#125;</span><br><span class="line">        mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(right &lt; <span class="number">0</span> || nums[right] != target)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="个人收获">个人收获</h2><p>这里使用的二分查找比较简单，类似于一棵树，主要就是收缩区间和循环终止等一些细节问题。</p><p>第二个关于区间问题的方法，在leetcode上虽然第一个方法的效率较高，但是第二个方法的模块化和层次化要更好，更适合进行改编改写。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是关于问题有序数组的二分查找问题，1.查找一个元素；2.查找区间全元素。&lt;/p&gt;
&lt;p&gt;涉及 leetcode 的&lt;a href=&quot;https://leetcode-cn.com/problems/binary-search/&quot;&gt;704. 二分查找&lt;/a&gt;和&lt;a href=&quot;https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/&quot;&gt;34. 在排序数组中查找元素的第一个和最后一个位置&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据结构算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>字符串解题技巧1——滑动窗口</title>
    <link href="http://example.com/2022/01/09/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A71%E2%80%94%E2%80%94%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <id>http://example.com/2022/01/09/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A71%E2%80%94%E2%80%94%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</id>
    <published>2022-01-09T13:51:01.000Z</published>
    <updated>2022-01-10T09:32:13.774Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是关于字符串的子串问题，就数据结构的形态来说还是属于数组的问题，这里主要是关于使用双指针解决滑动窗口的问题。</p><p>涉及 leetcode 的<a href="https://leetcode-cn.com/problems/minimum-window-substring/">76. 最小覆盖子串</a>、<a href="https://leetcode-cn.com/problems/permutation-in-string/">567. 字符串的排列</a>、<a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a>和<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a>。</p></blockquote><span id="more"></span><h2 id="包含子串元素问题">包含子串元素问题</h2><p><a href="https://leetcode-cn.com/problems/minimum-window-substring/">76. 最小覆盖子串</a>、<a href="https://leetcode-cn.com/problems/permutation-in-string/">567. 字符串的排列</a>和<a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a>这一系列的问题都是关于在字符串中包含子串元素的问题。</p><h3 id="题目1">题目1</h3><p>首先来看这些题目<a href="https://leetcode-cn.com/problems/permutation-in-string/">567. 字符串的排列</a>：给你两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true；否则，返回 false。</p><p>换句话说，s1 的排列之一是 s2 的子串。</p><p>示例1：</p><blockquote><p>输入：s1 = "ab" s2 = "eidbaooo"</p><p>输出：true</p></blockquote><p>示例2：</p><blockquote><p>输入：s1= "ab" s2 = "eidboaoo"</p><p>输出：false</p></blockquote><h3 id="理解一下1">理解一下1</h3><p>题目的大概意思就是：给你一个子串 s1，需要判断在 s2 中是否一个子串包含子串 s1 中的所有元素。</p><p>基本的思路是：</p><ol type="1"><li>获得子串<code>s1</code>的长度<code>Len</code>；</li><li>按照<code>Len</code>的大小，使用左右索引指针组成的<strong>固定窗口</strong>，在字符串<code>s2</code>上滑动；</li><li>不断比较窗口内的子串和<code>s1</code>的元素是否相同；</li><li>比较的方法可以使用<strong>hash表</strong>或数组，比较各个元素出现的次数相同即可。</li></ol><p>以上的方法需要的时间复杂度为两个字符串长度的乘积，即O(NM)。</p><p>想要优化到O(n)，则可以使用<strong>不固定的滑动窗口</strong>来完：</p><ol type="1"><li>首先使用<strong>hash表</strong>记录子串<code>s1</code>中元素出现的次数；</li><li>初始化在<code>s2</code>上的左右索引指针为0；</li><li>右索引指针进行向右<strong>扩张</strong>，不断将字符纳入窗口；</li><li>判断新加入的字符是否子串<code>s1</code>中的，若是则在<strong>窗口hash表</strong>记录字符及其个数；</li><li>此时若窗口内的子串不满足子串<code>s1</code>的元素要求，那么左索引指针右移来缩小窗口范围，并更新相应内容即可。</li></ol><h3 id="解题1">解题1</h3><p>以上的思路可能我没有很清楚的表示，不过没关系，我们弄清楚以下几点：</p><ol type="1"><li>移动right扩大窗口时该做什么？：判断新纳入窗口的字符是否是我们需要的，若需要则<strong>加入</strong>，并增加字符个数<strong>valid</strong>；</li><li>何时停止扩大窗口，并移动left缩小窗口？：窗口大小 ≥ 子串大小时；</li><li>缩小窗口时该干什么？；<ul><li>首先判断此时是否已经满足条件，若满足则直接返回；</li><li>否则移除left处元素，若是需要的元素，则更新有效值，并<strong>删除</strong>窗口内的元素。</li></ul></li></ol><p>还是看代码逻辑吧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// need是子串元素hash表，window是滑动窗口</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="comment">// 初始化need子串</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : s1)</span><br><span class="line">        need[c]++;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;  <span class="comment">// 区间左闭右开</span></span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;  <span class="comment">// 窗口内有效元素个数</span></span><br><span class="line">    <span class="keyword">while</span>(right &lt; s2.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s2[right];  <span class="comment">// 右移字符进入子串hash</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">if</span>(need.<span class="built_in">count</span>(c))&#123;  <span class="comment">// 1. 若是需要元素则修改hash</span></span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span>(window[c] == need[c])</span><br><span class="line">                valid++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 区域可缩小</span></span><br><span class="line">        <span class="keyword">while</span>(right-left &gt;= s1.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="comment">// 3.1 满足条件直接返回</span></span><br><span class="line">            <span class="keyword">if</span>(valid == need.<span class="built_in">size</span>())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> d = s2[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 3.2 移除元素</span></span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(d))&#123;</span><br><span class="line">                <span class="keyword">if</span>(window[d] == need[d])</span><br><span class="line">                    valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok，有了以上的代码再看剩下两题几乎是一模一样，就不详细解说了，代码如下：</p><h4 id="最小覆盖子串"><a href="https://leetcode-cn.com/problems/minimum-window-substring/">76. 最小覆盖子串</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// need是子串元素hash，window是滑动窗口</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="comment">// 初始化need子串</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : t)</span><br><span class="line">        need[c]++;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>; <span class="comment">// 区间左闭右开</span></span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;  <span class="comment">// 窗口内有效元素个数</span></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, len = INT_MAX;  <span class="comment">// 最终起点和长度</span></span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[right];  <span class="comment">//右移字符进入子串hash</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">if</span>(need.<span class="built_in">count</span>(c))&#123;  <span class="comment">//若需要则修改hash</span></span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span>(window[c] == need[c])</span><br><span class="line">                valid++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(valid == need.<span class="built_in">size</span>())&#123;  <span class="comment">//窗口内的元素已经满足需要</span></span><br><span class="line">            <span class="keyword">if</span>(right-left &lt; len)&#123;  <span class="comment">// 可以收缩窗口就更新结果</span></span><br><span class="line">                start = left;</span><br><span class="line">                len = right - left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(d))&#123;</span><br><span class="line">                <span class="keyword">if</span>(window[d] == need[d])</span><br><span class="line">                    valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len == INT_MAX ? <span class="string">&quot;&quot;</span> : s.<span class="built_in">substr</span>(start, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="找到字符串中所有字母异位词"><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a></h4><p>所谓异位词也就是子串重新排列嘛，不用感到新奇。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : p)</span><br><span class="line">        need[c]++;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[right++];</span><br><span class="line">        <span class="keyword">if</span>(need.<span class="built_in">count</span>(c))&#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span>(window[c] == need[c])</span><br><span class="line">                valid++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(right-left &gt;= p.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(valid == need.<span class="built_in">size</span>())&#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> d = s[left++];</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(d))&#123;</span><br><span class="line">                <span class="keyword">if</span>(window[d] == need[d])</span><br><span class="line">                    valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="无重复字符的最长子串">无重复字符的最长子串</h2><p>这题其实与以上三题大差不差，只不过这里<strong>没有给定子串</strong>，而是需要我们<strong>求出子串</strong>而已。</p><h3 id="题目2">题目2</h3><p>首先来看题目<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a>：给定一个字符串 s ，请你找出其中不含有重复字符的<strong>最长子串</strong>的长度。</p><p>示例1：</p><blockquote><p>输入："abcabcbb"</p><p>输出：3</p></blockquote><p>示例2：</p><blockquote><p>输入：s = "bbbbb"</p><p>输出：1</p></blockquote><h3 id="理解一下2">理解一下2</h3><p>题目的大概意思就是：找出字符串中元素不重复的子串的长度，也就是需要子串中的元素<strong>不重复</strong>，个数要尽可能的<strong>多</strong>。</p><p>保持之前的解题思路，但是这里就不需要<code>needhash</code>表和<code>valid</code>值了，因为我们没有需要比较的子串，但是需要一个<code>res</code>来记录长度：</p><ol type="1"><li>右侧子串向前扩张，将新字符纳入窗口；</li><li>判断该窗口内加入的该子串是否重复；</li><li>若重复，则左侧索引指针收缩，直至将重复元素抛出；</li><li>判断此时的长度与<code>res</code>大小，更新最大子串长度。</li></ol><h3 id="解题2">解题2</h3><p>很简单吧，看代码更简单。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; window;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="comment">// 扩张</span></span><br><span class="line">        <span class="keyword">char</span> c = s[right++];</span><br><span class="line">        window[c]++;</span><br><span class="line">        <span class="comment">// 有重复的字符</span></span><br><span class="line">        <span class="keyword">while</span>(window[c] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 收缩</span></span><br><span class="line">            <span class="keyword">char</span> d = s[left++];</span><br><span class="line">            window[d]--;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(res, right - left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="个人收获">个人收获</h2><p>之前使用双指针解决链表的时候，用快慢指针来解决一些链表上的逻辑问题；但是在字符串这种类似数组的数据结构中也是可以使用<strong>索引来表示指针</strong>，解决一些逻辑问题。</p><p>滑动窗口的结合hash表既可以来表示区域内的元素数量了，对于一些<strong>不要求顺序的子串问题</strong>就可以使用该方法解决。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是关于字符串的子串问题，就数据结构的形态来说还是属于数组的问题，这里主要是关于使用双指针解决滑动窗口的问题。&lt;/p&gt;
&lt;p&gt;涉及 leetcode 的&lt;a href=&quot;https://leetcode-cn.com/problems/minimum-window-substring/&quot;&gt;76. 最小覆盖子串&lt;/a&gt;、&lt;a href=&quot;https://leetcode-cn.com/problems/permutation-in-string/&quot;&gt;567. 字符串的排列&lt;/a&gt;、&lt;a href=&quot;https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/&quot;&gt;438. 找到字符串中所有字母异位词&lt;/a&gt;和&lt;a href=&quot;https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/&quot;&gt;3. 无重复字符的最长子串&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据结构算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="leetcode题解" scheme="http://example.com/tags/leetcode%E9%A2%98%E8%A7%A3/"/>
    
    <category term="双指针" scheme="http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
    <category term="字符串" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="滑动窗口" scheme="http://example.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>数组解题技巧2——差分数组</title>
    <link href="http://example.com/2022/01/07/%E6%95%B0%E7%BB%84%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A72%E2%80%94%E2%80%94%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"/>
    <id>http://example.com/2022/01/07/%E6%95%B0%E7%BB%84%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A72%E2%80%94%E2%80%94%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/</id>
    <published>2022-01-07T15:42:27.000Z</published>
    <updated>2022-01-10T09:31:53.337Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是关于数组的差分数组技巧，在对元素数组区间进行加减计算时使用。</p><p>涉及 leetcode 的<a href="https://leetcode-cn.com/problems/range-addition">370. 区间加法</a>、<a href="https://leetcode-cn.com/problems/corporate-flight-bookings">1109. 航班预订统计</a>和<a href="https://leetcode-cn.com/problems/car-pooling">1094. 拼车</a>。</p></blockquote><span id="more"></span><h2 id="合并两个有序链表">合并两个有序链表</h2><h3 id="题目1">题目1</h3><p>首先来看题目<a href="https://leetcode-cn.com/problems/range-addition">370. 区间加法</a>：假设你有一个长度为 n 的数组，初始情况下所有的数字均为 0，你将会被给出 k 个更新的操作。其中，每个操作会被表示为一个三元组：[startIndex, endIndex, inc]，你需要将子数组 A[startIndex ... endIndex]（包括 startIndex 和 endIndex）增加 inc。</p><p>请你返回 k 次操作后的数组。</p><p>示例1：</p><blockquote><p>输入：length = 5, updates = [ [1,3,2],[2,4,3],[0,2,-2] ]</p><p>输出：[-2,0,3,5,3]</p></blockquote><h3 id="理解一下1">理解一下1</h3><p>题目的大概意思就是：</p><ol type="1"><li>初始数组为元素均为 0；</li><li>三元组表示在区间<code>startIndex</code>到<code>endIndex</code>内的元素都加上<code>inc</code>。</li></ol><p>最直白的思路就是，将每个三元组表示的区间一个一个加上值，很快就能实现，但是复杂度太高会超时，那么怎么办呢？</p><p>这里引入<strong>差分数组</strong>的概念：</p><p>差分数组就是在原长度为<code>n</code>的<code>nums</code>数组上，构建一个长度为<code>n+1</code>的数组<code>diff</code>，<code>diff[i] = nums[i] - nums[i-1]</code>，也就是原数组相邻两项的之差。</p><p>当差分数组计算完成之后再通过<code>nums[i] = nums[i-1] + diff[i]</code>即可还原得到相应的数组。</p><blockquote><p>对差分数组的第<code>i</code>项进行计算，都会同等影响到之后的剩余项，这就是差分数组的<strong>性质</strong>！</p></blockquote><p>因此，我们可以在差分数组上对第<code>first</code>项加上<code>seats</code>，使得后续的每一项都会增加<code>seats</code>，但是我们只想增加到第<code>last</code>项，所以在第<code>last+1</code>项之后再减去<code>seats</code>，就可以抵消该影响啦！</p><p>ok，那我们就来看代码吧！</p><h3 id="解题1">解题1</h3><p>构建差分数组的时候，使得差分数组的长度为<code>n+1</code>可以使得不用判断数组越界的问题，这个和链表增加<strong>头结点</strong>有异曲同工之妙。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">getModifiedArray</span><span class="params">(<span class="keyword">int</span> length, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; updates)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实际上计算的nums是差分数组，只不过这里开始都为0</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(length+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; updates.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        nums[updates[i][<span class="number">0</span>]] += updates[i][<span class="number">2</span>];</span><br><span class="line">        nums[updates[i][<span class="number">1</span>]+<span class="number">1</span>] -= updates[i][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 差分数组还原</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++)&#123;</span><br><span class="line">        nums[i] += nums[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    nums.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于<a href="https://leetcode-cn.com/problems/corporate-flight-bookings">1109. 航班预订统计</a>和<a href="https://leetcode-cn.com/problems/car-pooling">1094. 拼车</a>这两个问题实际上就是将该简单问题应用到实际场景中了，学会了这个差分数组的思想就很容易了，只需要注意端点细节处理即可。</p><h2 id="个人收获">个人收获</h2><ol type="1"><li><p>前缀和数组用于计算区域和问题，差分数组用于区域元素同时加减问题，而且使用频率较高时使用效果较好。</p></li><li><p>注意将数组长度扩大一个，这个在计算相邻项的时候就无需判断在数组最后是否会出现数组越界的问题，与链表中增加头结点的效果类似。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是关于数组的差分数组技巧，在对元素数组区间进行加减计算时使用。&lt;/p&gt;
&lt;p&gt;涉及 leetcode 的&lt;a href=&quot;https://leetcode-cn.com/problems/range-addition&quot;&gt;370. 区间加法&lt;/a&gt;、&lt;a href=&quot;https://leetcode-cn.com/problems/corporate-flight-bookings&quot;&gt;1109. 航班预订统计&lt;/a&gt;和&lt;a href=&quot;https://leetcode-cn.com/problems/car-pooling&quot;&gt;1094. 拼车&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据结构算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="leetcode题解" scheme="http://example.com/tags/leetcode%E9%A2%98%E8%A7%A3/"/>
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="差分数组" scheme="http://example.com/tags/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>数组解题技巧1——前缀和数组</title>
    <link href="http://example.com/2022/01/07/%E6%95%B0%E7%BB%84%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A71%E2%80%94%E2%80%94%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84/"/>
    <id>http://example.com/2022/01/07/%E6%95%B0%E7%BB%84%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A71%E2%80%94%E2%80%94%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84/</id>
    <published>2022-01-07T14:44:22.000Z</published>
    <updated>2022-01-10T09:31:44.684Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是关于数组的前缀和技巧，在快速计算一个数组区间内的元素之和时使用</p><p>涉及 leetcode 的 <a href="https://leetcode-cn.com/problems/range-sum-query-immutable">303. 区域和检索 - 数组不可变</a>、<a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable">304. 二维区域和检索 - 矩阵不可变</a>和<a href="https://leetcode-cn.com/problems/subarray-sum-equals-k">560. 和为 K 的子数组</a>。</p></blockquote><span id="more"></span><h2 id="区域检索">区域检索</h2><h3 id="题目1">题目1</h3><p>首先来看题目<a href="https://leetcode-cn.com/problems/range-sum-query-immutable">303. 区域和检索 - 数组不可变</a>：给定一个整数数组 nums，求出数组从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点。</p><p>示例1：</p><blockquote><p>输入：[ [ [-2, 0, 3, -5, 2, -1] ], [0, 2], [2, 5], [0, 5] ]</p><p>输出：[null, 1, -1, -3]</p></blockquote><h3 id="理解一下1">理解一下1</h3><p>题目的大概意思就是：计算数组内某个区域的和。</p><p>代码要求有两点，一个是写出构造函数，一个是写出计算区域和的函数。</p><p>基本的思路是：</p><ol type="1"><li>构造函数直接将数组传递过去就行；</li><li>在<code>sumRange</code>中使用循环计算<code>left</code>到<code>right</code>的和。</li></ol><p>很简单的嘛，OK确实，但是提交了发现超越的人数不多呀，这怎么行！</p><p>仔细思考发现 OJ 测试的时候构造函数仅仅调用<strong>一次</strong>，而计算区域和函数调用了<strong>多次</strong>，所以我们需要优化<code>sumRange</code>函数。</p><p>于是考虑使用前缀和，使得构造函数麻烦一些，但是使得<code>sumRange</code>函数<strong>简单</strong>一些：</p><ol type="1"><li>使用构造函数时，直接在传递数组时，计算前<code>n</code>项的前缀累加和，时间复杂度为<code>O(n)</code>；</li><li>然后<code>sumRange</code>函数计算<code>left</code>到<code>right</code>的区域和时，只需要使用第<code>right</code>项的前缀和减去第<code>left-1</code>项前缀和即可，<code>sumRange</code>的时间复杂度就是<code>O(1)</code>。</li></ol><h3 id="解题1">解题1</h3><p>先看解法一：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;nums = nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; i++)&#123;</span><br><span class="line">            sum += <span class="keyword">this</span>-&gt;nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再看使用前缀和的解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; presums;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="comment">// 构造时为 n 的复杂度</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;presums.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;presums[i] = <span class="keyword">this</span>-&gt;presums[i<span class="number">-1</span>] + nums[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用时仅需要直接索引相减即可</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;presums[right+<span class="number">1</span>] - <span class="keyword">this</span>-&gt;presums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关于<a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable">304. 二维区域和检索 - 矩阵不可变</a>这题，只不过是从一维变化成了二维，大家举一反三即可。</p><p>需要注意的仅仅是边界的细节问题。</p><h2 id="和为-k-的子数组">和为 K 的子数组</h2><h3 id="题目2">题目2</h3><p>首先来看题目<a href="https://leetcode-cn.com/problems/subarray-sum-equals-k">560. 和为 K 的子数组</a>：给你一个整数数组 nums 和一个整数 k ，请你统计并返回该数组中和为 k 的连续子数组的个数。</p><p>示例1：</p><blockquote><p>输入：nums = [1,1,1], k = 2</p><p>输出：2</p></blockquote><p>示例2：</p><blockquote><p>输入：nums = [1,2,3], k = 3</p><p>输出：2</p></blockquote><h3 id="理解一下2">理解一下2</h3><p>题目的大概意思就是：计算出，给定数组中有多少个连续子数组的和为 K，也就是给定数组中有多少个区间和为K。</p><p>最基本的思路就是穷举嘛，嵌套循环，计算所有区间的数组之和，判断其是否为 K。不过很遗憾，时间复杂度<span class="math inline">\(O(n^2)\)</span>在10000大小的测试案例中超时了。</p><p>再仔细看看区域和为K，关于区域和那我们很自然的想到使用前缀和数组试试看了：</p><ol type="1"><li>计算前缀和数组；</li><li>我们要计算区域和，就得使用前缀和数组的端点值相减，并判断是否为K，如此一来时间复杂度又回到了<span class="math inline">\(O(n^2)\)</span>；</li><li>换个思路，验证<code>i</code>处的前缀和<code>sum_i</code>减去<code>K</code>的差值<code>sum_j</code>，判断<code>sum_j</code>是否已经<strong>存在</strong>已知的前缀和数组中，若存在则统计<strong>出现次数</strong>即可！</li><li><code>sum_j</code>出现的次数就是i为右端点的区间可以出现的次数，随着不断计算前缀和数组和计数，那么时间复杂度仅仅是计算前缀和的时间O(n)。</li></ol><h3 id="题解2">题解2</h3><p>判断存在计数可以使用<strong>hash表</strong>来实现，快速高效。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用hash表来记录前缀和出现的次数</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; presum;</span><br><span class="line">    <span class="comment">// 初始记录为 0，因为存在一个数等于 k 的情况</span></span><br><span class="line">    presum[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// count 记录个数，sum_i 计算前缀和</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>, sum_i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num: nums)&#123;</span><br><span class="line">        sum_i += num;</span><br><span class="line">        <span class="keyword">int</span> sum_j = sum_i - k;</span><br><span class="line">        <span class="comment">// 相差为 k 的前缀和若存在，则区域相加为 k</span></span><br><span class="line">        <span class="keyword">if</span>(presum.<span class="built_in">find</span>(sum_j) != presum.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="comment">// 加上此前出现 sum_j 的次数</span></span><br><span class="line">            count += presum[sum_j];</span><br><span class="line">        &#125;</span><br><span class="line">        presum[sum_i]++; <span class="comment">// 出现次数加 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="个人收获">个人收获</h2><p>前缀和的计算方法主要适用于处理数组<strong>区域之和</strong>的问题，并且计算区域和<strong>频率较高</strong>时使用，能够达到较好的效果。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是关于数组的前缀和技巧，在快速计算一个数组区间内的元素之和时使用&lt;/p&gt;
&lt;p&gt;涉及 leetcode 的 &lt;a href=&quot;https://leetcode-cn.com/problems/range-sum-query-immutable&quot;&gt;303. 区域和检索 - 数组不可变&lt;/a&gt;、&lt;a href=&quot;https://leetcode-cn.com/problems/range-sum-query-2d-immutable&quot;&gt;304. 二维区域和检索 - 矩阵不可变&lt;/a&gt;和&lt;a href=&quot;https://leetcode-cn.com/problems/subarray-sum-equals-k&quot;&gt;560. 和为 K 的子数组&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据结构算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="leetcode题解" scheme="http://example.com/tags/leetcode%E9%A2%98%E8%A7%A3/"/>
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="前缀和" scheme="http://example.com/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>加快国内访问GitHub速度</title>
    <link href="http://example.com/2022/01/07/%E5%8A%A0%E5%BF%AB%E5%9B%BD%E5%86%85%E8%AE%BF%E9%97%AEGitHub%E9%80%9F%E5%BA%A6/"/>
    <id>http://example.com/2022/01/07/%E5%8A%A0%E5%BF%AB%E5%9B%BD%E5%86%85%E8%AE%BF%E9%97%AEGitHub%E9%80%9F%E5%BA%A6/</id>
    <published>2022-01-07T08:16:03.000Z</published>
    <updated>2022-01-08T08:30:33.761Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要是为了提高国内访问GitHub的速度。</p><p>方法是修改host文件。</p></blockquote><span id="more"></span><p>在国内 GitHub 访问速度慢或者无法访问，一般是因为 github 的加速分发 CDN 域名<code>assets-cdn.github.com</code>遭到<a href="https://baike.baidu.com/item/DNS%E6%B1%A1%E6%9F%93/8620359">DNS污染</a>，无法访问导致的。</p><p>所以解决方法就是修改本地的 host 映射，让解析的域名直接指向 Github 的 IP 地址，来绕过 DNS 解析。</p><h2 id="查询最新的-github-的-ip-地址">查询最新的 Github 的 IP 地址</h2><p>使用<a href="https://www.ipaddress.com/">ipaddress.com</a>查询以下域名对应的 IP 地址：</p><blockquote><p>github.com assets-cdn.github.com github.global.ssl.fastly.net</p></blockquote><h2 id="修改本地-host-文件">修改本地 host 文件</h2><p>Windows 用户在<code>C:\Windows\System32\drivers\etc</code>下找到 host 目录，若没有修改权限在<code>属性 -&gt; 安全</code>中增加用户的修改权限。</p><p>在使用记事本打开，在最后加入查询的 IP 和域名，增加如下内容，其中 IP 是自己查的最新的：</p><blockquote><p>#github映射（随便啦，做个标记让自己以后看到知道这里修改了什么）</p><p>140.82.114.3 github.com</p><p>185.199.108.153 assets-cdn.github.com</p><p>199.232.69.194 github.global.ssl.fastly.net</p></blockquote><h2 id="刷新-dns-缓存">刷新 DNS 缓存</h2><p>Windows 下使用<code>Win+R</code>，输入<code>cmd</code>，打开命令行，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /flushdns</span><br></pre></td></tr></table></figure><p>刷新成功后就可以愉快的访问 Github 了。</p><h2 id="最后">最后</h2><p>由于 IP 经常会发生变化，所以如果访问变慢了就需要手动更新。</p><p>这里推荐一个网址<a href="https://raw.hellogithub.com/hosts">hellogithub</a>，有最新的 Github 访问 IP，可以直接复制粘贴。（不过还是建议自己搜一下这三个域名的ip，也很快，这个直接复制的效果好像并不好）</p><h2 id="参考文章">参考文章</h2><ol type="1"><li><a href="https://juejin.cn/post/6955761924722130974">国内加速访问Github的办法，超级简单</a></li><li><a href="https://juejin.cn/post/7019683061977579557">解决GitHub访问慢的问题</a></li></ol><h2 id="个人收获">个人收获</h2><p>其实很早之前就修改过但现在忘记了，所以还是自己写一篇文章，很久以后忘记了直接来找就好了。</p><p>其中的一些原理细节未必会懂，但是这就是一个工具呀，能用好就可以啦！</p><p>以上，继续加油！</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文主要是为了提高国内访问GitHub的速度。&lt;/p&gt;
&lt;p&gt;方法是修改host文件。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="配置" scheme="http://example.com/categories/%E9%85%8D%E7%BD%AE/"/>
    
    
    <category term="GitHub" scheme="http://example.com/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>单链表解题技巧3——相交链表</title>
    <link href="http://example.com/2022/01/06/%E5%8D%95%E9%93%BE%E8%A1%A8%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A73%E2%80%94%E2%80%94%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2022/01/06/%E5%8D%95%E9%93%BE%E8%A1%A8%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A73%E2%80%94%E2%80%94%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</id>
    <published>2022-01-06T12:54:24.000Z</published>
    <updated>2022-01-10T09:31:02.773Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是关于单链表的判断相交问题，使用了两种方法，快慢指针和更好的逻辑连接方法。</p><p>涉及 leetcode 的 <a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a>。</p></blockquote><span id="more"></span><h2 id="相交链表">相交链表</h2><h3 id="题目">题目</h3><p>首先来看题目<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a>：给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。</p><p>示例1：</p><blockquote><p>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3</p><p>输出：Intersected at '8'</p></blockquote><p>示例2：</p><blockquote><p>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3</p><p>输出：Intersected at '8'</p></blockquote><h3 id="理解一下1">理解一下1</h3><p>所谓链表相交，就是一个<code>Y型</code>的链表结构，在交点处汇流，需要注意的是:</p><blockquote><p>链表相交后不会分开！因为链表只有一个<code>next</code>，只有唯一后继。</p></blockquote><p>寻找两条链表相交的结点就是寻找<strong>相同的结点</strong>（而不是值！）</p><p>基本的思路是：</p><p>遍历第一条链表<code>l1</code>，嵌套遍历第二条链表<code>l2</code>，判断相同的结点即可。</p><p>这种方法的时间复杂度达到了<code>O(n)</code>不是很好，于是便思考其他方法。</p><ol type="1"><li>我们需要找到相交点，而最后相交点之后链的长度都是一样的；</li><li>两个指针判断相等时需要同时到达相交点；</li><li>那么自然就需要使得前面遍历的经过的结点数相同；</li></ol><h3 id="解法一双指针">解法一（双指针）</h3><p>使用双指针来解决，我思考的时候还是比较自然的，表述可能不够清晰，自己动手比划比划就很清楚了。</p><ol type="1"><li>当链长相同时，自然是一一比较即可（这种情况不用考虑，包含在下面）；</li><li>链长不同是，短链的指针<code>l1</code>会先到达终点，而长链指针<code>l2</code>则还有<code>k</code>个结点，这个<code>k</code>刚好是两条链的长度之差；</li><li>由此我们长链中再设一个指针<code>llong</code>，跟随<code>l2</code>继续前进;</li><li>当<code>l2</code>到达终点时，<code>llong</code>距离链尾刚好与短链长度<strong>相同</strong>；</li><li>此时在短链头设置一个指针<code>lshort</code>，与<code>llong</code>一同前进，一一比较即可。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">    ListNode *la = headA, *lb = headB;</span><br><span class="line">    ListNode *lc, *llong, *lshort;</span><br><span class="line">    <span class="comment">// 依旧是快慢指针</span></span><br><span class="line">    <span class="comment">// la和lb同时前进</span></span><br><span class="line">    <span class="keyword">while</span>(la != <span class="literal">nullptr</span> &amp;&amp; lb != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        la = la-&gt;next;</span><br><span class="line">        lb = lb-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 选出长链和短链</span></span><br><span class="line">    <span class="keyword">if</span>(lb != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        lc = lb;</span><br><span class="line">        llong = headB;</span><br><span class="line">        lshort = headA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        lc = la;</span><br><span class="line">        llong = headA;</span><br><span class="line">        lshort = headB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 指向长链的快指针带着慢指针走到头</span></span><br><span class="line">    <span class="keyword">while</span>(lc != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        llong = llong-&gt;next;</span><br><span class="line">        lc = lc-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//短链从头开始和后出发的慢指针同时前进即可找到相同点</span></span><br><span class="line">    <span class="keyword">while</span>(lshort != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(lshort == llong)&#123;</span><br><span class="line">            <span class="keyword">return</span> llong;</span><br><span class="line">        &#125;</span><br><span class="line">        lshort = lshort-&gt;next;</span><br><span class="line">        llong = llong-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解法二逻辑连接">解法二（逻辑连接）</h3><p>继基本的分析思路，接下来要使得双指针同时到达交点：</p><ol type="1"><li>只需要使得双指针在到达交点时经过相同个数的结点即可；</li><li>而我们知道<code>A+B = B+A</code>；</li><li>所以在A链前加上B链，在B链前加上A链，那么双指针同时从各自链出发，会在同一时刻到达相交点！</li></ol><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">    ListNode *la = headA, *lb = headB;</span><br><span class="line">    <span class="keyword">while</span>(la != lb)&#123;</span><br><span class="line">        <span class="comment">// A链完了去B链</span></span><br><span class="line">        <span class="keyword">if</span> (la != <span class="literal">nullptr</span>)</span><br><span class="line">            la = la-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            la = headB;</span><br><span class="line">        <span class="comment">// B链完了去A链</span></span><br><span class="line">        <span class="keyword">if</span> (lb != <span class="literal">nullptr</span>)</span><br><span class="line">            lb = lb-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            lb = headA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> la;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="个人收获">个人收获</h2><p>这次感觉自己有一点很好的使用了之前学过的双指针，毕竟学了会用才是真的学会了。</p><p>另外将两个链表逻辑连接，使得两个链表的长度相同，这一点还是很值得学习的，不能作为套路，但是是一个很好的思考方向。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是关于单链表的判断相交问题，使用了两种方法，快慢指针和更好的逻辑连接方法。&lt;/p&gt;
&lt;p&gt;涉及 leetcode 的 &lt;a href=&quot;https://leetcode-cn.com/problems/intersection-of-two-linked-lists/&quot;&gt;160. 相交链表&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据结构算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="单链表" scheme="http://example.com/tags/%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    
    <category term="leetcode题解" scheme="http://example.com/tags/leetcode%E9%A2%98%E8%A7%A3/"/>
    
    <category term="双指针" scheme="http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
    <category term="逻辑链接" scheme="http://example.com/tags/%E9%80%BB%E8%BE%91%E9%93%BE%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>单链表解题技巧(2)——快慢指针</title>
    <link href="http://example.com/2022/01/06/%E5%8D%95%E9%93%BE%E8%A1%A8%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A72%E2%80%94%E2%80%94%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"/>
    <id>http://example.com/2022/01/06/%E5%8D%95%E9%93%BE%E8%A1%A8%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A72%E2%80%94%E2%80%94%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/</id>
    <published>2022-01-06T11:00:57.000Z</published>
    <updated>2022-01-10T09:31:01.563Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是关于单链表的双指针问题中的快慢指针问题，1.链表的倒数第 n 个结点；2.寻找链表中间结点；3. 判断是否有环。</p><p>涉及 leetcode 的 <a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list">19. 删除链表的倒数第 N 个结点</a>、<a href="https://leetcode-cn.com/problems/middle-of-the-linked-list">876. 链表的中间结点</a>、<a href="https://leetcode-cn.com/problems/linked-list-cycle">141. 环形链表</a>和<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii">142. 环形链表 II</a>。</p></blockquote><span id="more"></span><h2 id="倒数第-n-个结点">倒数第 N 个结点</h2><h3 id="题目1">题目1</h3><p>首先来看题目<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list">19. 删除链表的倒数第 N 个结点</a>：给你一个链表，删除链表的<strong>倒数</strong>第 n 个结点，并且返回链表的头结点。</p><p>示例1：</p><blockquote><p>输入：head = [1,2,3,4,5], n = 2</p><p>输出：[1,2,3,5]</p></blockquote><p>示例2：</p><blockquote><p>输入：head = [1], n = 1</p><p>输出：[]</p></blockquote><h3 id="理解一下1">理解一下1</h3><p><strong>不用理解！</strong>(狗头)</p><p>基本的思路是：</p><ol type="1"><li>先遍历一遍链表，得到链表的长度<code>Len</code>；</li><li>然后再从头遍历一遍到第<code>Len-N</code>个结点，该结点的后一个结点就是需要删除的结点。</li></ol><p>以上的思路确实可以解决该问题，但是对链表进行了两次遍历，那么是否可以使用<strong>一次遍历</strong>完成呢？可以的。</p><p>这就需要使用快慢指针了：</p><ol type="1"><li>我们需要找到倒数<code>N</code>个结点，那么就需要寻找到第<code>Len-N</code>个结点；</li><li>首先让快指针先走，走出<code>N</code>步；</li><li>然后让慢指针和快指针保持相距<code>N</code>一起向前遍历，这时快指针还有<code>Len-N</code>步到达链尾，那么慢指针自然就还可以走<code>Len-N</code>步啦！</li></ol><h3 id="解题1">解题1</h3><p>这里我们同样需要对第一个结点进行讨论，所以直接引入头结点来解决。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用头结点</span></span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    dummy-&gt;next = head;</span><br><span class="line">    <span class="comment">// 快慢结点</span></span><br><span class="line">    ListNode *first = dummy, *second = dummy;</span><br><span class="line">    <span class="comment">// first先走n步</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// first和second保持相同的间距前进</span></span><br><span class="line">    <span class="comment">// first指向终点时second指向将要删除结点的前一个</span></span><br><span class="line">    <span class="keyword">while</span>(first-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">        second = second-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除（未释放空间）</span></span><br><span class="line">    second-&gt;next = second-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中间结点">中间结点</h2><p>再来看一下中间结点的问题，其实是相同的套路。</p><h3 id="题目2">题目2</h3><p>先来看一下题目<a href="https://leetcode-cn.com/problems/middle-of-the-linked-list">876. 链表的中间结点</a>：给定一个头结点为 head 的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。</p><p>示例1：</p><blockquote><p>输入：[1,2,3,4,5]</p><p>输出：此列表中的结点 3</p></blockquote><p>示例2：</p><blockquote><p>输入：[1,2,3,4,5,6]</p><p>输出：此列表中的结点 4</p></blockquote><h3 id="理解一下2">理解一下2</h3><p><strong>也不用理解！</strong>(狗头)</p><p>基本思路与上一题类似：</p><ol type="1"><li>先遍历一遍链表，得到链表的长度<code>Len</code>；</li><li>然后再从头遍历一遍到第<code>Len/2</code>个结点即可。</li></ol><p>这同样需要使用两次遍历，有了上面的经验我们自然可以想到使用快慢指针实现一次遍历：</p><ol type="1"><li>快指针和慢指针同时出发（与之前先后出发不同了）；</li><li>快指针一次走两个<code>next</code>，慢指针一次进行一次<code>next</code>，这样快指针走到最后，慢指针刚好走了快指针的一般路程。</li></ol><h3 id="题解2">题解2</h3><p>这里根据题目要求注意一下中间结点的定义即可。</p><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode * first = head, * second = head;</span><br><span class="line">    <span class="keyword">while</span>(first != <span class="literal">nullptr</span> &amp;&amp; first-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="comment">// 慢指针走一步，快指针走两步</span></span><br><span class="line">        second = second-&gt;next;</span><br><span class="line">        first = first-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="同样套路还有一个啦二合一">同样套路，还有一个啦（二合一）</h2><h2 id="环形链表">环形链表</h2><h3 id="题目3">题目3</h3><p><a href="https://leetcode-cn.com/problems/linked-list-cycle">141. 环形链表</a>和<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii">142. 环形链表 II</a>这两题类似。</p><p>141 给你一个链表的头节点 head ，判断链表中是否有环。</p><p>以及</p><p>142 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><h3 id="理解一下3">理解一下3</h3><p>也就是说需要判断链表是否有环，以及从哪个结点开始形成环。</p><p>那么我们首先需要知道如何判断环：</p><ol type="1"><li>容易发现，一旦使用指针在有环链表中进行遍历，那么遍历一定是没有终止；就像操场跑步一样，只要沿着400米的圈一直跑就没有尽头，但是沿着100米的直线跑却是有尽头的；</li><li>同样的，当我与你一起在<code>100 + 400n米</code>的操场上跑步，从我跑得慢，你跑得快，那么你是不是终究就会在某个点上超过我一圈！</li><li>因此我们同样可以使用快慢指针进行你追我赶，当然，补偿为1、2、3这种连续遍历，可能会超过K圈（整数倍），不过无所谓，<strong>你我终会相遇</strong>。</li></ol><p>然后如何判断在哪相遇呢？（你的速度是我的两倍）</p><ol type="1"><li>慢吞吞的我跑了<code>n</code>米，快吨吨的你跑了<code>2n</code>米，相遇时距离环起点也<code>m</code>米；</li><li>那么超过我的距离<code>n</code>一定是环的<strong>整数</strong>倍，所以你<strong>再</strong>跑<code>n-m</code>米就可以到达环起点，而我<strong>回到起点</strong>再跑<code>n-m</code>米也能到达环起点！</li><li>这里就不需要计数n了，保持相同速度跑，自然会在起点相遇，<strong>你我终会再次相遇</strong>。</li></ol><h3 id="题解3">题解3</h3><p>判断方法如下：</p><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    ListNode *first = head, *second = head;</span><br><span class="line">    <span class="comment">// 同样使用快慢指针，若存在环，那么快指针将会在环内与慢指针相遇</span></span><br><span class="line">    <span class="keyword">while</span>(first != <span class="literal">nullptr</span> &amp;&amp; first-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        first = first-&gt;next-&gt;next;</span><br><span class="line">        second = second-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(first == second)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>寻找环起点的方法如下：</p><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    ListNode *first = head, *second = head;</span><br><span class="line">    <span class="comment">// 标记是否相遇</span></span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(first != <span class="literal">nullptr</span> &amp;&amp; first-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        first = first-&gt;next-&gt;next;</span><br><span class="line">        second = second-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(second == first)&#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        <span class="comment">// 任意一个结点回到起点，同样速度跑</span></span><br><span class="line">        first = head;</span><br><span class="line">        <span class="keyword">while</span>(first != second)&#123;</span><br><span class="line">            first = first-&gt;next;</span><br><span class="line">            second = second-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="个人收获">个人收获</h2><p>这次的收获主要是头结点和快慢指针</p><ol type="1"><li>头结点使得每个结点都有直接前驱，可以避免单独处理第一个结点的问题，很好用的；</li><li>快慢指针可以用来解决一些与速度、距离有关的问题会有较好的处理方法，在后续的题目中多熟悉熟悉。</li></ol>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是关于单链表的双指针问题中的快慢指针问题，1.链表的倒数第 n 个结点；2.寻找链表中间结点；3. 判断是否有环。&lt;/p&gt;
&lt;p&gt;涉及 leetcode 的 &lt;a href=&quot;https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list&quot;&gt;19. 删除链表的倒数第 N 个结点&lt;/a&gt;、&lt;a href=&quot;https://leetcode-cn.com/problems/middle-of-the-linked-list&quot;&gt;876. 链表的中间结点&lt;/a&gt;、&lt;a href=&quot;https://leetcode-cn.com/problems/linked-list-cycle&quot;&gt;141. 环形链表&lt;/a&gt;和&lt;a href=&quot;https://leetcode-cn.com/problems/linked-list-cycle-ii&quot;&gt;142. 环形链表 II&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据结构算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="单链表" scheme="http://example.com/tags/%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    
    <category term="leetcode题解" scheme="http://example.com/tags/leetcode%E9%A2%98%E8%A7%A3/"/>
    
    <category term="双指针" scheme="http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="快慢指针" scheme="http://example.com/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"/>
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>单链表解题技巧(1)——合并有序链表</title>
    <link href="http://example.com/2022/01/05/%E5%8D%95%E9%93%BE%E8%A1%A8%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A71%E2%80%94%E2%80%94%E5%90%88%E5%B9%B6%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2022/01/05/%E5%8D%95%E9%93%BE%E8%A1%A8%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A71%E2%80%94%E2%80%94%E5%90%88%E5%B9%B6%E9%93%BE%E8%A1%A8/</id>
    <published>2022-01-05T12:49:18.000Z</published>
    <updated>2022-01-10T09:31:19.591Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是关于单链表的合并问题，1.合并两个有序链表；2.合并k个有序链表（堆）。</p><p>涉及 leetcode 的 <a href="https://leetcode-cn.com/problems/merge-two-sorted-lists">21. 合并两个有序链表</a>和 <a href="https://leetcode-cn.com/problems/merge-k-sorted-lists">23. 合并K个升序链表</a>。</p></blockquote><span id="more"></span><h2 id="合并两个有序链表">合并两个有序链表</h2><h3 id="题目1">题目1</h3><p>首先来看题目<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists">21. 合并两个有序链表</a>：将两个升序链表合并为一个新的<strong>升序</strong>链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p>示例1：</p><blockquote><p>输入：l1 = [1,2,4], l2 = [1,3,4]</p><p>输出：[1,1,2,3,4,4]</p></blockquote><p>示例2：</p><blockquote><p>输入：l1 = [], l2 = [0]</p><p>输出：[0]</p></blockquote><h3 id="理解一下1">理解一下1</h3><p>题目的大概意思就是：</p><ol type="1"><li>将两个本身就有序（升序）的链表合并起来，得到一个新的链表依旧是有序的；</li><li>并且新的链表依旧使用原本链表中的结点，而不是创建新的结点。（也就是用next指针指来指去）。</li></ol><p>基本的思路是：</p><ol type="1"><li>首先创建一个链表头<code>res</code>来表示最终的链表；</li><li>然后分别使用两个指针指向链表<code>l1</code>和链表<code>l2</code>；</li><li>再比较<code>l1</code>和<code>l2</code>对应结点的值的大小，将小的结点连接到<code>res</code>中；</li><li><code>l1</code>和<code>l2</code>不断向后遍历，重复3，最后剩下没遍历完的就直接放在<code>res</code>后。</li></ol><h3 id="解题1">解题1</h3><p>以上的思路忽略了一些细节（n，n-1，1，0等这些边界问题），这里我们在处理第一个结点（无前结点）的时候还是需要分类讨论的，所以根据数据结构的定义，引入所谓的<code>头结点</code>，这样第一个结点就和其他结点都一样了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 头结点</span></span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    ListNode* p = dummy;</span><br><span class="line">    ListNode* p1 = list1, *p2 = list2;</span><br><span class="line">    <span class="comment">// 谁的结点小就将谁接在链表 dummy 后</span></span><br><span class="line">    <span class="keyword">while</span>(p1 &amp;&amp; p2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1-&gt;val &gt; p2-&gt;val)&#123;</span><br><span class="line">            p-&gt;next = p2;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            p-&gt;next = p1;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 跳出 while 循环的条件必然是至少一条链遍历结束了，那么剩下的一条的后续部分直接接在 dummy 中即可。</span></span><br><span class="line">    <span class="keyword">if</span>(p1)</span><br><span class="line">        p-&gt;next = p1;</span><br><span class="line">    <span class="keyword">if</span>(p2)</span><br><span class="line">        p-&gt;next = p2;</span><br><span class="line">    <span class="comment">// 题目需要返回的是没有头结点的，所以是 next。</span></span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合并k个有序链表">合并K个有序链表</h2><h3 id="题目2">题目2</h3><p>同样先看一下题目<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists">23. 合并K个升序链表</a>：给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p>示例1：</p><blockquote><p>输入：lists = [ [1,4,5],[1,3,4],[2,6] ]</p><p>输出：[1,1,2,3,4,4,5,6]</p></blockquote><p>示例2：</p><blockquote><p>输入：lists = [ ]</p><p>输出：[ ]</p></blockquote><h3 id="理解一下2">理解一下2</h3><p>就相当于之前是两个有序链表两两合并，现在是K个链表进行有序合并成一个有序链表。</p><p>基本的思路有两个：</p><h4 id="两两合并2">两两合并2</h4><p>第一种方法是在上一题的基础上，直接进行两两合并，得到有序链表，当然这里也有两种思路：一个是直接进行<code>k-1</code>次两两合并，另一个是使用<strong>归并</strong>两两合并，无非是时间换空间的问题（嗷，还有一个问题是归并我不熟练）。</p><p>这里提供我用第一个思路写的k-1次归并题解，其中<code>mergeTwoLists</code>函数就是之前的两两合并（好家伙，直接复制！）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 无链表</span></span><br><span class="line">    <span class="keyword">if</span>(lists.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 仅有一个链表</span></span><br><span class="line">    <span class="keyword">if</span>(lists.<span class="built_in">size</span>() == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// k-1 次两两合并</span></span><br><span class="line">    ListNode * res = lists[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lists.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        res = <span class="built_in">mergeTwoLists</span>(res,lists[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小根堆合并">小根堆合并</h4><p>第二种方法需要使用数据结构——<strong>小根堆</strong>（本质上是一棵完全二叉树），通过堆的性质进行合并，在很多外部排序的时候会采用这种方法，同样的也有两个思路：</p><ol type="1"><li>一个是将所有的链表所有的结点都<strong>一次性</strong>扔到堆中（显然需要空间极大），然后依次从堆顶取出结点链接到链表<code>dummy</code>中即可；</li><li>另一个是以<code>k</code>个链表的头结点构建大小为<code>k</code>的小根堆，堆顶的的结点就是最小结点，将其拿出链接到链表<code>dummy</code>中即可，并将该链上的<code>next</code>结点加入小根堆，并进行调整，直至堆中无结点即可。</li></ol><p>很明显<strong>小根堆合并</strong>比<strong>两两合并</strong>好多了，但是实际 coding 的时候其实并不一定能写出来（orz），所以这两种方法作为思路，并提供了一个<code>labuladong</code>的 java 题解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 虚拟头结点</span></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode p = dummy;</span><br><span class="line">    <span class="comment">// 优先级队列，最小堆</span></span><br><span class="line">    PriorityQueue&lt;ListNode&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(</span><br><span class="line">        lists.length, (a, b)-&gt;(a.val - b.val));</span><br><span class="line">    <span class="comment">// 将 k 个链表的头结点加入最小堆</span></span><br><span class="line">    <span class="keyword">for</span> (ListNode head : lists) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="keyword">null</span>)</span><br><span class="line">            pq.add(head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 获取最小节点，接到结果链表中</span></span><br><span class="line">        ListNode node = pq.poll();</span><br><span class="line">        p.next = node;</span><br><span class="line">        <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pq.add(node.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// p 指针不断前进</span></span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="个人收获">个人收获</h2><p>这里主要学到的是对k个链表进行合并的思路：</p><ol type="1"><li>两两合并的方法其实很常见，在ML中，对多分类问题也经常使用多次二分类进行实现，本质上感觉还是很相似的，好吧不是一回事，总之是将问题进行拆分，然后再一个一个解决，虽然暴力（O(NK)），但是起码能够解决问题，不至于完全写不出来。</li><li>对于小根堆其实也是比较熟悉了，在数据结构中小根堆的<strong>画图</strong>我可是熟悉的一塌糊涂（除了考试没啥用），但是代码上就显得比较不熟练了，之后在树的这一个模块中再好好练一练。这个可以很好的降低时间的复杂度，相应的付出一些时间，不过效果要比两两合并好多（O(Nlogk)）。</li></ol>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是关于单链表的合并问题，1.合并两个有序链表；2.合并k个有序链表（堆）。&lt;/p&gt;
&lt;p&gt;涉及 leetcode 的 &lt;a href=&quot;https://leetcode-cn.com/problems/merge-two-sorted-lists&quot;&gt;21. 合并两个有序链表&lt;/a&gt;和 &lt;a href=&quot;https://leetcode-cn.com/problems/merge-k-sorted-lists&quot;&gt;23. 合并K个升序链表&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据结构算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="单链表" scheme="http://example.com/tags/%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    
    <category term="leetcode题解" scheme="http://example.com/tags/leetcode%E9%A2%98%E8%A7%A3/"/>
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
    <category term="k路问题" scheme="http://example.com/tags/k%E8%B7%AF%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>微信聊天记录制作词云图</title>
    <link href="http://example.com/2022/01/01/%E5%88%B6%E4%BD%9C%E8%AF%8D%E4%BA%91%E5%9B%BE/"/>
    <id>http://example.com/2022/01/01/%E5%88%B6%E4%BD%9C%E8%AF%8D%E4%BA%91%E5%9B%BE/</id>
    <published>2022-01-01T02:45:12.000Z</published>
    <updated>2022-01-01T04:33:47.324Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文记录了从微信聊天记录导出到制作完成词云图的过程</p><p>利用了python，GitHub开源项目完成，默认了解python和mysql基础知识。</p><p>设备：Windows、ipad</p></blockquote><span id="more"></span><h2 id="导出微信聊天记录有iosipados设备">导出微信聊天记录（有IOS/IpadOS设备）</h2><p>首先我们需要将手机端的聊天记录（手机端的聊天记录比较完整）传送到微信端，这一步需要大家首先有一台苹果设备，利用iTunes备份聊天信息。</p><ol type="1"><li><p>（安卓用户）打开微信，找到<code>设置-&gt;聊天-&gt;聊天记录备份与迁移-&gt;迁移聊天记录到另一台设备</code>，然后选择想要的聊天记录，最后用苹果设备扫描出现的二维码，等待传输完成即可。</p></li><li><p>当苹果设备备份完成后，下载<a href="https://support.apple.com/zh-cn/HT210384">iTunes</a>，用电脑连接苹果设备，这时候在iTunes上会出现一个设备图标，点击并打开</p><img src="/2022/01/01/%E5%88%B6%E4%BD%9C%E8%AF%8D%E4%BA%91%E5%9B%BE/image-20220101105954123.png" class="" title="image-20220101105954123"></li><li><p>点击<code>摘要-&gt;备份-&gt;本电脑-&gt;立即备份</code>，等待片刻使其备份完成。</p><img src="/2022/01/01/%E5%88%B6%E4%BD%9C%E8%AF%8D%E4%BA%91%E5%9B%BE/image-20220101110318002.png" class="" title="image-20220101110318002"></li><li><p>在Windows中，聊天记录一般在<code>C:\Users\用户名\AppData\Roaming\Apple Computer\MobileSync\Backup</code>内，使用<a href="https://github.com/BlueMatthew/WechatExporter/releases/download/v1.8.0.10/v1.8.0.10_x64_win.zip">WechatExporter-Windows</a>或<a href="https://github.com/BlueMatthew/WechatExporter/releases/download/v1.8.0.10/v1.8.0.10_x64_macos.zip">WechatExporter-MacOS</a>来解析文件，之后图片及聊天记录就会存在选定的文件夹中。若仅需要聊天记录文件的txt文件，则在<code>格式</code>中选择<code>文本</code>即可。</p><img src="/2022/01/01/%E5%88%B6%E4%BD%9C%E8%AF%8D%E4%BA%91%E5%9B%BE/image-20220101111144265.png" class="" title="image-20220101111144265"></li></ol><h2 id="聊天记录入库">聊天记录入库</h2><p>至此文件解析成功，接下来就是使用python对聊天记录导出的内容进行清洗过滤，得到<code>发送时间</code>、<code>用户名</code>和<code>聊天内容</code>，并保存到数据库中（当然也可以不用，自己对代码进行修改即可）如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">from</span> pymysql.converters <span class="keyword">import</span> escape_string</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_time</span>(<span class="params">time_str</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;将12小时日期时间转化为24小时制时间</span></span><br><span class="line"><span class="string">    Args: time_str (str): 12小时日期时间字符串，例如:2021-03-30 10:00:33 PM</span></span><br><span class="line"><span class="string">    Returns: str: 24小时制日期时间，例如:2021-03-30 22:00:33</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    str1 = time_str[-<span class="number">2</span>:]  <span class="comment"># 格式</span></span><br><span class="line">    data = time_str[:-<span class="number">3</span>]  <span class="comment"># 时间</span></span><br><span class="line">    <span class="keyword">if</span> str1.lower() == <span class="string">&quot;am&quot;</span> <span class="keyword">and</span> <span class="built_in">int</span>(time_str[-<span class="number">11</span>:-<span class="number">9</span>]) == <span class="number">12</span>:</span><br><span class="line">        hour = <span class="string">&quot;00&quot;</span></span><br><span class="line">        data = time_str[<span class="number">0</span>:<span class="number">11</span>] + hour + time_str[-<span class="number">9</span>:-<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">if</span> str1.lower() == <span class="string">&quot;pm&quot;</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">int</span>(time_str[-<span class="number">11</span>:-<span class="number">9</span>]) &lt; <span class="number">12</span>:</span><br><span class="line">            hour = <span class="built_in">str</span>(<span class="built_in">int</span>(time_str[-<span class="number">11</span>:-<span class="number">9</span>])+<span class="number">12</span>)</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># int(time_str[-11:-9]) == 12</span></span><br><span class="line">            hour = <span class="string">&quot;12&quot;</span></span><br><span class="line">        data = time_str[<span class="number">0</span>:<span class="number">11</span>] + hour + time_str[-<span class="number">9</span>:-<span class="number">3</span>]</span><br><span class="line">    str2 = time.mktime(time.strptime(data, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>))  <span class="comment"># 转换为时间戳</span></span><br><span class="line">    finally_result = <span class="built_in">str</span>(time.strftime(</span><br><span class="line">        <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, time.localtime(str2)))  <span class="comment"># 转换为指定格式</span></span><br><span class="line">    <span class="keyword">return</span> finally_result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">filter_lines = []  <span class="comment"># 最终的聊天信息</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;你的聊天记录路径.txt&quot;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    lines = f.readlines()</span><br><span class="line">    reg = <span class="string">&quot;^.+[\u4E00-\u9FFF]\s\(.+\):&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="comment"># 仅保留互相发送的信息记录</span></span><br><span class="line">        <span class="keyword">if</span> (line.startswith(<span class="string">&#x27;对方的用户名&#x27;</span>) <span class="keyword">or</span> line.startswith(<span class="string">&#x27;你的用户名&#x27;</span>)) <span class="keyword">and</span> re.match(reg, line):</span><br><span class="line">            filter_lines.append(line.strip())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接数据库</span></span><br><span class="line">conn = pymysql.connect(</span><br><span class="line">    host=<span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">    user=<span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    password=<span class="string">&#x27;123456&#x27;</span>,</span><br><span class="line">    db=<span class="string">&#x27;wechat_report&#x27;</span>,  <span class="comment"># 需要先建好</span></span><br><span class="line">    charset=<span class="string">&#x27;utf8mb4&#x27;</span>,</span><br><span class="line">    port=<span class="number">3306</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建游标</span></span><br><span class="line">cur = conn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据表</span></span><br><span class="line">create_sql = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">CREATE TABLE `log` (</span></span><br><span class="line"><span class="string">  `id` bigint(20) NOT NULL AUTO_INCREMENT,</span></span><br><span class="line"><span class="string">  `user` varchar(100) DEFAULT NULL,</span></span><br><span class="line"><span class="string">  `datetime` datetime DEFAULT NULL,</span></span><br><span class="line"><span class="string">  `content` text,</span></span><br><span class="line"><span class="string">  PRIMARY KEY (`id`)</span></span><br><span class="line"><span class="string">) ENGINE=InnoDB AUTO_INCREMENT=222187 DEFAULT CHARSET=utf8mb4;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">cur.execute(create_sql)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入数据表</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> filter_lines:</span><br><span class="line">    s1 = line.find(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    s2 = line.find(<span class="string">&quot;):&quot;</span>)</span><br><span class="line">    name = line[:s1]  <span class="comment"># 发送者</span></span><br><span class="line">    chattime = line[s1 + <span class="number">2</span>:s2]  <span class="comment"># 带有am/pm的12小时制时间</span></span><br><span class="line">    chattime = convert_time(chattime)  <span class="comment"># 转化为24小时制时间</span></span><br><span class="line">    content = line[s2 + <span class="number">2</span>:]  <span class="comment"># 聊天内容</span></span><br><span class="line">    insert_sql = <span class="string">f&quot;insert into log(user,datetime,content) values (&#x27;<span class="subst">&#123;name&#125;</span>&#x27;,&#x27;<span class="subst">&#123;chattime&#125;</span>&#x27; ,&#x27;<span class="subst">&#123;escape_string(content)&#125;</span>&#x27;)&quot;</span></span><br><span class="line">    cur.execute(insert_sql)</span><br><span class="line">conn.commit()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;一共有<span class="subst">&#123;<span class="built_in">len</span>(lines)&#125;</span>条聊天记录&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="聊天记录分词计算词频">聊天记录分词，计算词频</h2><p>从数据库中将数据读出，并使用<code>jieba</code>进行分词，统计每个词出现的次数，整理成<code>&#123;'word': str, 'count':number&#125;</code>的格式，并按照词频大小进行排序。</p><p>导出为使用<code>;</code>隔开的csv格式</p><blockquote><p>jieba分词的效果还是不错的，但是其实分析聊天记录的时候更想要的是关于句意吧，所以其实并没有达到我的预期。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接数据库</span></span><br><span class="line">conn = pymysql.connect(</span><br><span class="line">    host=<span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">    user=<span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    password=<span class="string">&#x27;123456&#x27;</span>,</span><br><span class="line">    db=<span class="string">&#x27;wechat_report&#x27;</span>,</span><br><span class="line">    charset=<span class="string">&#x27;utf8mb4&#x27;</span>,</span><br><span class="line">    port=<span class="number">3306</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立游标</span></span><br><span class="line">cur = conn.cursor()</span><br><span class="line"></span><br><span class="line">cur.execute(<span class="string">&quot;select * from log&quot;</span>)</span><br><span class="line">r = cur.fetchall()  <span class="comment"># 获得全部聊天记录</span></span><br><span class="line"></span><br><span class="line">result = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得最长的一句话</span></span><br><span class="line">max_item = <span class="literal">None</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> r:</span><br><span class="line">    content = item[<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">if</span> (max_item <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(content) &gt; <span class="built_in">len</span>(max_item[<span class="number">3</span>])) <span class="keyword">and</span> content.find(<span class="string">&#x27;http&#x27;</span>) == -<span class="number">1</span>:</span><br><span class="line">        max_item = item</span><br><span class="line"><span class="built_in">print</span>(max_item)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行分词</span></span><br><span class="line">word_arr = []</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> r:</span><br><span class="line">    content = item[<span class="number">3</span>]</span><br><span class="line">    seg_list = jieba.cut(content)</span><br><span class="line">    word_arr = word_arr + <span class="built_in">list</span>(seg_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算词频</span></span><br><span class="line">word_count_map = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> word_arr:</span><br><span class="line">    <span class="keyword">if</span> word <span class="keyword">in</span> word_count_map:</span><br><span class="line">        word_count_map[word] = word_count_map[word] + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        word_count_map[word] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 组合成字典</span></span><br><span class="line">word_count_arr = []</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> word_count_map:</span><br><span class="line">    o = &#123;</span><br><span class="line">        <span class="string">&#x27;word&#x27;</span>: word,</span><br><span class="line">        <span class="string">&#x27;count&#x27;</span>: word_count_map[word]</span><br><span class="line">    &#125;</span><br><span class="line">    word_count_arr.append(o)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按词频排序</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">custom_sort</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x[<span class="string">&#x27;count&#x27;</span>] &gt; y[<span class="string">&#x27;count&#x27;</span>]:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> x[<span class="string">&#x27;count&#x27;</span>] &lt; y[<span class="string">&#x27;count&#x27;</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result[<span class="string">&#x27;word&#x27;</span>] = <span class="built_in">sorted</span>(word_count_arr, key=functools.cmp_to_key(custom_sort))</span><br><span class="line"></span><br><span class="line"><span class="comment"># with open(&quot;wechat-report\bin\result.json&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:</span></span><br><span class="line"><span class="comment">#     f.write(</span></span><br><span class="line"><span class="comment">#         json.dumps(result, ensure_ascii=False)</span></span><br><span class="line"><span class="comment">#     )</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用分号隔开写入csv文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;wechat-report\bin\result.csv&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> result[<span class="string">&#x27;word&#x27;</span>]:</span><br><span class="line">        f.write(i[<span class="string">&#x27;word&#x27;</span>]+<span class="string">&#x27;;&#x27;</span>+<span class="built_in">str</span>(i[<span class="string">&#x27;count&#x27;</span>])+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="制作词云">制作词云</h2><p>词云的制作利用了一个还不错的网站<a href="https://wordart.com/create">Word Art</a>。</p><ol type="1"><li>words中使用<code>import</code>导入使用分号隔开的csv文件（复制粘贴进来）；</li><li>shapes可以选择形状；</li><li>fonts中记得导入中文字体，该网站默认仅支持英文字体；</li><li>其他的自己探索吧，我也没仔细设置，点击上方中间红色按钮<code>Visualize</code>生成词云，下载项中可以免费下载普通画质的，也还可以了。</li></ol><h2 id="参考内容">参考内容</h2><p><a href="https://github.com/myth984/wechat-report">myth984/wechat-report: 微信聊天记录年度报告 (github.com)</a></p><p><a href="https://github.com/BlueMatthew/WechatExporter">BlueMatthew/WechatExporter: Wechat Chat History Exporter 微信聊天记录导出程序 (github.com)</a></p><p><a href="https://wordart.com/create">Word Art - Edit - WordArt.com</a></p><p><a href="https://izihun.com/zitixiazai-450.html?from_code=10033">沐瑶软笔手写体(Muyao-Softbrush)_TTF字体下载-字魂网 (izihun.com)</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文记录了从微信聊天记录导出到制作完成词云图的过程&lt;/p&gt;
&lt;p&gt;利用了python，GitHub开源项目完成，默认了解python和mysql基础知识。&lt;/p&gt;
&lt;p&gt;设备：Windows、ipad&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="工具" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="词云" scheme="http://example.com/tags/%E8%AF%8D%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>hexo的迁移</title>
    <link href="http://example.com/2021/12/29/hexo%E7%9A%84%E8%BF%81%E7%A7%BB/"/>
    <id>http://example.com/2021/12/29/hexo%E7%9A%84%E8%BF%81%E7%A7%BB/</id>
    <published>2021-12-29T09:05:01.000Z</published>
    <updated>2021-12-29T12:02:08.983Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>为了重新开始写点东西，而且换了电脑，所以将博客进行了一次迁移，在此记录一些坑，其实真的很简单！，本质上就是拷贝！</p></blockquote><span id="more"></span><h2 id="安装必备环境">安装必备环境</h2><p>有关一些环境的准备在<a href="https://gipbear.github.io/2021/01/05/hexo%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/">hexo 的安装和配置</a>说明过了，当然，这不完全相同，我这次在新电脑中并没有采用yarn来安装，不过这个无所谓。</p><p>简单说明一下需要安装<code>git客户端</code>和<code>nodejs</code>，至今的npm一般在安装nodejs中都已经包含了。</p><p>安装<code>hexo</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><h2 id="git关联github">git关联github</h2><p>首先，生成本地密钥（如果已经有了则不需要），这会在本地用户的<code>.ssh</code>文件夹中出现一个私钥<code>id_rsa</code>（妥善保管！），以及一个公钥<code>id_rsa.pub</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;example@example.com&quot;</span></span><br></pre></td></tr></table></figure><p>然后在个人Github的Settings中找到侧边<a href="https://github.com/settings/keys">SSH and GPG keys</a>，点击<code>New SSH key</code>，将公钥<code>id_rsa.pub</code>中的内容复制到其中即可。</p><p>会发个邮件给你的邮箱，点击确认一下。</p><p>在git中输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssh git@github.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 出现如下内容即可：</span></span><br><span class="line"><span class="comment"># PTY allocation request failed on channel 0</span></span><br><span class="line"><span class="comment"># Hi XXX! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span><br><span class="line"><span class="comment"># Connection to github.com closed.</span></span><br></pre></td></tr></table></figure><h2 id="新建空文件夹用来做为博客使用">新建空文件夹用来做为博客使用</h2><p>初始化hexo至空文件夹<code>hexo_blog</code>中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init hexo_blog</span><br></pre></td></tr></table></figure><p>切换至<code>hexo_blog</code>文件夹中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> hexo_blog</span><br></pre></td></tr></table></figure><p>尝试启动hexo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>很不幸，我出现了一些问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ERROR Cannot find module <span class="string">&#x27;hexo&#x27;</span> from <span class="string">&#x27;E:\hexo_blog&#x27;</span></span><br><span class="line">ERROR Local hexo loading failed <span class="keyword">in</span> E:\hexo_blog</span><br><span class="line">ERROR Try running: <span class="string">&#x27;rm -rf node_modules &amp;&amp; npm install --force&#x27;</span></span><br></pre></td></tr></table></figure><p>于是我按照他的建议，执行了如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf node_modules &amp;&amp; npm install --force</span><br></pre></td></tr></table></figure><p>很不幸，又出了问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm WARN using --force I sure hope you know what you are doing.</span><br><span class="line">npm WARN deprecated urix@0.1.0: Please see https://github.com/lydell/urix<span class="comment">#deprecated</span></span><br><span class="line">npm WARN deprecated resolve-url@0.2.1: https://github.com/lydell/resolve-url<span class="comment">#deprecated</span></span><br><span class="line">npm ERR! Unexpected end of JSON input <span class="keyword">while</span> parsing near <span class="string">&#x27;...a69f8709d4bd17ffe153b&#x27;</span></span><br><span class="line"></span><br><span class="line">npm ERR! A complete <span class="built_in">log</span> of this run can be found <span class="keyword">in</span>:</span><br><span class="line">npm ERR!     C:\Users\username\AppData\Roaming\npm-cache\_logs\2021-12-29T08_54_26_243Z-debug.log</span><br></pre></td></tr></table></figure><p>经查找，发现只需要清除一下npm的cache即可，<a href="https://segmentfault.com/a/1190000015646531">原文在此</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm cache clean --force</span><br></pre></td></tr></table></figure><p>接下来再本地<code>hexo s</code>启动一下服务试试看，发现大功告成！</p><blockquote><p>以上步骤大致如此，不行就删了博客文件夹重来，反正也是空空的！</p><p>放心大胆的试吧</p></blockquote><h2 id="迁移博客">迁移博客</h2><p>实际上只需要将原电脑上的文章和一些配置拷贝过来即可，主要是三个文件夹和一个配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scaffolds</span><br><span class="line"><span class="built_in">source</span></span><br><span class="line">themes</span><br><span class="line">_config.yml</span><br></pre></td></tr></table></figure><p>首先清除public中的内容，然后重新再生成内容，并发布</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo d</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure><h2 id="完成">完成</h2><p>OK，至此就完成了，本质上也就是重新搭建博客，然后将配置文件和已经有的内容给拷贝过来就可以了，也没有很麻烦嘛!</p><h2 id="关于一些小问题">关于一些小问题</h2><p>迁移之后有很多东西可能跟之前不一样了，包括版本，安装的包之类的，所以还需要根据具体情况来自己踩坑，目前我发现了两个。</p><blockquote><p>插件都是需要自己在新设备上重新安装的，这个没有在上面的步骤中拷贝过来！！</p></blockquote><h3 id="本地图片上传失败">本地图片上传失败</h3><p>原本安装的<code>hexo-asset-image</code>插件不能使用了，重新安装后出现了严重警告和错误，经过查找资料发现是该插件不能用了，所以采用其他方法。参考<a href="https://blog.pakro.top/2021/solve_the_problem_that_after_upgrade_to_hexo5_local_image_cannot_be_displayed_while_deployed/">解决 hexo5 本地图像上传后无法显示的问题</a></p><p>首先，卸载安装的<code>hexo-asset-image</code>；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>然后，同样修改修改博客配置文件<code>_config.yml</code>中的 <code>post_asset_folder</code>为<code>true</code>；</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>最后，安装<code>post_asset_folder</code>。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>在之后在博客中就正常使用原方法传文件即可。</p><h3 id="主题中添加搜索功能">主题中添加搜索功能</h3><p>安装<code>hexo-generator-searchdb</code>插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure><p>首先修改<strong>博客</strong>配置文件<code>_config.yml</code>，如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure><p>然后，修改<strong>主题</strong>配置文件<code>_config.yml</code>如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span>  <span class="comment"># trigger若为auto, 通过改变输入触发搜索；trigger若为manual, 通过按下enter键或者点击搜索按钮触发搜索</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span>  <span class="comment"># 展示每篇文章的前n个结果，如果想要展示所有结果，设置为-1</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span>  <span class="comment"># 将html字符串转义为可读的字符串。</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span>  <span class="comment"># 当加载页面时预加载搜索结果</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;为了重新开始写点东西，而且换了电脑，所以将博客进行了一次迁移，在此记录一些坑，其实真的很简单！，本质上就是拷贝！&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="配置" scheme="http://example.com/categories/%E9%85%8D%E7%BD%AE/"/>
    
    
    <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>STP分析</title>
    <link href="http://example.com/2021/02/25/STP%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2021/02/25/STP%E5%88%86%E6%9E%90/</id>
    <published>2021-02-25T07:18:22.000Z</published>
    <updated>2021-02-25T14:17:24.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是根据《活用数据|驱动业务的数据分析实战》中的案例进行的学习总结，主要是针对彩电用户的特征和行为，从研究调查问卷组成，以及分析问卷统计用户偏好。</p><p>适用于需要结合案例学习数据分析方法的初学者。</p></blockquote><span id="more"></span><h2 id="总体思路">总体思路</h2><p>甲保险公司的主要经营业务是车险，为了在激烈的竞争中获胜，决定以精准营销为发展策略，针对车险目标用户开展定制服务。</p><p><code>研究目的</code>是其了根据用户的偏好，对用户进行精准营销。由于个体的差异，所有的用户不可能同时喜欢一个产品，即使将全部的用户作为目标市场，也只会获得部分客户购买产品，这样反而付出了巨大的代价，却获得很小的收益。所以需要开展市场细分（Market Segmenting），寻找目标市场（Market Target），进行市场定位（Market Positioning），从而达到精准营销的目的。</p><p><code>研究内容</code>主要是对客户按照不同维度进行分类，衡量用户在各个维度上的差异。主要有5种分类维度：</p><ul><li>自然属性因素：性别、年龄、地域等；</li><li>社会特征因素：收入、职业、教育等；</li><li>行为特征因素：用户购物行为的五个阶段各个因素（<a href="https://gipbear.github.io/2021/02/21/用户偏好分析案例/">用户偏好分析案例</a>中几个方面）；</li><li>态度偏好因素：心理需求、购买动机、使用习惯、使用体验与态度倾向等；</li><li>生活状态与个性因素：客户生活方式、价值观和个性特点等。</li></ul><p>其中前三种属于<code>事前分类维度</code>，这些维度表露在外，接触用户时，企业可以从中凭借经验进行分类，对企业起到<strong>验证性作用</strong>。后两种属于<code>事后分类维度</code>，需要对用户进行深入调研，才能进行了解，体现了用户的<strong>内在本质</strong>，需要根据事后的客户分类项目，从中对用户进行分类，对企业起到<strong>探索性作用</strong>。</p><h2 id="调查问卷">调查问卷</h2><p>调查问卷从以下几个方面展开：</p><ol type="1"><li>甄别问题：是否购买车险</li><li>自然属性因素：性别、年龄、城市</li><li>社会属性因素：学历、家庭月收入、职业、汽车价格</li><li>行为特征因素：<ol type="1"><li>产生需求阶段：决策时间</li><li>信息收集阶段：是否收集信息、从什么渠道收集信息</li><li>方案比选阶段：投保渠道</li><li>购买决策阶段保险公司的选择、<u>保费金额</u></li><li>购后行为阶段：索赔经历</li></ol></li><li>态度偏好因素：<u>一站式服务考虑程度</u>、<u>网上投保考虑程度</u>、<u>产品个性化考虑程度</u>、选择保险公司的考虑因素、满意度</li><li>生活状态与个性因素：<u>对自己的生活很满意</u>、<u>为享受而产生的浪费是必要的</u>、<u>买房子前要先有车</u>、<u>不惜金钱和时间装修房子</u>、<u>买衣服都买便宜的</u>、<u>休息时经常进行户外活动</u>、<u>尝试生活充满变化</u>、<u>喜欢独自享受安静的生活</u>、<u>下班后尽快回家</u>。</li></ol><h2 id="调研计划">调研计划</h2><p>与上一篇<a href="https://gipbear.github.io/2021/02/21/用户偏好分析案例/#调研计划">调研计划</a>类似，不再赘述。</p><h2 id="数据分析架构">数据分析架构</h2><p>分析的架构按照STP分析理论展开，从市场细分、目标市场和市场定位三个方面进行。</p><p>数据分析的架构如图所示。</p><img src="/2021/02/25/STP%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%9E%B6%E6%9E%84.png" class="" title="image-20210225164041236"><h3 id="客户细分">客户细分</h3><ul><li><p>首先需要确定<strong>分类维度</strong>，若选择多个维度，则需要尽量保证维度之间不存在相关性，可以使用因子分析进行处理，并进行标准化处理。</p><p>由于事先分类优于事后分类。所以选择客户<u>生活状态的9个问题</u>作为第一个细分维度。由于9个问题之间存在一定的相关性，会使得具有相关性的因素影响扩大，所以使用对数据进行降维。一般会采用<strong>因子分析</strong>，并得到<u>因子类别</u>作为最终的细分维度。</p><p>同时，客户的购买行为十分显著的区分客户购买行为，所以选择<u>保费金额</u>作为第二个细分维度。</p><p>由于因子类别是分类数据、保费金额是数值数据，两个因素的量纲并不相同，所以使用<strong>标准化统一量纲</strong>，使其具有可比性。</p></li><li><p>其次选择合适的<strong>细分方法</strong>。</p><p>单一维度的细分直接使用交叉分析就可以完成，直接找到客户在某个因素上的区别。</p><p>多个维度则需要使用一些机器学习的方法进行，根据是有监督问题还是无监督问题进行选择。</p></li><li><p>最后使用选择的细分方法对客户进行<strong>聚类</strong>。此处无监督的可以使用聚类分析方法进行，获得细分类别。对于聚类效果可以使用方差分析进行<strong>检验</strong>，依旧按照<span class="math inline">\(显著性&lt;0.05\)</span>来判断。之后给通过交叉分析和比较均值，来<strong>刻画</strong>客户在细分类别和保费金额上的区别，并给客户群体<strong>命名</strong>。</p></li></ul><h4 id="因子分析">因子分析</h4><p>对数据进行因子分析之前，要先检验原始因素中是否存在相关性。通过SPSS的<code>分析-降维-因子</code>直接进行因子分析，根据选项会得到各个计算结果。</p><ul><li>在<code>对话框的“描述”中选择KMO和Bartlett的球形度检验</code>，当<span class="math inline">\(显著性&lt;0.05\)</span>时说明适合做因子分析。</li><li>公因子方差表明提取的因子对原始因素的解释能力。总方差解释是将<span class="math inline">\(特征值&gt;1\)</span>的因子作为最后的因子。</li><li>成分矩阵存储的是因子载荷，说明提取后的各个因子对原始维度的解释程度。但是可能存在多个因子对同一个原始因素都具有解释性，这与因子分析要剔除相关性冲突，所以需要进行因子旋转，使得最终因子之间的差异最大，可以在<code>对话框的“旋转”中选择最大方差法</code>，使得每个维度上仅有一个最大的因子载荷。</li><li>在<code>对话框的“得分”中选择保存为变量和显示因子得分系数矩阵</code>，利用得到的因子得分系数矩阵能够计算各个因子的得分并保存。通过<code>转换-计算变量</code>将4个因子转化为一个变量，即因子类别。</li></ul><h4 id="聚类分析">聚类分析</h4><p>聚类分析一般有两者方法，一种是层次分析，一种迭代聚类。</p><ul><li>层次聚类：主要思想是逐层合并，按照样本距离，将最近的样本归为一类，接着将形成的类别与较近的样本合并为一类，依次聚成一类，其形状类似于一棵树状图。</li><li>迭代聚类：最常见的是K-Means聚类，根据指定的聚类数k，随机选择k个初始点，将用户归为最近的初始点，重新计算聚类后的中心点，并再次聚类，通过不断的迭代计算中心点直至收敛，获得最后的聚类结果。</li></ul><p>关于其特征和性能上的一些区别：</p><table><thead><tr class="header"><th></th><th>层次聚类</th><th>迭代聚类</th></tr></thead><tbody><tr class="odd"><td>思路</td><td>逐层合并</td><td>不断迭代</td></tr><tr class="even"><td>类别数</td><td>未知，得到树状图进行判断</td><td>需要指定</td></tr><tr class="odd"><td>计算速度</td><td>反复计算距离，大样本或多变量时候较慢</td><td>计算量小，常用于处理大样本</td></tr><tr class="even"><td>聚类对象</td><td>记录或变量</td><td>仅记录</td></tr><tr class="odd"><td>数据类型</td><td>连续变量或分类变量</td><td>连续变量</td></tr></tbody></table><h3 id="目标客户选择">目标客户选择</h3><p>这部分和上一节内容类似，主要分为市场吸引力和自身竞争力两部分来考虑。</p><ul><li><p>首先选择衡量客户吸引力和企业竞争力的<strong>指标</strong>，作为选择客户的标准。通过内部讨论，决定使用客户规模和保费金额来衡量客户吸引力，使用市场份额指标衡量企业竞争力。</p></li><li><p>其次根据各类细分客户在这些指标上的表现，计算各类客户<strong>得分</strong>。使用频数统计细分类别获得客户规模，以及均值分析获得保费金额在细分类别上的均值，得分由客户吸引力和企业竞争力加权计算得到。</p></li><li><p>最后使用矩阵分析的方法<strong>选择</strong>企业目标客户。根据获得的得分绘制散点图，形成波士顿矩阵。</p></li></ul><h3 id="目标客户定位">目标客户定位</h3><p>确定目标客户之后，需要找出目标客户的<strong>特征</strong>，以及该目标客户对哪种产品具有<strong>需求</strong>。需要进行目标客户特征描述和目标客户需求定位。</p><ul><li>目标客户的特征描述：首先利用方差分析判断目标客户与其他客户在哪些方面具有显著差异，再将具有差异的因素利用SPSS中的<code>分析-降维-最优标度</code>获得特征上的具体差异。</li><li>目标客户需求定位：同样先进行方差分析判断哪些方面具有显著差异，这些分类数据可以使用<code>交叉表</code>来描述具体差异。当得到用户不满意的结论时，需要进一步挖掘用户哪里不满意，进行深入分析。</li></ul><h2 id="个人收获">个人收获</h2><p>通过</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是根据《活用数据|驱动业务的数据分析实战》中的案例进行的学习总结，主要是针对彩电用户的特征和行为，从研究调查问卷组成，以及分析问卷统计用户偏好。&lt;/p&gt;
&lt;p&gt;适用于需要结合案例学习数据分析方法的初学者。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据分析实战" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="STP" scheme="http://example.com/tags/STP/"/>
    
  </entry>
  
  <entry>
    <title>用户偏好分析案例</title>
    <link href="http://example.com/2021/02/21/%E7%94%A8%E6%88%B7%E5%81%8F%E5%A5%BD%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/"/>
    <id>http://example.com/2021/02/21/%E7%94%A8%E6%88%B7%E5%81%8F%E5%A5%BD%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/</id>
    <published>2021-02-21T08:11:43.000Z</published>
    <updated>2021-02-25T08:01:02.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是根据《活用数据|驱动业务的数据分析实战》中的案例进行的学习总结，主要是针对彩电用户的特征和行为，从研究调查问卷组成，以及分析问卷，来统计用户偏好。</p><p>适用于需要结合案例学习数据分析方法的初学者。</p></blockquote><span id="more"></span><h2 id="总体思路">总体思路</h2><p>国内某彩电企业为了摆脱价格战，提高核心竞争力，从用户入手，针对不同用户偏好，展开差异化营销。同样地，我们需要明确研究目的和研究内容。</p><p><code>研究目的</code>很简单，就是<strong>开展差异化营销</strong>。差异化营销是使得企业最大限度地满足用户需求，从而提高企业的营业业绩；那么差异化营销在该企业是否可行，就需要考虑多个维度的因素，基于时间思维和结构思维进行分析，将用户偏好分为五个阶段和七个要素。</p><p><code>研究内容</code>就围绕五个阶段和七个要素进行展开：</p><ul><li>产生需求阶段：购买的原因（why）、决策时间（when）、了解程度（how much）</li><li>信息收集阶段：获取信息的渠道（where）、关注哪些信息（what）</li><li>方案比选阶段：比较时考虑的因素（what）、各因素考虑的程度（how）</li><li>购买决策阶段：最终买的是什么（what）</li><li>购后行为阶段：如何使用彩电（how）</li></ul><h2 id="调查问卷">调查问卷</h2><p>根据以上的研究内容，设计一份调查问卷，来获得相应的调查数据，来进行定量分析。</p><p>问卷结果由以下几个问题组成： 1. 问卷编号 2. 是否购买彩电：S1甄别问题 3. 产生需求阶段：Q1购买原因，Q2决策时间，Q3了解程度 4. 信息收集阶段：Q4信息渠道，Q5关注信息 5. 方案比选阶段：Q6刻录功能考虑程度，Q7耗电量考虑程度，Q8上网功能考虑程度，Q9他人推荐考虑程度，Q10促销活动考虑程度，Q11感兴趣的促销活动 6. 购买决策阶段：Q12品牌，Q13价格，Q14外观，Q15规格，Q16颜色 7. 购后行为阶段：Q17安装方式，Q18摆放位置 8. 用户背景信息：A1性别，A2年龄，A3学历，A4家庭收入，A5住房面积，A6家庭成员</p><h2 id="调研计划">调研计划</h2><p>完成调查问卷的创建之后，紧接着进行问卷调查，这里需要明确6个问题： * 调查方法：例如中心定点拦截访问（CIL） * 调查对象：某天之后购买过彩电的用户 * 调查地点与样本量： * 项目周期： * 项目成员及职责： * 项目经理：负责整个项目的统筹控制，业务沟通、制定方案、控制进度及质量、团队协调沟通 * 督导员：向项目经理汇报工作进展，招聘和监督访问员，对访问质量直接负责 * 访问员：负责实际访问，向督导员汇报工作进度 * 数据处理人员：调查问卷审核，数据录入，数据检查和对数据质量进行评价 * 数据分析人员：对调查和处理好的数据进行研究分析 * 报告撰写与宣讲人员：撰写分析报告并向相关领导汇报 * 项目质量与进度控制：安排跟访，保证数据真实有效性，并及时汇报和录入数据</p><h2 id="数据处理">数据处理</h2><p>调查得到的数据是最原始的数据，其中可能会出现很多的问题，所以需要对数据先进行处理，主要分为四个步骤： * 数据集成：将多个数据源的数据进行合并 * 数据转换：对数据进行标准化处理 * 数据消减：对数据进行聚合和降维，减小数据规模 * <strong>数据清洗</strong>：数据筛选、数据去重、填补缺失值和数据纠错。（本案例仅关注数据清洗）</p><h3 id="数据编码">数据编码</h3><p>其中方案比选阶段的Q6-Q10数据为数值数据，可以直接进行数据分析，而其他数据均为类别数据，需要使用编码格式进行数值转换</p><p>针对<strong>不存在大小</strong>的分类数据，可以直接使用set容器去重，再使用map进行<strong>硬编码</strong>，若存在大小的，最好还是手动创建map参数。例如下面非比较类型分类数据的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;A&#x27;</span>:[<span class="string">&#x27;一&#x27;</span>,<span class="string">&#x27;二&#x27;</span>,<span class="string">&#x27;一&#x27;</span>,<span class="string">&#x27;三&#x27;</span>,<span class="string">&#x27;一&#x27;</span>,<span class="string">&#x27;一&#x27;</span>,<span class="string">&#x27;三&#x27;</span>],</span><br><span class="line">                   <span class="string">&#x27;B&#x27;</span>:[<span class="string">&#x27;aa&#x27;</span>,<span class="string">&#x27;bb&#x27;</span>,<span class="string">&#x27;cc&#x27;</span>,<span class="string">&#x27;cc&#x27;</span>,<span class="string">&#x27;bb&#x27;</span>,<span class="string">&#x27;aa&#x27;</span>,<span class="string">&#x27;dd&#x27;</span>],</span><br><span class="line">                   <span class="string">&#x27;C&#x27;</span>:[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]&#125;)</span><br><span class="line"></span><br><span class="line">df_obj= df.select_dtypes(<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line">datamap = []</span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> df_obj.columns:</span><br><span class="line">    datamap.append(&#123;elem: index+<span class="number">1</span> <span class="keyword">for</span> index, elem <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">set</span>(df[col]))&#125;)</span><br></pre></td></tr></table></figure><h3 id="数据清洗">数据清洗</h3><p>首先通过数据筛选，将<code>S1甄别问题</code>为<code>1</code>的问卷筛选出来，因为购买了彩电的用户才是我们需要分析的用户。</p><p>然后对数据进行去重，针对的是问卷编号，保证每个问卷仅出现一次。</p><p>再对处理数据中存在的缺失值，可以找到缺失值的位置，找到相应问卷进行查看并填补；若问卷上也不存在，则对数值型数据使用统计值填补，对分类型数据使用众数填补；或者少量数据可以直接删除。</p><p>最后进行数据纠错，数据的错误类型主要有两种，一种是非逻辑错误，就是在问卷调查或录入数据的时候出现差错，这需要加强调研的各个环节的质量监控；另一种是逻辑错误，例如，性别男为“1”，女为“2”，但是录入了3，这种属于逻辑错误，需要在数据编码的时候进行控制。</p><h2 id="分析架构">分析架构</h2><p>用户偏好分析主要分为三个部分：</p><ol type="1"><li>用户基本特征描述：用户的特征不同，结论分析往往不同，可以协助业务方在下结论的时候注意应用对象。</li><li>用户整体偏好分析：对于问卷中的数值数据可以使用<strong>均值分析</strong>用户整体偏好，对于非数值数值使用<strong>频数统计</strong>反映用户整体情况。</li><li>各类用户偏好分析：将用户偏好和用户基本特征做<strong>比较均值</strong>或<strong>交叉分析</strong>。</li></ol><blockquote><p>在此之前需要利用<strong>方差分析</strong>，检验不同用户之间是否存在<strong>显著差异</strong>，若存在，做差异对比才有意义。</p></blockquote><h2 id="实例演示">实例演示</h2><p>详见我在Github上的<a href="https://github.com/Gipbear/data-analysis/blob/master/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/%E7%94%A8%E6%88%B7%E5%81%8F%E5%A5%BD%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E6%9F%90%E5%BD%A9%E7%94%B5%E4%BC%81%E4%B8%9A%E7%94%A8%E6%88%B7%E5%81%8F%E5%A5%BD%E5%88%86%E6%9E%90/%E6%9F%90%E5%BD%A9%E7%94%B5%E4%BC%81%E4%B8%9A%E7%94%A8%E6%88%B7%E5%81%8F%E5%A5%BD%E5%88%86%E6%9E%90.ipynb">代码</a></p><h2 id="分析结果解读">分析结果解读</h2><p>最后根据以上得到的各个分析结果，进行可视化图像进行分析比较，得到最终结论。</p><p>// todo: 详细的会在之后学习了数据分析经验之后再来分析一下。</p><h2 id="个人收获">个人收获</h2><p>总体上学到了有几点，首先是学会了如何设计一个比较全面的问卷调查方法，需要考虑需要的各个方面，从需求开始，从分支扩展，按照需要的、可能的、与结论相关的因素进行讨论，由此编写有效的问卷；其次第一次进行编码操作，之前学会的硬编码和热编码并没有使用，所以未知其用途，在这里发现在方差分析的时候，必须使用编码参数进行调用；最后，发现python或许是万能的，但并不是最方便的，这些统计分析之类的，需要自己慢慢编写程序，而在spss中却是及其方便，由此我以后或许可以尝试，使用python进行清洗整理数据以及机器学习相关，使用spss完成统计分析，以及使用tableau实现图表可视化。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是根据《活用数据|驱动业务的数据分析实战》中的案例进行的学习总结，主要是针对彩电用户的特征和行为，从研究调查问卷组成，以及分析问卷，来统计用户偏好。&lt;/p&gt;
&lt;p&gt;适用于需要结合案例学习数据分析方法的初学者。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据分析实战" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="调查问卷" scheme="http://example.com/tags/%E8%B0%83%E6%9F%A5%E9%97%AE%E5%8D%B7/"/>
    
    <category term="数据编码" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81/"/>
    
    <category term="方差分析" scheme="http://example.com/tags/%E6%96%B9%E5%B7%AE%E5%88%86%E6%9E%90/"/>
    
    <category term="频数统计" scheme="http://example.com/tags/%E9%A2%91%E6%95%B0%E7%BB%9F%E8%AE%A1/"/>
    
    <category term="交叉分析" scheme="http://example.com/tags/%E4%BA%A4%E5%8F%89%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>快乐Linux学习（六）</title>
    <link href="http://example.com/2021/02/19/%E5%BF%AB%E4%B9%90Linux%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89/"/>
    <id>http://example.com/2021/02/19/%E5%BF%AB%E4%B9%90Linux%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89/</id>
    <published>2021-02-19T13:25:05.000Z</published>
    <updated>2021-03-12T03:25:02.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要是介绍Linux中的正则表达式</p><p>适用于需要学习正则表达式的同学。</p></blockquote><span id="more"></span><p>正则表达式是一种符号表示法，用来识别文本模式，与之前使用过的路径通配符有些相似，但是功能更强大。</p><p>需要注意的是，很多系统和编程语言的都是具有正则表达式这个规则的，但是并不完全相同，此处仅学习Linux系统下POSIX标准中藐视的正则表达式，之后其他系统触类旁通学习即可。</p><h2 id="grep">grep</h2><p>主要使用的是grep程序，名字来自于“global regular expression print”，能够在文本文件中查找一个指定的正则表达式，并将匹配到的结果进行输出。</p><p>例如先使用ls标准输出/usr/bin的目录名，再通过管道，grep从管道中接受输入，并将匹配结果进行输出。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /usr/bin | grep zip</span><br></pre></td></tr></table></figure><p>不通过管道的表达式如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [options] regex [file...]</span><br></pre></td></tr></table></figure><p>选项options有下列情况：</p><table><thead><tr class="header"><th>选项</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>-i</td><td>忽略大小写</td></tr><tr class="even"><td>-v</td><td>获得不匹配项</td></tr><tr class="odd"><td>-c</td><td>获得匹配的数量</td></tr><tr class="even"><td>-l/-L</td><td>打印存在匹配/不匹配项的文件夹名</td></tr><tr class="odd"><td>-n</td><td>打印匹配项的行号和结果</td></tr></tbody></table><h2 id="元字符和原义字符">元字符和原义字符</h2><p>上面grep后的<code>zip</code>，其中的“z”，“i”，“p”都是按照原本的意思和顺序进行匹配的，这些称为原义字符，需要使用其他规则进行匹配的时候，还包含如下<strong>元字符</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^ $ . [ ] &#123; &#125; - ? * + ( ) | \</span><br></pre></td></tr></table></figure><p>其中POSIX 规范的字符集又将元字符又存在两种情况，基本正则表达式（BRE）和扩展的正则表达式（ERE），BRE中支持的是<code>^ $ . [ ] *</code>，ERE在此基础上扩展了<code>( ) &#123; &#125; ? + |</code>，使用的时候需要增加<code>-E</code>选项表示执行ERE标准。</p><table><thead><tr class="header"><th>元字符</th><th>解释</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>.</td><td>任何字符</td><td>可以用来匹配在某个位置的任意<strong>一个</strong>字符。</td></tr><tr class="even"><td>^ / $</td><td>锚点</td><td>该表达式在文本开头/末尾存在才会被匹配。“^$”组合可以匹配空行。</td></tr><tr class="odd"><td>[ ]</td><td>指定字符集</td><td>从中括号内的指定字符集匹配<strong>一个</strong>字符。元字符在被放置到中括号中后将会失去本身的特殊含义，除了“^”和“-”。</td></tr><tr class="even"><td>^</td><td>否定</td><td>在<strong>中括号内第一个字符</strong>时表示否定，匹配中括号内字符集以外的字符。</td></tr><tr class="odd"><td>-</td><td>字符范围</td><td>例如[a-z]，[B-Y]，[4-9a-h]等。</td></tr><tr class="even"><td>|</td><td>交替</td><td>允许从一系列表达式之间选择匹配项。</td></tr><tr class="odd"><td>？</td><td></td><td>匹配零个或一个元素。</td></tr><tr class="even"><td>*</td><td></td><td>匹配零个或多个元素。</td></tr><tr class="odd"><td>+</td><td></td><td>匹配一个或多个元素。</td></tr><tr class="even"><td>{ }</td><td></td><td>匹配特定个数的元素，n：元素只出现n次，n,m：元素出现[n,m]次，n,：元素出现不少于n次，,m：元素出现不多于m次。</td></tr></tbody></table><p>补充一些字符集：[:word:]=[:alnum:]+[_]；[:alnum:]=[:alpha:]+[:digit:]；[:blank:]=空格+tab；[:cntrl:]=0-31和127字符；[:lower:]；[:upper:]；[:punct:]=标点符号；[:print:]=[:graph:]+[:space:]；[:xdigit:]=[0-9A-Fa-f]</p><p>其他的基本都可以被视为<strong>原义字符</strong>。元字符也可以被<strong>反斜杠</strong>转义为原义字符。</p><blockquote><p>所以之前在shell执行的时候，存在的一些元字符等特殊符号会被展开，这时候就可以使用引号阻止其展开。</p></blockquote><h2 id="应用正则表达式">应用正则表达式</h2><h3 id="使用grep匹配">使用grep匹配</h3><p>首先使用下列语句生成一个测试的搜索匹配列表，多尝试几次，生成不符合“(nnn) nnn-nnnn”格式的电话号码，以便用来匹配。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i in &#123;1..10&#125;; do echo &quot;($&#123;RANDOM:0:3&#125;) $&#123;RANDOM:0:3&#125;-$&#123;RANDOM:0:4&#125;&quot; &gt;&gt;phonelist.txt; done</span><br></pre></td></tr></table></figure><p>再使用cat和管道连接grep，因为使用了扩展的正则表达式，所以需要使用-E选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat phonelist.txt | grep -Ev &#x27;^\([0-9]&#123;3&#125;\) [0-9]&#123;3&#125;-[0-9]&#123;4&#125;&#x27;</span><br></pre></td></tr></table></figure><h3 id="使用find查找">使用find查找</h3><p>查找某个路径下的文件名是否符合满足正则表达式要求，例如查找当前路径下包含空格等不符合规范的路径名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -regex &#x27;.*[^-\_./0-9a-zA-Z].*&#x27;</span><br></pre></td></tr></table></figure><h3 id="利用locate查找文件">利用locate查找文件</h3><p>locate支持基本的（--regexp）和扩展的（regex）正则表达式。例如搜索包含指定字符串的路径名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate --regex &#x27;bin/(bz|gz|zip)&#x27;</span><br></pre></td></tr></table></figure><h3 id="在lessvim中使用正则表达式">在less/vim中使用正则表达式</h3><p>less是使用“<code>/</code>”命令输入正则表达式进行匹配</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">less phonelist.txt</span><br><span class="line">/^\([0-9]&#123;3&#125;\) [0-9]&#123;3&#125;-[0-9]&#123;4&#125;$</span><br></pre></td></tr></table></figure><p>vim也类似，不过vim中使用扩展表达式会被认作为文本字符，需要使用反斜杠进行转义为元字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/([0-9]\&#123;3\&#125;) [0-9]\&#123;3\&#125;-[0-9]\&#123;4\&#125;</span><br></pre></td></tr></table></figure><p>默认是没有高亮显示的，想要高亮显示的话可以在命令模式下输入<code>:set hlsearch</code>转化为高亮模式。</p><h2 id="个人收获">个人收获</h2><p>本章主要学习的是正则表达式，了解到不同系统和语言会具有不完全相同的正则表达式，主要是用于之后的查找和筛选，以及在处理数据的时候能够利用规则直接提取相关信息，比较重要。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文主要是介绍Linux中的正则表达式&lt;/p&gt;
&lt;p&gt;适用于需要学习正则表达式的同学。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="正则表达式" scheme="http://example.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>战略分析案例——网上商城</title>
    <link href="http://example.com/2021/02/16/%E6%88%98%E7%95%A5%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/"/>
    <id>http://example.com/2021/02/16/%E6%88%98%E7%95%A5%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/</id>
    <published>2021-02-16T11:42:23.000Z</published>
    <updated>2021-02-25T07:42:18.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是根据《活用数据|驱动业务的数据分析实战》中的案例进行的学习总结，主要是从内外部因素对企业网上商城进行定性和定量分析，并结合波士顿矩阵进行分析。</p><p>适用于需要结合案例学习数据分析方法的初学者。</p></blockquote><span id="more"></span><h2 id="总体思路">总体思路</h2><p>进行战略分析的分析思路是进行研究目的和研究内容的分解，下面对此分别进行考虑。</p><p>首先考虑<code>研究目的</code>，这里是帮助商城进行<strong>战略选择</strong>，选择最适合商城的目标市场。对此我们需要分析两个因素：</p><ul><li>外部因素——市场吸引力：市场情况如何，是否有希望获得足够的利益；</li><li>内部因素——企业竞争力：企业是否有能力进入市场，进入市场后能够获得多少利益。</li></ul><p>其次分析<code>研究内容</code>，主要是进行环境分析，包括宏观环境、市场环境、竞争环境分析。</p><h2 id="环境分析">环境分析</h2><h3 id="宏观环境分析">宏观环境分析</h3><p>宏观环境是指影响市场的各种宏观原因，可以利益PEST进行概况：</p><ul><li>政治环境 Political</li><li>经济环境 Economic</li><li>社会文化环境 Social</li><li>技术环境 Technological</li></ul><p>通过宏观环境分析，企业可以判断出，对某企业而言，哪些因素是机会，哪些因素是威胁，若<strong>机会大于威胁</strong>，则说明该市场具有吸引力。</p><h3 id="市场环境分析">市场环境分析</h3><p>市场环境是指市场的<strong>具体情况</strong>，需要考虑的因素比较多，比较倾向于市场规模大、利润水平高、增长速度快、成长潜力强、所处生命周期成长期等，这种市场对于企业更具有吸引力。但是大部分市场并不会同时满足以上条件，所以，需要企业按照自身资源和定位情况进行取舍。</p><p>通过以上宏观环境和市场环境可以分析得出市场对企业是否具有吸引力，但是并不是具有吸引力的市场，就一定会使得企业获利，因为我们还需要对比企业自身优势进行分析。优势并不是绝对的，而是相对的，其相对于竞争环境，所以需要进行竞争环境分析。</p><h3 id="竞争环境分析">竞争环境分析</h3><p>企业的竞争环境可以归纳为影响企业生存状况的波特五力，包括供应商、购买者、直接竞争对手、替代品和潜在进入者五个方面的力。</p><p>通过对比分析这企业在五力中的情况，如果总体处于上风，则表明企业具有竞争力。</p><h2 id="实例演示">实例演示</h2><p>本案例是在jupyter上进行的，可以参考我在Github上相应的<a href="https://github.com/Gipbear/data-analysis/blob/master/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/%E8%B4%AD%E7%89%A9%E4%B8%AD%E5%BF%83%E7%BD%91%E4%B8%8A%E5%95%86%E5%9F%8E%E6%88%98%E7%95%A5%E5%88%86%E6%9E%90/%E6%9F%90%E8%B4%AD%E7%89%A9%E4%B8%AD%E5%BF%83%E7%BD%91%E4%B8%8A%E5%95%86%E5%9F%8E%E6%88%98%E7%95%A5%E5%88%86%E6%9E%90.ipynb">代码</a></p><ol type="1"><li><p>首先导入需要使用的依赖包（个人偏好都添加在第一行）;</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> mpl</span><br><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> set_matplotlib_formats</span><br><span class="line"></span><br><span class="line">%matplotlib inline</span><br></pre></td></tr></table></figure></p></li><li><p>读取excel表格，依次读取各个sheet中的内外因素评价矩阵;</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">df1 = pd.read_excel(<span class="string">&#x27;data/内外因素评价矩阵数据.xlsx&#x27;</span>,sheet_name=<span class="number">0</span>)</span><br><span class="line">col_name = [<span class="string">&#x27;分数&#x27;</span>,<span class="string">&#x27;电商在销售渠道地位凸显&#x27;</span>,<span class="string">&#x27;国内消费者信心指数攀升&#x27;</span>,<span class="string">&#x27;电子商务交易额迅速增长&#x27;</span>,<span class="string">&#x27;通过电商可以掌握用户界面&#x27;</span>,<span class="string">&#x27;国家政策的扶持&#x27;</span>]</span><br><span class="line">df1.columns = col_name</span><br><span class="line"></span><br><span class="line">df2 = pd.read_excel(<span class="string">&#x27;data/内外因素评价矩阵数据.xlsx&#x27;</span>,sheet_name=<span class="number">1</span>)</span><br><span class="line">col_name = [<span class="string">&#x27;分数&#x27;</span>,<span class="string">&#x27;激烈的市场竞争&#x27;</span>,<span class="string">&#x27;电子商务诚信制度未完善&#x27;</span>,<span class="string">&#x27;网络安全缺乏坚实保障&#x27;</span>]</span><br><span class="line">df2.columns = col_name</span><br><span class="line"></span><br><span class="line">df3 = pd.read_excel(<span class="string">&#x27;data/内外因素评价矩阵数据.xlsx&#x27;</span>,sheet_name=<span class="number">2</span>)</span><br><span class="line">col_name = [<span class="string">&#x27;分数&#x27;</span>,<span class="string">&#x27;实力强大&#x27;</span>,<span class="string">&#x27;消费者信誉良好&#x27;</span>,<span class="string">&#x27;良好的企业形象&#x27;</span>,<span class="string">&#x27;透明化贴心服务&#x27;</span>]</span><br><span class="line">df3.columns = col_name</span><br><span class="line"></span><br><span class="line">df4 = pd.read_excel(<span class="string">&#x27;data/内外因素评价矩阵数据.xlsx&#x27;</span>,sheet_name=<span class="number">3</span>)</span><br><span class="line">col_name = [<span class="string">&#x27;分数&#x27;</span>,<span class="string">&#x27;缺乏电商运营经验&#x27;</span>,<span class="string">&#x27;缺乏网购消费者群体&#x27;</span>,<span class="string">&#x27;网站建设不完整&#x27;</span>,<span class="string">&#x27;物流体系未真正建成&#x27;</span>]</span><br><span class="line">df4.columns = col_name</span><br></pre></td></tr></table></figure></p></li><li><p>计算权重分为两个步骤：</p><ol type="1"><li><p>计算评分均值：将专家人数作为权重<span class="math inline">\(f\)</span>，对分数<span class="math inline">\(x_i\)</span>求其加权平均值： <span class="math display">\[ \bar{x} = \frac{\sum{x_i \times f_i}}{\sum{f_i}} \]</span></p></li><li><p>计算权重：权重的确定方法有很多，大体分为主观赋权法（层次分析法等）和客观赋权法（主成分分析法等），此处采用变异系数方法来计算： <span class="math display">\[ \text{V} = \frac{\sigma}{\bar{x}}  \]</span> 其中<span class="math inline">\(\sigma\)</span>是标准差，<span class="math inline">\(\sigma=\sqrt{\sum{(x_i-x)^2 \times Pi}}\)</span>，而其中<span class="math inline">\(\sum{(x_i-x)^2}\)</span>是该因素的离差平方和，<span class="math inline">\(P_i\)</span>是该因素的频率。</p></li></ol><blockquote><p>在评价体系中，若某个因素的取值差异较大，则说明该因素难以实现，是反映评价对象差距的关键因素，就要赋予更大的权重。</p><p>变异系数在数值上等于标准差除以均值，可以表示因素取值的波动情况，因此这里可以使用变异系数来赋权。</p></blockquote><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算变异系数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coefficient_variation</span>(<span class="params">df,dfn,num</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    df: 统计矩阵</span></span><br><span class="line"><span class="string">    dfn: 矩阵编号</span></span><br><span class="line"><span class="string">    num: 样本数</span></span><br><span class="line"><span class="string">    res: 样本评分</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    me = df[<span class="string">&#x27;分数&#x27;</span>].dot(df.iloc[:,<span class="number">1</span>:])/num <span class="comment"># 计算评分均值</span></span><br><span class="line">    dfa = df.iloc[:,<span class="number">1</span>:]/num <span class="comment"># 计算分数频率</span></span><br><span class="line">    s = df[<span class="string">&#x27;分数&#x27;</span>]-me[dfn]</span><br><span class="line">    dfb = s*s <span class="comment"># 计算分数离差平方和</span></span><br><span class="line">    dfc = dfb.dot(dfa).apply(np.sqrt) <span class="comment"># 计算标准差</span></span><br><span class="line">    dfd = dfc/me[dfn] <span class="comment"># 计算变异系数</span></span><br><span class="line">    <span class="keyword">return</span> dfd,me</span><br></pre></td></tr></table></figure></p></li><li><p>求得变异系数<span class="math inline">\(\text{V}\)</span>之后，使用<span class="math inline">\(W_i=\frac{V_i}{\sum{V_i}}\)</span>求得最终的权重，并计算各个评分均值加权平均数来获得最终的得分。</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算最后得分</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_score</span>(<span class="params">coeVar,me</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    coeVar: 变异系数</span></span><br><span class="line"><span class="string">    me: 评分均值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    weights = coeVar / <span class="built_in">sum</span>(coeVar) <span class="comment"># 计算权重</span></span><br><span class="line">    score = weights.dot(me) <span class="comment"># 计算评分的加权平均数</span></span><br><span class="line">    <span class="keyword">return</span> score</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">coeVar, me= coefficient_variation(df1,<span class="number">0</span>,<span class="number">200</span>)</span><br><span class="line">score1 = get_score(coeVar,me)</span><br><span class="line">coeVar, me= coefficient_variation(df2,<span class="number">1</span>,<span class="number">200</span>)</span><br><span class="line">score2 = get_score(coeVar,me)</span><br><span class="line">coeVar, me= coefficient_variation(df3,<span class="number">2</span>,<span class="number">2000</span>)</span><br><span class="line">score3 = get_score(coeVar,me)</span><br><span class="line">coeVar, me= coefficient_variation(df4,<span class="number">3</span>,<span class="number">2000</span>)</span><br><span class="line">score4 = get_score(coeVar,me)</span><br></pre></td></tr></table></figure></p></li><li><p>得到各个优势、劣势、机会和威胁的最终得分之后，计算<span class="math inline">\(\frac{优势}{劣势}\)</span>的比值是否大于1，若大于1则说明优势大于劣势，企业具有竞争力，否则不具有竞争力；计算<span class="math inline">\(\frac{机会}{威胁}\)</span>的比值是否大于1，若大于1则说明机会大于威胁，市场具有吸引力，否则不具有吸引力。</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = score1/score2</span><br><span class="line">y = score3/score4</span><br></pre></td></tr></table></figure></p></li><li><p>根据求得的两个比值制作战略选择波士顿矩阵图，进行战略选择分析：</p><ol type="1"><li>SO战略：市场机会多，企业优势明显，属于增长型，利用外部机会和自身优势，创造最大收益；</li><li>WO战略：市场机会多，企业劣势明显，属于扭转型，利用外部机会，克服自身劣势，抓住机遇；</li><li>ST战略：市场威胁多，企业优势明显，属于多种经营型，依靠自身优势，回避外部威胁，勇敢面对挑战；</li><li>WT战略：市场威胁多，企业劣势明显，属于防御型，减少外部威胁和自身劣势，休养生息。</li></ol><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">set_matplotlib_formats(<span class="string">&#x27;svg&#x27;</span>)</span><br><span class="line">mpl.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>] <span class="comment"># 中文字体</span></span><br><span class="line"></span><br><span class="line">lim = <span class="built_in">max</span>(<span class="built_in">round</span>(x,<span class="number">1</span>),<span class="built_in">round</span>(y,<span class="number">1</span>)) + <span class="number">0.2</span> <span class="comment"># 坐标区间</span></span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">plt.scatter(x,y,marker=<span class="string">&#x27;o&#x27;</span>,s=<span class="number">100</span>) <span class="comment"># 绘制散点图</span></span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">&#x27;机会最终得分/威胁最终得分&#x27;</span>,fontsize=<span class="number">16</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;优势最终得分/劣势最终得分&#x27;</span>,fontsize=<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">plt.xlim(<span class="number">0</span>,lim)</span><br><span class="line">plt.ylim(<span class="number">0</span>,lim)</span><br><span class="line"></span><br><span class="line">plt.vlines(<span class="number">1</span>,<span class="number">0</span>,lim,colors=<span class="string">&quot;r&quot;</span>,linestyles=<span class="string">&quot;dashed&quot;</span>)</span><br><span class="line">plt.hlines(<span class="number">1</span>,<span class="number">0</span>,lim,colors=<span class="string">&quot;r&quot;</span>,linestyles=<span class="string">&quot;dashed&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.text(x+<span class="number">0.001</span>,y,<span class="string">&#x27;&#123;:.2f&#125; &#123;:.2f&#125;&#x27;</span>.<span class="built_in">format</span>(x,y),ha=<span class="string">&#x27;left&#x27;</span>,va=<span class="string">&#x27;bottom&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.text(<span class="number">0.02</span>,lim-<span class="number">0.12</span>,<span class="string">&#x27;&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;ST战略&#x27;</span>),ha=<span class="string">&#x27;left&#x27;</span>,va=<span class="string">&#x27;bottom&#x27;</span>,color=<span class="string">&quot;w&quot;</span>,fontsize=<span class="number">20</span>).set_bbox(<span class="built_in">dict</span>(facecolor=<span class="string">&#x27;black&#x27;</span>, alpha=<span class="number">0.5</span>))</span><br><span class="line">plt.text(<span class="number">0.02</span>,<span class="number">1</span>-<span class="number">0.12</span>,<span class="string">&#x27;&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;WT战略&#x27;</span>),ha=<span class="string">&#x27;left&#x27;</span>,va=<span class="string">&#x27;bottom&#x27;</span>,color=<span class="string">&quot;w&quot;</span>,fontsize=<span class="number">20</span>).set_bbox(<span class="built_in">dict</span>(facecolor=<span class="string">&#x27;black&#x27;</span>, alpha=<span class="number">0.5</span>))</span><br><span class="line">plt.text(<span class="number">1.02</span>,lim-<span class="number">0.12</span>,<span class="string">&#x27;&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;SO战略&#x27;</span>),ha=<span class="string">&#x27;left&#x27;</span>,va=<span class="string">&#x27;bottom&#x27;</span>,color=<span class="string">&quot;w&quot;</span>,fontsize=<span class="number">20</span>).set_bbox(<span class="built_in">dict</span>(facecolor=<span class="string">&#x27;black&#x27;</span>, alpha=<span class="number">0.5</span>))</span><br><span class="line">plt.text(<span class="number">1.02</span>,<span class="number">1</span>-<span class="number">0.12</span>,<span class="string">&#x27;&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;SWO战略&#x27;</span>),ha=<span class="string">&#x27;left&#x27;</span>,va=<span class="string">&#x27;bottom&#x27;</span>,color=<span class="string">&quot;w&quot;</span>,fontsize=<span class="number">20</span>).set_bbox(<span class="built_in">dict</span>(facecolor=<span class="string">&#x27;black&#x27;</span>, alpha=<span class="number">0.5</span>))</span><br></pre></td></tr></table></figure></p></li></ol><p>最终得到波士顿矩阵，如图：</p><img src="/2021/02/16/%E6%88%98%E7%95%A5%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/%E7%BD%91%E4%B8%8A%E5%95%86%E5%9F%8E%E6%88%98%E7%95%A5%E5%88%86%E6%9E%90%E6%B3%A2%E5%A3%AB%E9%A1%BF%E7%9F%A9%E9%98%B5%E5%9B%BE.svg" class="" title="网上商城战略分析波士顿矩阵图"><h2 id="结论">结论</h2><p>该购物中心网上商城的业务处于SO战略区，市场机会多，自身优势明显，可以充分利用市场机会和自身优势快速发展，创建最佳业务。</p><h2 id="个人收获">个人收获</h2><p>通过本案例的学习，首先掌握了PEST和波特五力两种分析思路，从宏观和细节上对分析对象进行细化；SWOT定性分析方法将细化后的对象进行内外因素分析，并通过量化方法进行定量分析。该案例有层次的、内外结合的、定性定量的分析，学习了如何进行一次全面的战略分析。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是根据《活用数据|驱动业务的数据分析实战》中的案例进行的学习总结，主要是从内外部因素对企业网上商城进行定性和定量分析，并结合波士顿矩阵进行分析。&lt;/p&gt;
&lt;p&gt;适用于需要结合案例学习数据分析方法的初学者。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据分析实战" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="战略分析" scheme="http://example.com/tags/%E6%88%98%E7%95%A5%E5%88%86%E6%9E%90/"/>
    
    <category term="PEST" scheme="http://example.com/tags/PEST/"/>
    
    <category term="SWOT" scheme="http://example.com/tags/SWOT/"/>
    
    <category term="波特五力" scheme="http://example.com/tags/%E6%B3%A2%E7%89%B9%E4%BA%94%E5%8A%9B/"/>
    
    <category term="波士顿矩阵" scheme="http://example.com/tags/%E6%B3%A2%E5%A3%AB%E9%A1%BF%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
  <entry>
    <title>林骥的思维分析模型（一）</title>
    <link href="http://example.com/2021/02/12/%E6%9E%97%E9%AA%A5%E7%9A%84%E6%80%9D%E7%BB%B4%E5%88%86%E6%9E%90%E6%A8%A1%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://example.com/2021/02/12/%E6%9E%97%E9%AA%A5%E7%9A%84%E6%80%9D%E7%BB%B4%E5%88%86%E6%9E%90%E6%A8%A1%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2021-02-12T04:14:05.000Z</published>
    <updated>2021-12-29T12:02:44.391Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是在对林骥公众号中的100种思维分析模型（更新中）上进行自我理解。</p><p>适用于想要了解多种分析模型的同学，主要是关于模型的一些应用和注意点，并没有具体的模型详解。</p></blockquote><span id="more"></span><h2 id="福格行为模型">福格行为模型</h2><p>该模型主要是用来分析<code>用户行为</code>的<u>产生原因</u>和<u>基础心理</u>。</p><p><span class="math display">\[行为 = 动机 \times 能力 \times 触发\]</span> 用户的行为由三要素决定（例如购物）：</p><ol type="1"><li>用户去做这件事情的动机（why用户购买产品）；</li><li>用户完成这件事情的能力（how让用户方便购买）；</li><li>触发用户去采取行动的信号（what触发用户想要购买）。</li></ol><p>在其中也暗含了4p营销理论：产品（Product）、价格（Price）、促销（Promotion）、渠道（Place）</p><h2 id="杜邦分析模型">杜邦分析模型</h2><p>该模型主要是对关键指标进行分解，在<code>财务分析</code>、<code>销售管理</code>方面有助于深入分析企业的经营业绩。</p><p>杜邦分析模型将指标之间的<u>内在联系</u>结合起来，形成一套类似金字塔结构，层次清晰的指标体系，从而暴露出影响业务的关键因素。</p><ol type="1"><li>从核心指标开始，逐层分解各个指标；</li><li>制作杜邦分析图，填入相关指标数据；</li><li>对比前后期数据，或者横向进行对比。</li></ol><h2 id="矩阵分析模型">矩阵分析模型</h2><p>该模型也称作波士顿矩阵或四象限分析法。通过两个关键指标组成象限即可进行分析。主要是用来分析<code>产品和结构</code>，其中特别关注<strong>销售增长率</strong>和<strong>市场占有率</strong>这两个指标。</p><ol type="1"><li>找出两种最关注的指标（销售增长率A和市场占有率B）；</li><li>绘制四象限分析图表（假设增长方向为从左至右和从下至上）；</li><li>分析总结并提出建议（AB均低的产品可以逐渐放弃，A高B低是有问题的产品，需要调整策略，A低B高则可以保持现状，AB均高的可以考虑加大投资）；</li></ol><p>针对不同的象限将产品进行分类，由此来采取不同的发展策略，从而实现产品结构的良性循环。</p><h2 id="夏普利值模型">夏普利值模型</h2><p>该模型综合考虑各方利益，使得所作和所得相等，保证利益分配的公平合理。主要在分配权力等问题上非常有用。</p><ol type="1"><li>列举角色可能出现的各种分配情况；</li><li>判断角色在分配过程是否起作用；</li><li>计算分析角色起作用的占比情况。</li></ol><p>价值并不在于拥有的资源或历史贡献，而是在所有可能的合作中，不可或缺的程度。</p><blockquote><p>我们的成长也需要提高核心竞争力。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是在对林骥公众号中的100种思维分析模型（更新中）上进行自我理解。&lt;/p&gt;
&lt;p&gt;适用于想要了解多种分析模型的同学，主要是关于模型的一些应用和注意点，并没有具体的模型详解。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="他山之石" scheme="http://example.com/categories/%E4%BB%96%E5%B1%B1%E4%B9%8B%E7%9F%B3/"/>
    
    
    <category term="思维方式" scheme="http://example.com/tags/%E6%80%9D%E7%BB%B4%E6%96%B9%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>mysql中位数</title>
    <link href="http://example.com/2021/02/06/mysql%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://example.com/2021/02/06/mysql%E4%B8%AD%E4%BD%8D%E6%95%B0/</id>
    <published>2021-02-06T15:15:59.000Z</published>
    <updated>2021-02-06T15:33:40.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是在mysql中查询一列<strong>奇数</strong>个数据的中位数。</p></blockquote><span id="more"></span><p>在<a href="https://www.hackerrank.com/dashboard">HackerRank</a>刷题的时候遇到了一道需要查询中位数的题目。</p><h2 id="题目">题目</h2><p>将中位数定义为：将数据集的上半部分与下半部分分开的数字，也就是仅存在一个中位数。</p><p>需要找出某列的中位数。</p><h2 id="思路">思路</h2><p>Station表中存在奇数个数据，那么我们要查找的LAT_N就是将数据分开后使得：上半部分个数=下半部分个数。</p><p>于是我们需要在查询该表Station S的同时，再创建两个相同的Station表来计算上下部分的LAT_N个数，在检查记录的同时比较上下两部分的数量，当数量相同的时候，该S.LAT_N就是需要得到的中位数。</p><h2 id="方案">方案</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select round(s.LAT_N,4)</span><br><span class="line">from station s</span><br><span class="line">where (select count(LAT_N)</span><br><span class="line">       from station</span><br><span class="line">       where LAT_N &lt; s.LAT_N) = (</span><br><span class="line">           select count(LAT_N)</span><br><span class="line">           from station</span><br><span class="line">           where (LAT_N &gt; s.LAT_N))</span><br></pre></td></tr></table></figure><h2 id="个人收获">个人收获</h2><p>当遇到比较抽象的问题的时候，需要学会转换思路，将抽象的中位数定义，转化为现实的，上下部分数量相同问题；也要熟悉mysql中创建新表和原表比较的方法。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是在mysql中查询一列&lt;strong&gt;奇数&lt;/strong&gt;个数据的中位数。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="增删改查" scheme="http://example.com/categories/%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/"/>
    
    
    <category term="select" scheme="http://example.com/tags/select/"/>
    
    <category term="中位数" scheme="http://example.com/tags/%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    
    <category term="mysql" scheme="http://example.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>python常用函数</title>
    <link href="http://example.com/2021/02/06/python%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <id>http://example.com/2021/02/06/python%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</id>
    <published>2021-02-06T05:39:21.000Z</published>
    <updated>2021-02-06T13:36:26.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文罗列了回顾python时候的一些常用函数</p></blockquote><span id="more"></span><ul><li><p><a href="https://www.hackerrank.com/challenges/text-alignment/problem">文字对齐</a>：</p><p><code>string.ljust(width,'-')</code>string在左侧；<code>string.center(width,'-')</code>string居中；<code>string.rjust(width,'-')</code>string在右侧</p></li><li><p><a href="https://www.hackerrank.com/challenges/text-wrap/problem">文本自动换行</a>：</p><p><code>textwrap.wrap(string, width)</code>获得list，使用<code>'\n'.join()</code>进行连接</p></li><li><p><a href="https://www.hackerrank.com/challenges/python-string-formatting/problem">矩阵显示多进制</a>：</p><p>二进制八进制以及十六进制的格式化显示，矩阵间距为二进制宽度。使用format进行格式化</p></li><li></li></ul><h2 id="个人收获">个人收获</h2>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文罗列了回顾python时候的一些常用函数&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    
    <category term="函数" scheme="http://example.com/tags/%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>幸存者偏差</title>
    <link href="http://example.com/2021/02/05/%E5%B9%B8%E5%AD%98%E8%80%85%E5%81%8F%E5%B7%AE/"/>
    <id>http://example.com/2021/02/05/%E5%B9%B8%E5%AD%98%E8%80%85%E5%81%8F%E5%B7%AE/</id>
    <published>2021-02-05T12:35:29.000Z</published>
    <updated>2021-02-05T14:01:04.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要解释了幸存者偏差的定义</p></blockquote><span id="more"></span><h2 id="定义">定义</h2><p>幸存者偏差（Survivorship bias）是指从筛选之后的<u>“幸存者”样本</u>中得到结论，从而产生的偏差。</p><h2 id="偏差影响">偏差影响</h2><p>这种偏差属于认知上的偏差，仅考虑了获得的样本，而忽视了未通过筛选的样本。在这种偏差下往往会出现两种常见的错误：<strong>规则推导</strong>和<strong>因果推断</strong>。</p><ul><li><p>规则推导：现存的事物是曾经唯一存在过的事物。</p><p>我们会假设自己所看到是事物是过去唯一的存在，而实际上很多过去的事物并未保存至今。（商朝流只传下青铜器，但是并不表示商朝只用青铜器）</p></li><li><p>因果推断：某个机制中幸存下来的事物都会受到该机制的影响。</p><p>并不是从该机制中幸存下来说明该机制影响了该事物，而是该事物满足了该机制的条件才得以幸存。</p></li></ul><h2 id="bi软件调研分析">BI软件调研分析</h2><p>假设一家商业智能（BI）软件公司正在开展2周免费使用活动，一周后剩下少数用书仍在使用，并且这些用户都是数据分析师，借助该软件进行了更加复杂的分析。</p><p>按照调研的结果，可能会得到两个<strong>错误</strong>的结论：</p><ul><li><p>BI软件的适用人群是数据分析师。</p><p>在下结论之前，同样需要观察那些<u>“非幸存者”</u>（放弃使用的用户），我们并不知道这些用户中是否也有数据分析师。如果我们的调研用户全部是数据分析师，若离开的用户比剩下的用户更多时，那么得出的结论则恰恰相反。</p><p>为了得到正确的结论，我们需要分析每一个一开始就加入使用的用户，找到真正能够区分同期群的用户特征。</p></li><li><p>BI软件让深入数据分析变得更加容易：</p><p>在调研中，我们并没有设置一个对照组来比较用户之间的<strong>分析能力</strong>，这些用户或许是在使用BI软件做最高级的任务，但是或许在其他软件上能够做更高级的事情，也获取用户本身就是资深的数据分析师，无论使用说明软件都能进行深入分析。而不是因为使用了该BI软件才能进行深入分析。</p><p>若要衡量该软件的真正价值，则需要先评估用户分析水平，然后对比在相似的分析任务，操作不同软件的表现，从而得到有说服力的结论。</p></li></ul><h2 id="个人收获">个人收获</h2><p>分析所有同期群的用户；衡量产品价值的时候需要和竞争对手的产品进行对比；对比用户使用前后的改变，得到产品带来的因果关系。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文主要解释了幸存者偏差的定义&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="统计学" scheme="http://example.com/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6/"/>
    
    
    <category term="误差" scheme="http://example.com/tags/%E8%AF%AF%E5%B7%AE/"/>
    
  </entry>
  
  <entry>
    <title>快乐Linux学习（五）</title>
    <link href="http://example.com/2021/02/01/%E5%BF%AB%E4%B9%90Linux%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <id>http://example.com/2021/02/01/%E5%BF%AB%E4%B9%90Linux%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89/</id>
    <published>2021-02-01T08:23:48.000Z</published>
    <updated>2021-02-02T14:41:20.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是快乐学习Linux的第五篇，是基于Windows的Linux子系统（WSL）进行操作的。</p><p>适用于学习Linux系统中shell环境和vi相关内容的读者。</p></blockquote><span id="more"></span><h2 id="shell环境">shell环境</h2><p>shell在shell会话中保存着大量的信息，这些信息被称为shell环境。</p><p>一般程序都是通过获取环境中的数据（<strong>环境变量</strong>）或<strong>配置文件</strong>来存储程序的设置，所以我们可以调整环境变量或配置文件来改变程序的行为。</p><p>在shell环境中，一般存储两种基本类型的数据，一种是环境变量，一种是shell变量（bash存放的少量数据）。</p><ul><li>printenv：可以显示环境变量，看到的是环境变量及其对应的数值。</li><li>set：可以显示环境变量、shell变量和自定义的shell函数，并且按照首字母排序。</li></ul><h2 id="shell启动文件">shell启动文件</h2><p>登录系统之后会启动bash程序，读取一些列称为启动文件的配置脚本，之后再读取用户home目录的启动文件，这两个启动文件分别定义了全局和个人的shell环境。其中的启动顺序根据shell会话类型来决定。</p><ul><li><p>登录shell会话</p><p>会提示用户输入用户名和密码，读取一个或多个启动文件。</p><p>首先是应用于所有用户的全局配置文件：<code>/etc/profile</code>，然后是用户个人的启动文件：在WSL下使用的是：<code>~/.profile</code>，其他的Linux版本可能是<code>~/.bash_profile</code>和<code>~/.bash_login</code>。</p></li><li><p>非登录shell会话</p><p>一般是在GUI下启动终端会话时出现，读取全局配置文件：<code>/etc/bash.bashrc</code>，以及个人配置文件：<code>~/.bashrc</code>。并会集成父进程的环境设置（一般是一个登录shell进程）。</p></li></ul><h3 id="修改配置文件">修改配置文件</h3><p>修改配置文件的时候，可以使用文本编辑器打开文件，例如使用下面会提到的<strong>vi</strong>进行修改。</p><p>修改之前可以对文件进行备份，通常使用扩展名<code>.bak</code>、<code>.sav</code>、<code>.old</code>等方式来备份：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp .bashrc .bashrc.bak</span><br></pre></td></tr></table></figure><p>然后修改<code>.bashrc</code>文件，遇到麻烦的时候可以再利用备份文件进行还原。</p><p>修改之后使用source来激活配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source .bashrc</span><br></pre></td></tr></table></figure><blockquote><p>一般来说，添加目录到PATH变量或定义额外的环境变量，需要把修改<code>.profile</code>文件（或替代文件<code>.bash_profile</code>），对于其他的修改则放在<code>.bashrc</code>文件中。</p></blockquote><h2 id="vi">vi</h2><p>在很多Linux系统都预装了vi程序，并且存在另一个高级替代版vim（vi improved），之后我们使用是vi实际上就是vim。vi具有轻量且快速的特点，相比于一些其他并不会在Linux上都预装的文本编辑器，在远程服务器上进行文本修改的时候，vi就显得相当方便了。</p><blockquote><p>最重要的是：不会的话会被其他Linux使用者嘲笑！所以加油吧:fist_oncoming:！</p></blockquote><h3 id="打开和退出">打开和退出</h3><p>首先最重要的是学会如何打开vi，并关闭它。</p><p>WSL已经预装了vim，我们在命令行输入vi或vim命令即可进入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi</span><br></pre></td></tr></table></figure><p>会发现显示<code>VIM - Vi IMproved</code>等内容，但实际上这些并不是打开了任何文件的内容，因为在vi中，行编辑最左侧出现了波浪号<code>~</code>说明该行内容为空。此时不要按下键盘上的任何键，因为我们此时处于vi的命令模式，如果我们需要退出的话，输入<code>:q</code>并按下回车就可以退出（出现在屏幕左下角，并且冒号是命令的一部分）。</p><blockquote><p>命令模式分为普通命令模式和ex模式，ex模式就是有冒号的命令，普通命令模式就是正常的命令，需要注意区分，在下文中，出现冒号的就是ex命令，否则就是普通命令。</p></blockquote><h3 id="移动光标">移动光标</h3><p>在vi的命令模式下，存在大量的移动命令：</p><table><thead><tr class="header"><th>按键</th><th>移动效果</th></tr></thead><tbody><tr class="odd"><td>k j h l或Alt+方向键</td><td>上下左右（方向）移动一个字符</td></tr><tr class="even"><td>0</td><td>移动到当前行的行首</td></tr><tr class="odd"><td>^</td><td>当前行第一个非空字符</td></tr><tr class="even"><td>$</td><td>当前行末尾</td></tr><tr class="odd"><td>b w或Shift+方向键</td><td>移动到上/下一个单词或标点的开头</td></tr><tr class="even"><td>B W或Ctrl+方向键</td><td>移动到上/下一个单词的开头</td></tr><tr class="odd"><td>G</td><td>文件末尾</td></tr></tbody></table><p>并且可以使用<strong>数字和命令</strong>来控制移动多少个字符或行，例如<code>5h</code>向左移动5个字符。</p><h3 id="编辑文本">编辑文本</h3><p>我们使用vi可以直接创建一个新的或打开一个已经存在的文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi foo.txt</span><br></pre></td></tr></table></figure><p>执行命令会出现空白界面，我们需要知道的是：<strong>vi是一个模式编辑器</strong>，此时进入的vi的<strong>命令模式</strong>，按下的每一个键都是命令，所以千万不要乱来！</p><p>我们按下<code>i</code>键，在左下角会出现<code>-- INSERT --</code>，表示进入了<u>插入</u>模式。此时可以输入一些文本。输入文本之后需要返回，需要使用<code>Esc</code>重新进入命令模式，如果需要<u>保存修改</u>则使用<code>:w</code>或保存并退出<code>:wq</code>，如果不需要保存则使用<code>:q!</code>。</p><p>当我们想要<u>撤回</u>的时候，可以使用<code>u</code>来撤回对文本的最后一次<strong>修改</strong>，注意和word中只撤回几个字不一样，这是撤回最后一次<strong>修改</strong>。</p><p>当我们再一次进入foo.txt文件时，光标会出现在上次退出的地方，当我们想要在行尾进行插入的时候，发现<code>i</code>只能出现在最后一个字符之前，所以我们使用<code>a</code>进行插入，同样会出现<code>-- INSERT --</code>，表示进入编辑模式，或者<code>A</code>直接到达编辑行的行尾。</p><p>当我们需要<u>插入空白行</u>的时候，可以使用命令<code>o</code>在光标下方插入一行，使用命令<code>O</code>在光标上方插入一行。</p><h3 id="删除剪切复制和粘贴">删除、剪切、复制和粘贴</h3><p>这些操作的命令和移动光标类似</p><table><thead><tr class="header"><th>按键</th><th>效果</th></tr></thead><tbody><tr class="odd"><td>[number]x</td><td>删除当前字符，及其后面number-1个字符</td></tr><tr class="even"><td>[number]dd</td><td>剪切当前行，及其后面number-1行</td></tr><tr class="odd"><td>d+移动光标的命令</td><td>移动光标决定剪切内容</td></tr><tr class="even"><td>[number]yy</td><td>复制当前行，及其后面number-1行</td></tr><tr class="odd"><td>y+移动光标的命令</td><td>移动光标决定复制内容</td></tr><tr class="even"><td>P/p</td><td>粘贴到光标前/后</td></tr></tbody></table><h3 id="查找和替换">查找和替换</h3><p>使用<code>/</code>命令来查找匹配的字符。例如<code>/line</code>找到所有line开头的字符，使用n命令重复查询操作（可循环查找）。</p><p>替换操作则略显复杂，例如将文本所有的line都替换为Line，需要输入命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/line/Line/gc</span><br></pre></td></tr></table></figure><p>%表示行数，省略则是执行当前行；s表示替换；/line/Line是查找与替换的文本；g是全局匹配，省略则是每行第一个匹配的进行替换；c是增加用户确认。</p><h3 id="多文件操作">多文件操作</h3><p>当我们需要进行多文件编辑的时候，就可以使用vi同时打开多个文本，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi foo.txt ls-output.txt</span><br></pre></td></tr></table></figure><p>此时屏幕显示第一个文件，使用<code>:n</code>切换到下一个文件，使用<code>:N</code>切换到上一个文件。也可以使用<code>:buffers</code>来查看打开的文件列表，使用<code>:buffer 编号</code>就可以切换编辑的文件。</p><p>当前文件修改而未保存的时候，vi会阻止我们进行跳转，在命令后添加感叹号可以强制跳转。</p><p>在打开的文件中，使用<code>:e 文件地址</code>就可以打开新的文件。</p><h2 id="个人收获">个人收获</h2><p>一些可以直接使用echo显得是命令原来就是shell环境中的变量，像path就和Windows中修改环境变量类似，影响着一些程序的运行，需要在安装一些程序的时候进行修改，例如安装WSL显示GUI界面，需要安装xlaunch，并且之后需要在.bashrc文件中进行一定的配置才能正常运行。</p><p>在vi编辑器方便则是学会基本的编辑操作和保存，有一定的认知即可，毕竟学习成本较高，正常情况下本人还是比较喜欢直接在Windows下使用交互式编辑器进行快速编辑。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是快乐学习Linux的第五篇，是基于Windows的Linux子系统（WSL）进行操作的。&lt;/p&gt;
&lt;p&gt;适用于学习Linux系统中shell环境和vi相关内容的读者。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="shell" scheme="http://example.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>快乐Linux学习（四）</title>
    <link href="http://example.com/2021/01/28/%E5%BF%AB%E4%B9%90Linux%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://example.com/2021/01/28/%E5%BF%AB%E4%B9%90Linux%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/</id>
    <published>2021-01-28T03:34:53.000Z</published>
    <updated>2021-02-01T08:24:46.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是快乐学习Linux的第四篇，是基于Windows的Linux子系统（WSL）进行操作的。</p><p>适用于学习Linux系统中文件权限和进程相关内容的读者。</p></blockquote><span id="more"></span><h2 id="权限">权限</h2><p>本系列的博客内容其实是建立在WSL上的，主要是仅给个人用户一个Linux环境，顺便来熟悉Linux系统，所以以下不会涉及太过复杂的权限设置，会覆盖基本的操作。</p><p>当我们使用ls -l进行查看的时候，会按照长模式的方式显示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件访问权限 硬链接数目 文件所属用户 文件所属用户组 文件大小 上次修改日期 文件名</span><br></pre></td></tr></table></figure><h3 id="文件访问权限">文件访问权限</h3><p>文件访问权限是由两部分组成的，一部分是文件类型，一部分是文件模式。</p><p>文件类型有：</p><ul><li>-：普通文件。</li><li>d：目录。</li><li>l：符号连接，其显示的文件模式都是虚拟值，真正的文件模式是链接指向的文件决定的。</li><li>c：字符设备文件，按照字节流处理数据的设备，例如终端机或者调制解调器。</li><li>b：块设备文件，按照数据块处理数据的设备，例如硬盘或者CD-ROM。</li></ul><p>文件模式由文件所有者、文件组所有者和其他人三种用户的三种基本的：可读r、可写w、可执行x（s、t什么的就不涉及了）组成，共9个字符。</p><table><thead><tr class="header"><th>属性</th><th>文件</th><th>目录</th></tr></thead><tbody><tr class="odd"><td>r</td><td>允许打开并读写文件内容</td><td>允许列出目录内容，前提是目录设置了x属性</td></tr><tr class="even"><td>w</td><td>允许写入文件内容。重命名或删除是根据目录属性来的</td><td>允许在目录下新建、删除或重命名文件，前提也是目录设置了x属性</td></tr><tr class="odd"><td>x</td><td>允许将文件作为程序来执行，脚本语言编写的程序必须具备</td><td></td></tr></tbody></table><h3 id="更改文件模式">更改文件模式</h3><p>我们可以使用chomd来更改文件模式，更改的方式有两种，一种是八进制数字表示法或符号表示法，由于本人倾向于八进制数字表示法，且确实很nice，所以就不介绍符号表示法了。</p><p><strong>八进制数字表示法</strong>是因为1个八进制恰好需要3个二进制位来表示，而3个权限刚好对应3个二进制位，那么3种用户就只需要使用3位八进制数来表示即可（缕一缕这句话，其实挺清楚的）。</p><p>例如<code>r--</code>就是100，也就是4，<code>rw-</code>就是110，也就是6，以此类推即可。</p><p>那么新建并修改foo.txt权限为<code>rwxrw-r--</code>只需要使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; foo.txt</span><br><span class="line">chmod 764 foo.txt</span><br></pre></td></tr></table></figure><h3 id="默认权限">默认权限</h3><p>当我们新建文件的时候会自动赋予一个默认权限，这里在<strong>WSL</strong>下，默认的是<code>rw-r--r--</code>，这是由<code>umask</code>进行控制的。</p><p>命令行使用<code>umask</code>进行查看，会发现响应的数值是0022，常用的Linux系统还有0002，对应着关闭了哪些权限，2指的就是10，也就是原始文件权限是<code>rw-rw-rw-</code>，根据umask的掩码来<strong>关闭</strong>某些权限，作为最终的默认权限。</p><p>一般不用修改，使用系统默认的就可以了。</p><h3 id="用户和用户组">用户和用户组</h3><p>针对具有多个用户和用户组的情况下，不同用户具有不同的文件的控制权。</p><ul><li><p>su [-[l]] [user]：是允许我们切换到另一个用户的身份，重新启动一个shell进程。</p><p>-l 表示切换shell环境，并更改工作目录到该用户下，没有用户名则默认是root，如下切换至root用户：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su -</span><br></pre></td></tr></table></figure></p><p>需要输入切换后用户的密码，登录后超级用户root显示的符号从“<code>$</code>”变为“<code>#</code>”，使用exit退出。</p></li><li><p>sudo：是允许一个普通用户以另一个用户的身份执行任务，本质上用户并没有切换，而且输入的密码是用户本身的密码，并且密码可以维持一段时间的信任。</p></li></ul><p>可以使用<code>chown [owner][:[group]] file</code>对文件的用户和用户组进行更改。</p><p>使用<code>passwd</code>可以更改密码。</p><h2 id="进程">进程</h2><h2 id="个人收获">个人收获</h2><p>关于文件和目录权限的内容并不过多赘述，之后存在需求之后再进行补充。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是快乐学习Linux的第四篇，是基于Windows的Linux子系统（WSL）进行操作的。&lt;/p&gt;
&lt;p&gt;适用于学习Linux系统中文件权限和进程相关内容的读者。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
</feed>
