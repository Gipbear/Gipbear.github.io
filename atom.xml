<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Grizzly&#39;s daily</title>
  
  
  <link href="https://gipbear.github.io/atom.xml" rel="self"/>
  
  <link href="https://gipbear.github.io/"/>
  <updated>2022-02-05T13:08:59.046Z</updated>
  <id>https://gipbear.github.io/</id>
  
  <author>
    <name>Grizzly</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>markdown表情集</title>
    <link href="https://gipbear.github.io/2022/02/05/markdown%E8%A1%A8%E6%83%85%E9%9B%86/"/>
    <id>https://gipbear.github.io/2022/02/05/markdown%E8%A1%A8%E6%83%85%E9%9B%86/</id>
    <published>2022-02-05T13:03:43.000Z</published>
    <updated>2022-02-05T13:08:59.046Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是小表情的markdown代码, 来自<a href="https://gist.github.com/rxaviers/7360908">GitHub</a>, 也可以使用<code>&lt;Win + .&gt;</code>快捷键来输入.</p></blockquote><span id="more"></span><p>People</p><table><colgroup><col style="width: 33%" /><col style="width: 33%" /><col style="width: 33%" /></colgroup><tbody><tr class="odd"><td>:bowtie: <code>:bowtie:</code></td><td>:smile: <code>:smile:</code></td><td>:laughing: <code>:laughing:</code></td></tr><tr class="even"><td>:blush: <code>:blush:</code></td><td>:smiley: <code>:smiley:</code></td><td>:relaxed: <code>:relaxed:</code></td></tr><tr class="odd"><td>:smirk: <code>:smirk:</code></td><td>:heart_eyes: <code>:heart_eyes:</code></td><td>:kissing_heart: <code>:kissing_heart:</code></td></tr><tr class="even"><td>:kissing_closed_eyes: <code>:kissing_closed_eyes:</code></td><td>:flushed: <code>:flushed:</code></td><td>:relieved: <code>:relieved:</code></td></tr><tr class="odd"><td>:satisfied: <code>:satisfied:</code></td><td>:grin: <code>:grin:</code></td><td>:wink: <code>:wink:</code></td></tr><tr class="even"><td>:stuck_out_tongue_winking_eye: <code>:stuck_out_tongue_winking_eye:</code></td><td>:stuck_out_tongue_closed_eyes: <code>:stuck_out_tongue_closed_eyes:</code></td><td>:grinning: <code>:grinning:</code></td></tr><tr class="odd"><td>:kissing: <code>:kissing:</code></td><td>:kissing_smiling_eyes: <code>:kissing_smiling_eyes:</code></td><td>:stuck_out_tongue: <code>:stuck_out_tongue:</code></td></tr><tr class="even"><td>:sleeping: <code>:sleeping:</code></td><td>:worried: <code>:worried:</code></td><td>:frowning: <code>:frowning:</code></td></tr><tr class="odd"><td>:anguished: <code>:anguished:</code></td><td>:open_mouth: <code>:open_mouth:</code></td><td>:grimacing: <code>:grimacing:</code></td></tr><tr class="even"><td>:confused: <code>:confused:</code></td><td>:hushed: <code>:hushed:</code></td><td>:expressionless: <code>:expressionless:</code></td></tr><tr class="odd"><td>:unamused: <code>:unamused:</code></td><td>:sweat_smile: <code>:sweat_smile:</code></td><td>:sweat: <code>:sweat:</code></td></tr><tr class="even"><td>:disappointed_relieved: <code>:disappointed_relieved:</code></td><td>:weary: <code>:weary:</code></td><td>:pensive: <code>:pensive:</code></td></tr><tr class="odd"><td>:disappointed: <code>:disappointed:</code></td><td>:confounded: <code>:confounded:</code></td><td>:fearful: <code>:fearful:</code></td></tr><tr class="even"><td>:cold_sweat: <code>:cold_sweat:</code></td><td>:persevere: <code>:persevere:</code></td><td>:cry: <code>:cry:</code></td></tr><tr class="odd"><td>:sob: <code>:sob:</code></td><td>:joy: <code>:joy:</code></td><td>:astonished: <code>:astonished:</code></td></tr><tr class="even"><td>:scream: <code>:scream:</code></td><td>:neckbeard: <code>:neckbeard:</code></td><td>:tired_face: <code>:tired_face:</code></td></tr><tr class="odd"><td>:angry: <code>:angry:</code></td><td>:rage: <code>:rage:</code></td><td>:triumph: <code>:triumph:</code></td></tr><tr class="even"><td>:sleepy: <code>:sleepy:</code></td><td>:yum: <code>:yum:</code></td><td>:mask: <code>:mask:</code></td></tr><tr class="odd"><td>:sunglasses: <code>:sunglasses:</code></td><td>:dizzy_face: <code>:dizzy_face:</code></td><td>:imp: <code>:imp:</code></td></tr><tr class="even"><td>:smiling_imp: <code>:smiling_imp:</code></td><td>:neutral_face: <code>:neutral_face:</code></td><td>:no_mouth: <code>:no_mouth:</code></td></tr><tr class="odd"><td>:innocent: <code>:innocent:</code></td><td>:alien: <code>:alien:</code></td><td>:yellow_heart: <code>:yellow_heart:</code></td></tr><tr class="even"><td>:blue_heart: <code>:blue_heart:</code></td><td>:purple_heart: <code>:purple_heart:</code></td><td>:heart: <code>:heart:</code></td></tr><tr class="odd"><td>:green_heart: <code>:green_heart:</code></td><td>:broken_heart: <code>:broken_heart:</code></td><td>:heartbeat: <code>:heartbeat:</code></td></tr><tr class="even"><td>:heartpulse: <code>:heartpulse:</code></td><td>:two_hearts: <code>:two_hearts:</code></td><td>:revolving_hearts: <code>:revolving_hearts:</code></td></tr><tr class="odd"><td>:cupid: <code>:cupid:</code></td><td>:sparkling_heart: <code>:sparkling_heart:</code></td><td>:sparkles: <code>:sparkles:</code></td></tr><tr class="even"><td>:star: <code>:star:</code></td><td>:star2: <code>:star2:</code></td><td>:dizzy: <code>:dizzy:</code></td></tr><tr class="odd"><td>:boom: <code>:boom:</code></td><td>:collision: <code>:collision:</code></td><td>:anger: <code>:anger:</code></td></tr><tr class="even"><td>:exclamation: <code>:exclamation:</code></td><td>:question: <code>:question:</code></td><td>:grey_exclamation: <code>:grey_exclamation:</code></td></tr><tr class="odd"><td>:grey_question: <code>:grey_question:</code></td><td>:zzz: <code>:zzz:</code></td><td>:dash: <code>:dash:</code></td></tr><tr class="even"><td>:sweat_drops: <code>:sweat_drops:</code></td><td>:notes: <code>:notes:</code></td><td>:musical_note: <code>:musical_note:</code></td></tr><tr class="odd"><td>:fire: <code>:fire:</code></td><td>:hankey: <code>:hankey:</code></td><td>:poop: <code>:poop:</code></td></tr><tr class="even"><td>:shit: <code>:shit:</code></td><td>:+1: <code>:+1:</code></td><td>:thumbsup: <code>:thumbsup:</code></td></tr><tr class="odd"><td>:-1: <code>:-1:</code></td><td>:thumbsdown: <code>:thumbsdown:</code></td><td>:ok_hand: <code>:ok_hand:</code></td></tr><tr class="even"><td>:punch: <code>:punch:</code></td><td>:facepunch: <code>:facepunch:</code></td><td>:fist: <code>:fist:</code></td></tr><tr class="odd"><td>:v: <code>:v:</code></td><td>:wave: <code>:wave:</code></td><td>:hand: <code>:hand:</code></td></tr><tr class="even"><td>:raised_hand: <code>:raised_hand:</code></td><td>:open_hands: <code>:open_hands:</code></td><td>:point_up: <code>:point_up:</code></td></tr><tr class="odd"><td>:point_down: <code>:point_down:</code></td><td>:point_left: <code>:point_left:</code></td><td>:point_right: <code>:point_right:</code></td></tr><tr class="even"><td>:raised_hands: <code>:raised_hands:</code></td><td>:pray: <code>:pray:</code></td><td>:point_up_2: <code>:point_up_2:</code></td></tr><tr class="odd"><td>:clap: <code>:clap:</code></td><td>:muscle: <code>:muscle:</code></td><td>:metal: <code>:metal:</code></td></tr><tr class="even"><td>:fu: <code>:fu:</code></td><td>:walking: <code>:walking:</code></td><td>:runner: <code>:runner:</code></td></tr><tr class="odd"><td>:running: <code>:running:</code></td><td>:couple: <code>:couple:</code></td><td>:family: <code>:family:</code></td></tr><tr class="even"><td>:two_men_holding_hands: <code>:two_men_holding_hands:</code></td><td>:two_women_holding_hands: <code>:two_women_holding_hands:</code></td><td>:dancer: <code>:dancer:</code></td></tr><tr class="odd"><td>:dancers: <code>:dancers:</code></td><td>:ok_woman: <code>:ok_woman:</code></td><td>:no_good: <code>:no_good:</code></td></tr><tr class="even"><td>:information_desk_person: <code>:information_desk_person:</code></td><td>:raising_hand: <code>:raising_hand:</code></td><td>:bride_with_veil: <code>:bride_with_veil:</code></td></tr><tr class="odd"><td>:person_with_pouting_face: <code>:person_with_pouting_face:</code></td><td>:person_frowning: <code>:person_frowning:</code></td><td>:bow: <code>:bow:</code></td></tr><tr class="even"><td>:couplekiss: <code>:couplekiss:</code></td><td>:couple_with_heart: <code>:couple_with_heart:</code></td><td>:massage: <code>:massage:</code></td></tr><tr class="odd"><td>:haircut: <code>:haircut:</code></td><td>:nail_care: <code>:nail_care:</code></td><td>:boy: <code>:boy:</code></td></tr><tr class="even"><td>:girl: <code>:girl:</code></td><td>:woman: <code>:woman:</code></td><td>:man: <code>:man:</code></td></tr><tr class="odd"><td>:baby: <code>:baby:</code></td><td>:older_woman: <code>:older_woman:</code></td><td>:older_man: <code>:older_man:</code></td></tr><tr class="even"><td>:person_with_blond_hair: <code>:person_with_blond_hair:</code></td><td>:man_with_gua_pi_mao: <code>:man_with_gua_pi_mao:</code></td><td>:man_with_turban: <code>:man_with_turban:</code></td></tr><tr class="odd"><td>:construction_worker: <code>:construction_worker:</code></td><td>:cop: <code>:cop:</code></td><td>:angel: <code>:angel:</code></td></tr><tr class="even"><td>:princess: <code>:princess:</code></td><td>:smiley_cat: <code>:smiley_cat:</code></td><td>:smile_cat: <code>:smile_cat:</code></td></tr><tr class="odd"><td>:heart_eyes_cat: <code>:heart_eyes_cat:</code></td><td>:kissing_cat: <code>:kissing_cat:</code></td><td>:smirk_cat: <code>:smirk_cat:</code></td></tr><tr class="even"><td>:scream_cat: <code>:scream_cat:</code></td><td>:crying_cat_face: <code>:crying_cat_face:</code></td><td>:joy_cat: <code>:joy_cat:</code></td></tr><tr class="odd"><td>:pouting_cat: <code>:pouting_cat:</code></td><td>:japanese_ogre: <code>:japanese_ogre:</code></td><td>:japanese_goblin: <code>:japanese_goblin:</code></td></tr><tr class="even"><td>:see_no_evil: <code>:see_no_evil:</code></td><td>:hear_no_evil: <code>:hear_no_evil:</code></td><td>:speak_no_evil: <code>:speak_no_evil:</code></td></tr><tr class="odd"><td>:guardsman: <code>:guardsman:</code></td><td>:skull: <code>:skull:</code></td><td>:feet: <code>:feet:</code></td></tr><tr class="even"><td>:lips: <code>:lips:</code></td><td>:kiss: <code>:kiss:</code></td><td>:droplet: <code>:droplet:</code></td></tr><tr class="odd"><td>:ear: <code>:ear:</code></td><td>:eyes: <code>:eyes:</code></td><td>:nose: <code>:nose:</code></td></tr><tr class="even"><td>:tongue: <code>:tongue:</code></td><td>:love_letter: <code>:love_letter:</code></td><td>:bust_in_silhouette: <code>:bust_in_silhouette:</code></td></tr><tr class="odd"><td>:busts_in_silhouette: <code>:busts_in_silhouette:</code></td><td>:speech_balloon: <code>:speech_balloon:</code></td><td>:thought_balloon: <code>:thought_balloon:</code></td></tr><tr class="even"><td>:feelsgood: <code>:feelsgood:</code></td><td>:finnadie: <code>:finnadie:</code></td><td>:goberserk: <code>:goberserk:</code></td></tr><tr class="odd"><td>:godmode: <code>:godmode:</code></td><td>:hurtrealbad: <code>:hurtrealbad:</code></td><td>:rage1: <code>:rage1:</code></td></tr><tr class="even"><td>:rage2: <code>:rage2:</code></td><td>:rage3: <code>:rage3:</code></td><td>:rage4: <code>:rage4:</code></td></tr><tr class="odd"><td>:suspect: <code>:suspect:</code></td><td>:trollface: <code>:trollface:</code></td><td></td></tr></tbody></table><p>Nature</p><table><colgroup><col style="width: 33%" /><col style="width: 33%" /><col style="width: 33%" /></colgroup><tbody><tr class="odd"><td>:sunny: <code>:sunny:</code></td><td>:umbrella: <code>:umbrella:</code></td><td>:cloud: <code>:cloud:</code></td></tr><tr class="even"><td>:snowflake: <code>:snowflake:</code></td><td>:snowman: <code>:snowman:</code></td><td>:zap: <code>:zap:</code></td></tr><tr class="odd"><td>:cyclone: <code>:cyclone:</code></td><td>:foggy: <code>:foggy:</code></td><td>:ocean: <code>:ocean:</code></td></tr><tr class="even"><td>:cat: <code>:cat:</code></td><td>:dog: <code>:dog:</code></td><td>:mouse: <code>:mouse:</code></td></tr><tr class="odd"><td>:hamster: <code>:hamster:</code></td><td>:rabbit: <code>:rabbit:</code></td><td>:wolf: <code>:wolf:</code></td></tr><tr class="even"><td>:frog: <code>:frog:</code></td><td>:tiger: <code>:tiger:</code></td><td>:koala: <code>:koala:</code></td></tr><tr class="odd"><td>:bear: <code>:bear:</code></td><td>:pig: <code>:pig:</code></td><td>:pig_nose: <code>:pig_nose:</code></td></tr><tr class="even"><td>:cow: <code>:cow:</code></td><td>:boar: <code>:boar:</code></td><td>:monkey_face: <code>:monkey_face:</code></td></tr><tr class="odd"><td>:monkey: <code>:monkey:</code></td><td>:horse: <code>:horse:</code></td><td>:racehorse: <code>:racehorse:</code></td></tr><tr class="even"><td>:camel: <code>:camel:</code></td><td>:sheep: <code>:sheep:</code></td><td>:elephant: <code>:elephant:</code></td></tr><tr class="odd"><td>:panda_face: <code>:panda_face:</code></td><td>:snake: <code>:snake:</code></td><td>:bird: <code>:bird:</code></td></tr><tr class="even"><td>:baby_chick: <code>:baby_chick:</code></td><td>:hatched_chick: <code>:hatched_chick:</code></td><td>:hatching_chick: <code>:hatching_chick:</code></td></tr><tr class="odd"><td>:chicken: <code>:chicken:</code></td><td>:penguin: <code>:penguin:</code></td><td>:turtle: <code>:turtle:</code></td></tr><tr class="even"><td>:bug: <code>:bug:</code></td><td>:honeybee: <code>:honeybee:</code></td><td>:ant: <code>:ant:</code></td></tr><tr class="odd"><td>:beetle: <code>:beetle:</code></td><td>:snail: <code>:snail:</code></td><td>:octopus: <code>:octopus:</code></td></tr><tr class="even"><td>:tropical_fish: <code>:tropical_fish:</code></td><td>:fish: <code>:fish:</code></td><td>:whale: <code>:whale:</code></td></tr><tr class="odd"><td>:whale2: <code>:whale2:</code></td><td>:dolphin: <code>:dolphin:</code></td><td>:cow2: <code>:cow2:</code></td></tr><tr class="even"><td>:ram: <code>:ram:</code></td><td>:rat: <code>:rat:</code></td><td>:water_buffalo: <code>:water_buffalo:</code></td></tr><tr class="odd"><td>:tiger2: <code>:tiger2:</code></td><td>:rabbit2: <code>:rabbit2:</code></td><td>:dragon: <code>:dragon:</code></td></tr><tr class="even"><td>:goat: <code>:goat:</code></td><td>:rooster: <code>:rooster:</code></td><td>:dog2: <code>:dog2:</code></td></tr><tr class="odd"><td>:pig2: <code>:pig2:</code></td><td>:mouse2: <code>:mouse2:</code></td><td>:ox: <code>:ox:</code></td></tr><tr class="even"><td>:dragon_face: <code>:dragon_face:</code></td><td>:blowfish: <code>:blowfish:</code></td><td>:crocodile: <code>:crocodile:</code></td></tr><tr class="odd"><td>:dromedary_camel: <code>:dromedary_camel:</code></td><td>:leopard: <code>:leopard:</code></td><td>:cat2: <code>:cat2:</code></td></tr><tr class="even"><td>:poodle: <code>:poodle:</code></td><td>:paw_prints: <code>:paw_prints:</code></td><td>:bouquet: <code>:bouquet:</code></td></tr><tr class="odd"><td>:cherry_blossom: <code>:cherry_blossom:</code></td><td>:tulip: <code>:tulip:</code></td><td>:four_leaf_clover: <code>:four_leaf_clover:</code></td></tr><tr class="even"><td>:rose: <code>:rose:</code></td><td>:sunflower: <code>:sunflower:</code></td><td>:hibiscus: <code>:hibiscus:</code></td></tr><tr class="odd"><td>:maple_leaf: <code>:maple_leaf:</code></td><td>:leaves: <code>:leaves:</code></td><td>:fallen_leaf: <code>:fallen_leaf:</code></td></tr><tr class="even"><td>:herb: <code>:herb:</code></td><td>:mushroom: <code>:mushroom:</code></td><td>:cactus: <code>:cactus:</code></td></tr><tr class="odd"><td>:palm_tree: <code>:palm_tree:</code></td><td>:evergreen_tree: <code>:evergreen_tree:</code></td><td>:deciduous_tree: <code>:deciduous_tree:</code></td></tr><tr class="even"><td>:chestnut: <code>:chestnut:</code></td><td>:seedling: <code>:seedling:</code></td><td>:blossom: <code>:blossom:</code></td></tr><tr class="odd"><td>:ear_of_rice: <code>:ear_of_rice:</code></td><td>:shell: <code>:shell:</code></td><td>:globe_with_meridians: <code>:globe_with_meridians:</code></td></tr><tr class="even"><td>:sun_with_face: <code>:sun_with_face:</code></td><td>:full_moon_with_face: <code>:full_moon_with_face:</code></td><td>:new_moon_with_face: <code>:new_moon_with_face:</code></td></tr><tr class="odd"><td>:new_moon: <code>:new_moon:</code></td><td>:waxing_crescent_moon: <code>:waxing_crescent_moon:</code></td><td>:first_quarter_moon: <code>:first_quarter_moon:</code></td></tr><tr class="even"><td>:waxing_gibbous_moon: <code>:waxing_gibbous_moon:</code></td><td>:full_moon: <code>:full_moon:</code></td><td>:waning_gibbous_moon: <code>:waning_gibbous_moon:</code></td></tr><tr class="odd"><td>:last_quarter_moon: <code>:last_quarter_moon:</code></td><td>:waning_crescent_moon: <code>:waning_crescent_moon:</code></td><td>:last_quarter_moon_with_face: <code>:last_quarter_moon_with_face:</code></td></tr><tr class="even"><td>:first_quarter_moon_with_face: <code>:first_quarter_moon_with_face:</code></td><td>:moon: <code>:moon:</code></td><td>:earth_africa: <code>:earth_africa:</code></td></tr><tr class="odd"><td>:earth_americas: <code>:earth_americas:</code></td><td>:earth_asia: <code>:earth_asia:</code></td><td>:volcano: <code>:volcano:</code></td></tr><tr class="even"><td>:milky_way: <code>:milky_way:</code></td><td>:partly_sunny: <code>:partly_sunny:</code></td><td>:octocat: <code>:octocat:</code></td></tr><tr class="odd"><td>:squirrel: <code>:squirrel:</code></td><td></td><td></td></tr></tbody></table><p>Objects</p><table><colgroup><col style="width: 33%" /><col style="width: 33%" /><col style="width: 33%" /></colgroup><tbody><tr class="odd"><td>:bamboo: <code>:bamboo:</code></td><td>:gift_heart: <code>:gift_heart:</code></td><td>:dolls: <code>:dolls:</code></td></tr><tr class="even"><td>:school_satchel: <code>:school_satchel:</code></td><td>:mortar_board: <code>:mortar_board:</code></td><td>:flags: <code>:flags:</code></td></tr><tr class="odd"><td>:fireworks: <code>:fireworks:</code></td><td>:sparkler: <code>:sparkler:</code></td><td>:wind_chime: <code>:wind_chime:</code></td></tr><tr class="even"><td>:rice_scene: <code>:rice_scene:</code></td><td>:jack_o_lantern: <code>:jack_o_lantern:</code></td><td>:ghost: <code>:ghost:</code></td></tr><tr class="odd"><td>:santa: <code>:santa:</code></td><td>:christmas_tree: <code>:christmas_tree:</code></td><td>:gift: <code>:gift:</code></td></tr><tr class="even"><td>:bell: <code>:bell:</code></td><td>:no_bell: <code>:no_bell:</code></td><td>:tanabata_tree: <code>:tanabata_tree:</code></td></tr><tr class="odd"><td>:tada: <code>:tada:</code></td><td>:confetti_ball: <code>:confetti_ball:</code></td><td>:balloon: <code>:balloon:</code></td></tr><tr class="even"><td>:crystal_ball: <code>:crystal_ball:</code></td><td>:cd: <code>:cd:</code></td><td>:dvd: <code>:dvd:</code></td></tr><tr class="odd"><td>:floppy_disk: <code>:floppy_disk:</code></td><td>:camera: <code>:camera:</code></td><td>:video_camera: <code>:video_camera:</code></td></tr><tr class="even"><td>:movie_camera: <code>:movie_camera:</code></td><td>:computer: <code>:computer:</code></td><td>:tv: <code>:tv:</code></td></tr><tr class="odd"><td>:iphone: <code>:iphone:</code></td><td>:phone: <code>:phone:</code></td><td>:telephone: <code>:telephone:</code></td></tr><tr class="even"><td>:telephone_receiver: <code>:telephone_receiver:</code></td><td>:pager: <code>:pager:</code></td><td>:fax: <code>:fax:</code></td></tr><tr class="odd"><td>:minidisc: <code>:minidisc:</code></td><td>:vhs: <code>:vhs:</code></td><td>:sound: <code>:sound:</code></td></tr><tr class="even"><td>:speaker: <code>:speaker:</code></td><td>:mute: <code>:mute:</code></td><td>:loudspeaker: <code>:loudspeaker:</code></td></tr><tr class="odd"><td>:mega: <code>:mega:</code></td><td>:hourglass: <code>:hourglass:</code></td><td>:hourglass_flowing_sand: <code>:hourglass_flowing_sand:</code></td></tr><tr class="even"><td>:alarm_clock: <code>:alarm_clock:</code></td><td>:watch: <code>:watch:</code></td><td>:radio: <code>:radio:</code></td></tr><tr class="odd"><td>:satellite: <code>:satellite:</code></td><td>:loop: <code>:loop:</code></td><td>:mag: <code>:mag:</code></td></tr><tr class="even"><td>:mag_right: <code>:mag_right:</code></td><td>:unlock: <code>:unlock:</code></td><td>:lock: <code>:lock:</code></td></tr><tr class="odd"><td>:lock_with_ink_pen: <code>:lock_with_ink_pen:</code></td><td>:closed_lock_with_key: <code>:closed_lock_with_key:</code></td><td>:key: <code>:key:</code></td></tr><tr class="even"><td>:bulb: <code>:bulb:</code></td><td>:flashlight: <code>:flashlight:</code></td><td>:high_brightness: <code>:high_brightness:</code></td></tr><tr class="odd"><td>:low_brightness: <code>:low_brightness:</code></td><td>:electric_plug: <code>:electric_plug:</code></td><td>:battery: <code>:battery:</code></td></tr><tr class="even"><td>:calling: <code>:calling:</code></td><td>:email: <code>:email:</code></td><td>:mailbox: <code>:mailbox:</code></td></tr><tr class="odd"><td>:postbox: <code>:postbox:</code></td><td>:bath: <code>:bath:</code></td><td>:bathtub: <code>:bathtub:</code></td></tr><tr class="even"><td>:shower: <code>:shower:</code></td><td>:toilet: <code>:toilet:</code></td><td>:wrench: <code>:wrench:</code></td></tr><tr class="odd"><td>:nut_and_bolt: <code>:nut_and_bolt:</code></td><td>:hammer: <code>:hammer:</code></td><td>:seat: <code>:seat:</code></td></tr><tr class="even"><td>:moneybag: <code>:moneybag:</code></td><td>:yen: <code>:yen:</code></td><td>:dollar: <code>:dollar:</code></td></tr><tr class="odd"><td>:pound: <code>:pound:</code></td><td>:euro: <code>:euro:</code></td><td>:credit_card: <code>:credit_card:</code></td></tr><tr class="even"><td>:money_with_wings: <code>:money_with_wings:</code></td><td>:e-mail: <code>:e-mail:</code></td><td>:inbox_tray: <code>:inbox_tray:</code></td></tr><tr class="odd"><td>:outbox_tray: <code>:outbox_tray:</code></td><td>:envelope: <code>:envelope:</code></td><td>:incoming_envelope: <code>:incoming_envelope:</code></td></tr><tr class="even"><td>:postal_horn: <code>:postal_horn:</code></td><td>:mailbox_closed: <code>:mailbox_closed:</code></td><td>:mailbox_with_mail: <code>:mailbox_with_mail:</code></td></tr><tr class="odd"><td>:mailbox_with_no_mail: <code>:mailbox_with_no_mail:</code></td><td>:door: <code>:door:</code></td><td>:smoking: <code>:smoking:</code></td></tr><tr class="even"><td>:bomb: <code>:bomb:</code></td><td>:gun: <code>:gun:</code></td><td>:hocho: <code>:hocho:</code></td></tr><tr class="odd"><td>:pill: <code>:pill:</code></td><td>:syringe: <code>:syringe:</code></td><td>:page_facing_up: <code>:page_facing_up:</code></td></tr><tr class="even"><td>:page_with_curl: <code>:page_with_curl:</code></td><td>:bookmark_tabs: <code>:bookmark_tabs:</code></td><td>:bar_chart: <code>:bar_chart:</code></td></tr><tr class="odd"><td>:chart_with_upwards_trend: <code>:chart_with_upwards_trend:</code></td><td>:chart_with_downwards_trend: <code>:chart_with_downwards_trend:</code></td><td>:scroll: <code>:scroll:</code></td></tr><tr class="even"><td>:clipboard: <code>:clipboard:</code></td><td>:calendar: <code>:calendar:</code></td><td>:date: <code>:date:</code></td></tr><tr class="odd"><td>:card_index: <code>:card_index:</code></td><td>:file_folder: <code>:file_folder:</code></td><td>:open_file_folder: <code>:open_file_folder:</code></td></tr><tr class="even"><td>:scissors: <code>:scissors:</code></td><td>:pushpin: <code>:pushpin:</code></td><td>:paperclip: <code>:paperclip:</code></td></tr><tr class="odd"><td>:black_nib: <code>:black_nib:</code></td><td>:pencil2: <code>:pencil2:</code></td><td>:straight_ruler: <code>:straight_ruler:</code></td></tr><tr class="even"><td>:triangular_ruler: <code>:triangular_ruler:</code></td><td>:closed_book: <code>:closed_book:</code></td><td>:green_book: <code>:green_book:</code></td></tr><tr class="odd"><td>:blue_book: <code>:blue_book:</code></td><td>:orange_book: <code>:orange_book:</code></td><td>:notebook: <code>:notebook:</code></td></tr><tr class="even"><td>:notebook_with_decorative_cover: <code>:notebook_with_decorative_cover:</code></td><td>:ledger: <code>:ledger:</code></td><td>:books: <code>:books:</code></td></tr><tr class="odd"><td>:bookmark: <code>:bookmark:</code></td><td>:name_badge: <code>:name_badge:</code></td><td>:microscope: <code>:microscope:</code></td></tr><tr class="even"><td>:telescope: <code>:telescope:</code></td><td>:newspaper: <code>:newspaper:</code></td><td>:football: <code>:football:</code></td></tr><tr class="odd"><td>:basketball: <code>:basketball:</code></td><td>:soccer: <code>:soccer:</code></td><td>:baseball: <code>:baseball:</code></td></tr><tr class="even"><td>:tennis: <code>:tennis:</code></td><td>:8ball: <code>:8ball:</code></td><td>:rugby_football: <code>:rugby_football:</code></td></tr><tr class="odd"><td>:bowling: <code>:bowling:</code></td><td>:golf: <code>:golf:</code></td><td>:mountain_bicyclist: <code>:mountain_bicyclist:</code></td></tr><tr class="even"><td>:bicyclist: <code>:bicyclist:</code></td><td>:horse_racing: <code>:horse_racing:</code></td><td>:snowboarder: <code>:snowboarder:</code></td></tr><tr class="odd"><td>:swimmer: <code>:swimmer:</code></td><td>:surfer: <code>:surfer:</code></td><td>:ski: <code>:ski:</code></td></tr><tr class="even"><td>:spades: <code>:spades:</code></td><td>:hearts: <code>:hearts:</code></td><td>:clubs: <code>:clubs:</code></td></tr><tr class="odd"><td>:diamonds: <code>:diamonds:</code></td><td>:gem: <code>:gem:</code></td><td>:ring: <code>:ring:</code></td></tr><tr class="even"><td>:trophy: <code>:trophy:</code></td><td>:musical_score: <code>:musical_score:</code></td><td>:musical_keyboard: <code>:musical_keyboard:</code></td></tr><tr class="odd"><td>:violin: <code>:violin:</code></td><td>:space_invader: <code>:space_invader:</code></td><td>:video_game: <code>:video_game:</code></td></tr><tr class="even"><td>:black_joker: <code>:black_joker:</code></td><td>:flower_playing_cards: <code>:flower_playing_cards:</code></td><td>:game_die: <code>:game_die:</code></td></tr><tr class="odd"><td>:dart: <code>:dart:</code></td><td>:mahjong: <code>:mahjong:</code></td><td>:clapper: <code>:clapper:</code></td></tr><tr class="even"><td>:memo: <code>:memo:</code></td><td>:pencil: <code>:pencil:</code></td><td>:book: <code>:book:</code></td></tr><tr class="odd"><td>:art: <code>:art:</code></td><td>:microphone: <code>:microphone:</code></td><td>:headphones: <code>:headphones:</code></td></tr><tr class="even"><td>:trumpet: <code>:trumpet:</code></td><td>:saxophone: <code>:saxophone:</code></td><td>:guitar: <code>:guitar:</code></td></tr><tr class="odd"><td>:shoe: <code>:shoe:</code></td><td>:sandal: <code>:sandal:</code></td><td>:high_heel: <code>:high_heel:</code></td></tr><tr class="even"><td>:lipstick: <code>:lipstick:</code></td><td>:boot: <code>:boot:</code></td><td>:shirt: <code>:shirt:</code></td></tr><tr class="odd"><td>:tshirt: <code>:tshirt:</code></td><td>:necktie: <code>:necktie:</code></td><td>:womans_clothes: <code>:womans_clothes:</code></td></tr><tr class="even"><td>:dress: <code>:dress:</code></td><td>:running_shirt_with_sash: <code>:running_shirt_with_sash:</code></td><td>:jeans: <code>:jeans:</code></td></tr><tr class="odd"><td>:kimono: <code>:kimono:</code></td><td>:bikini: <code>:bikini:</code></td><td>:ribbon: <code>:ribbon:</code></td></tr><tr class="even"><td>:tophat: <code>:tophat:</code></td><td>:crown: <code>:crown:</code></td><td>:womans_hat: <code>:womans_hat:</code></td></tr><tr class="odd"><td>:mans_shoe: <code>:mans_shoe:</code></td><td>:closed_umbrella: <code>:closed_umbrella:</code></td><td>:briefcase: <code>:briefcase:</code></td></tr><tr class="even"><td>:handbag: <code>:handbag:</code></td><td>:pouch: <code>:pouch:</code></td><td>:purse: <code>:purse:</code></td></tr><tr class="odd"><td>:eyeglasses: <code>:eyeglasses:</code></td><td>:fishing_pole_and_fish: <code>:fishing_pole_and_fish:</code></td><td>:coffee: <code>:coffee:</code></td></tr><tr class="even"><td>:tea: <code>:tea:</code></td><td>:sake: <code>:sake:</code></td><td>:baby_bottle: <code>:baby_bottle:</code></td></tr><tr class="odd"><td>:beer: <code>:beer:</code></td><td>:beers: <code>:beers:</code></td><td>:cocktail: <code>:cocktail:</code></td></tr><tr class="even"><td>:tropical_drink: <code>:tropical_drink:</code></td><td>:wine_glass: <code>:wine_glass:</code></td><td>:fork_and_knife: <code>:fork_and_knife:</code></td></tr><tr class="odd"><td>:pizza: <code>:pizza:</code></td><td>:hamburger: <code>:hamburger:</code></td><td>:fries: <code>:fries:</code></td></tr><tr class="even"><td>:poultry_leg: <code>:poultry_leg:</code></td><td>:meat_on_bone: <code>:meat_on_bone:</code></td><td>:spaghetti: <code>:spaghetti:</code></td></tr><tr class="odd"><td>:curry: <code>:curry:</code></td><td>:fried_shrimp: <code>:fried_shrimp:</code></td><td>:bento: <code>:bento:</code></td></tr><tr class="even"><td>:sushi: <code>:sushi:</code></td><td>:fish_cake: <code>:fish_cake:</code></td><td>:rice_ball: <code>:rice_ball:</code></td></tr><tr class="odd"><td>:rice_cracker: <code>:rice_cracker:</code></td><td>:rice: <code>:rice:</code></td><td>:ramen: <code>:ramen:</code></td></tr><tr class="even"><td>:stew: <code>:stew:</code></td><td>:oden: <code>:oden:</code></td><td>:dango: <code>:dango:</code></td></tr><tr class="odd"><td>:egg: <code>:egg:</code></td><td>:bread: <code>:bread:</code></td><td>:doughnut: <code>:doughnut:</code></td></tr><tr class="even"><td>:custard: <code>:custard:</code></td><td>:icecream: <code>:icecream:</code></td><td>:ice_cream: <code>:ice_cream:</code></td></tr><tr class="odd"><td>:shaved_ice: <code>:shaved_ice:</code></td><td>:birthday: <code>:birthday:</code></td><td>:cake: <code>:cake:</code></td></tr><tr class="even"><td>:cookie: <code>:cookie:</code></td><td>:chocolate_bar: <code>:chocolate_bar:</code></td><td>:candy: <code>:candy:</code></td></tr><tr class="odd"><td>:lollipop: <code>:lollipop:</code></td><td>:honey_pot: <code>:honey_pot:</code></td><td>:apple: <code>:apple:</code></td></tr><tr class="even"><td>:green_apple: <code>:green_apple:</code></td><td>:tangerine: <code>:tangerine:</code></td><td>:lemon: <code>:lemon:</code></td></tr><tr class="odd"><td>:cherries: <code>:cherries:</code></td><td>:grapes: <code>:grapes:</code></td><td>:watermelon: <code>:watermelon:</code></td></tr><tr class="even"><td>:strawberry: <code>:strawberry:</code></td><td>:peach: <code>:peach:</code></td><td>:melon: <code>:melon:</code></td></tr><tr class="odd"><td>:banana: <code>:banana:</code></td><td>:pear: <code>:pear:</code></td><td>:pineapple: <code>:pineapple:</code></td></tr><tr class="even"><td>:sweet_potato: <code>:sweet_potato:</code></td><td>:eggplant: <code>:eggplant:</code></td><td>:tomato: <code>:tomato:</code></td></tr><tr class="odd"><td>:corn: <code>:corn:</code></td><td></td><td></td></tr></tbody></table><p>Places</p><table><colgroup><col style="width: 33%" /><col style="width: 33%" /><col style="width: 33%" /></colgroup><tbody><tr class="odd"><td>:house: <code>:house:</code></td><td>:house_with_garden: <code>:house_with_garden:</code></td><td>:school: <code>:school:</code></td></tr><tr class="even"><td>:office: <code>:office:</code></td><td>:post_office: <code>:post_office:</code></td><td>:hospital: <code>:hospital:</code></td></tr><tr class="odd"><td>:bank: <code>:bank:</code></td><td>:convenience_store: <code>:convenience_store:</code></td><td>:love_hotel: <code>:love_hotel:</code></td></tr><tr class="even"><td>:hotel: <code>:hotel:</code></td><td>:wedding: <code>:wedding:</code></td><td>:church: <code>:church:</code></td></tr><tr class="odd"><td>:department_store: <code>:department_store:</code></td><td>:european_post_office: <code>:european_post_office:</code></td><td>:city_sunrise: <code>:city_sunrise:</code></td></tr><tr class="even"><td>:city_sunset: <code>:city_sunset:</code></td><td>:japanese_castle: <code>:japanese_castle:</code></td><td>:european_castle: <code>:european_castle:</code></td></tr><tr class="odd"><td>:tent: <code>:tent:</code></td><td>:factory: <code>:factory:</code></td><td>:tokyo_tower: <code>:tokyo_tower:</code></td></tr><tr class="even"><td>:japan: <code>:japan:</code></td><td>:mount_fuji: <code>:mount_fuji:</code></td><td>:sunrise_over_mountains: <code>:sunrise_over_mountains:</code></td></tr><tr class="odd"><td>:sunrise: <code>:sunrise:</code></td><td>:stars: <code>:stars:</code></td><td>:statue_of_liberty: <code>:statue_of_liberty:</code></td></tr><tr class="even"><td>:bridge_at_night: <code>:bridge_at_night:</code></td><td>:carousel_horse: <code>:carousel_horse:</code></td><td>:rainbow: <code>:rainbow:</code></td></tr><tr class="odd"><td>:ferris_wheel: <code>:ferris_wheel:</code></td><td>:fountain: <code>:fountain:</code></td><td>:roller_coaster: <code>:roller_coaster:</code></td></tr><tr class="even"><td>:ship: <code>:ship:</code></td><td>:speedboat: <code>:speedboat:</code></td><td>:boat: <code>:boat:</code></td></tr><tr class="odd"><td>:sailboat: <code>:sailboat:</code></td><td>:rowboat: <code>:rowboat:</code></td><td>:anchor: <code>:anchor:</code></td></tr><tr class="even"><td>:rocket: <code>:rocket:</code></td><td>:airplane: <code>:airplane:</code></td><td>:helicopter: <code>:helicopter:</code></td></tr><tr class="odd"><td>:steam_locomotive: <code>:steam_locomotive:</code></td><td>:tram: <code>:tram:</code></td><td>:mountain_railway: <code>:mountain_railway:</code></td></tr><tr class="even"><td>:bike: <code>:bike:</code></td><td>:aerial_tramway: <code>:aerial_tramway:</code></td><td>:suspension_railway: <code>:suspension_railway:</code></td></tr><tr class="odd"><td>:mountain_cableway: <code>:mountain_cableway:</code></td><td>:tractor: <code>:tractor:</code></td><td>:blue_car: <code>:blue_car:</code></td></tr><tr class="even"><td>:oncoming_automobile: <code>:oncoming_automobile:</code></td><td>:car: <code>:car:</code></td><td>:red_car: <code>:red_car:</code></td></tr><tr class="odd"><td>:taxi: <code>:taxi:</code></td><td>:oncoming_taxi: <code>:oncoming_taxi:</code></td><td>:articulated_lorry: <code>:articulated_lorry:</code></td></tr><tr class="even"><td>:bus: <code>:bus:</code></td><td>:oncoming_bus: <code>:oncoming_bus:</code></td><td>:rotating_light: <code>:rotating_light:</code></td></tr><tr class="odd"><td>:police_car: <code>:police_car:</code></td><td>:oncoming_police_car: <code>:oncoming_police_car:</code></td><td>:fire_engine: <code>:fire_engine:</code></td></tr><tr class="even"><td>:ambulance: <code>:ambulance:</code></td><td>:minibus: <code>:minibus:</code></td><td>:truck: <code>:truck:</code></td></tr><tr class="odd"><td>:train: <code>:train:</code></td><td>:station: <code>:station:</code></td><td>:train2: <code>:train2:</code></td></tr><tr class="even"><td>:bullettrain_front: <code>:bullettrain_front:</code></td><td>:bullettrain_side: <code>:bullettrain_side:</code></td><td>:light_rail: <code>:light_rail:</code></td></tr><tr class="odd"><td>:monorail: <code>:monorail:</code></td><td>:railway_car: <code>:railway_car:</code></td><td>:trolleybus: <code>:trolleybus:</code></td></tr><tr class="even"><td>:ticket: <code>:ticket:</code></td><td>:fuelpump: <code>:fuelpump:</code></td><td>:vertical_traffic_light: <code>:vertical_traffic_light:</code></td></tr><tr class="odd"><td>:traffic_light: <code>:traffic_light:</code></td><td>:warning: <code>:warning:</code></td><td>:construction: <code>:construction:</code></td></tr><tr class="even"><td>:beginner: <code>:beginner:</code></td><td>:atm: <code>:atm:</code></td><td>:slot_machine: <code>:slot_machine:</code></td></tr><tr class="odd"><td>:busstop: <code>:busstop:</code></td><td>:barber: <code>:barber:</code></td><td>:hotsprings: <code>:hotsprings:</code></td></tr><tr class="even"><td>:checkered_flag: <code>:checkered_flag:</code></td><td>:crossed_flags: <code>:crossed_flags:</code></td><td>:izakaya_lantern: <code>:izakaya_lantern:</code></td></tr><tr class="odd"><td>:moyai: <code>:moyai:</code></td><td>:circus_tent: <code>:circus_tent:</code></td><td>:performing_arts: <code>:performing_arts:</code></td></tr><tr class="even"><td>:round_pushpin: <code>:round_pushpin:</code></td><td>:triangular_flag_on_post: <code>:triangular_flag_on_post:</code></td><td>:jp: <code>:jp:</code></td></tr><tr class="odd"><td>:kr: <code>:kr:</code></td><td>:cn: <code>:cn:</code></td><td>:us: <code>:us:</code></td></tr><tr class="even"><td>:fr: <code>:fr:</code></td><td>:es: <code>:es:</code></td><td>:it: <code>:it:</code></td></tr><tr class="odd"><td>:ru: <code>:ru:</code></td><td>:gb: <code>:gb:</code></td><td>:uk: <code>:uk:</code></td></tr><tr class="even"><td>:de: <code>:de:</code></td><td></td><td></td></tr></tbody></table><p>Symbols</p><table><colgroup><col style="width: 33%" /><col style="width: 33%" /><col style="width: 33%" /></colgroup><tbody><tr class="odd"><td>:one: <code>:one:</code></td><td>:two: <code>:two:</code></td><td>:three: <code>:three:</code></td></tr><tr class="even"><td>:four: <code>:four:</code></td><td>:five: <code>:five:</code></td><td>:six: <code>:six:</code></td></tr><tr class="odd"><td>:seven: <code>:seven:</code></td><td>:eight: <code>:eight:</code></td><td>:nine: <code>:nine:</code></td></tr><tr class="even"><td>:keycap_ten: <code>:keycap_ten:</code></td><td>:1234: <code>:1234:</code></td><td>:zero: <code>:zero:</code></td></tr><tr class="odd"><td>:hash: <code>:hash:</code></td><td>:symbols: <code>:symbols:</code></td><td>:arrow_backward: <code>:arrow_backward:</code></td></tr><tr class="even"><td>:arrow_down: <code>:arrow_down:</code></td><td>:arrow_forward: <code>:arrow_forward:</code></td><td>:arrow_left: <code>:arrow_left:</code></td></tr><tr class="odd"><td>:capital_abcd: <code>:capital_abcd:</code></td><td>:abcd: <code>:abcd:</code></td><td>:abc: <code>:abc:</code></td></tr><tr class="even"><td>:arrow_lower_left: <code>:arrow_lower_left:</code></td><td>:arrow_lower_right: <code>:arrow_lower_right:</code></td><td>:arrow_right: <code>:arrow_right:</code></td></tr><tr class="odd"><td>:arrow_up: <code>:arrow_up:</code></td><td>:arrow_upper_left: <code>:arrow_upper_left:</code></td><td>:arrow_upper_right: <code>:arrow_upper_right:</code></td></tr><tr class="even"><td>:arrow_double_down: <code>:arrow_double_down:</code></td><td>:arrow_double_up: <code>:arrow_double_up:</code></td><td>:arrow_down_small: <code>:arrow_down_small:</code></td></tr><tr class="odd"><td>:arrow_heading_down: <code>:arrow_heading_down:</code></td><td>:arrow_heading_up: <code>:arrow_heading_up:</code></td><td>:leftwards_arrow_with_hook: <code>:leftwards_arrow_with_hook:</code></td></tr><tr class="even"><td>:arrow_right_hook: <code>:arrow_right_hook:</code></td><td>:left_right_arrow: <code>:left_right_arrow:</code></td><td>:arrow_up_down: <code>:arrow_up_down:</code></td></tr><tr class="odd"><td>:arrow_up_small: <code>:arrow_up_small:</code></td><td>:arrows_clockwise: <code>:arrows_clockwise:</code></td><td>:arrows_counterclockwise: <code>:arrows_counterclockwise:</code></td></tr><tr class="even"><td>:rewind: <code>:rewind:</code></td><td>:fast_forward: <code>:fast_forward:</code></td><td>:information_source: <code>:information_source:</code></td></tr><tr class="odd"><td>:ok: <code>:ok:</code></td><td>:twisted_rightwards_arrows: <code>:twisted_rightwards_arrows:</code></td><td>:repeat: <code>:repeat:</code></td></tr><tr class="even"><td>:repeat_one: <code>:repeat_one:</code></td><td>:new: <code>:new:</code></td><td>:top: <code>:top:</code></td></tr><tr class="odd"><td>:up: <code>:up:</code></td><td>:cool: <code>:cool:</code></td><td>:free: <code>:free:</code></td></tr><tr class="even"><td>:ng: <code>:ng:</code></td><td>:cinema: <code>:cinema:</code></td><td>:koko: <code>:koko:</code></td></tr><tr class="odd"><td>:signal_strength: <code>:signal_strength:</code></td><td>:u5272: <code>:u5272:</code></td><td>:u5408: <code>:u5408:</code></td></tr><tr class="even"><td>:u55b6: <code>:u55b6:</code></td><td>:u6307: <code>:u6307:</code></td><td>:u6708: <code>:u6708:</code></td></tr><tr class="odd"><td>:u6709: <code>:u6709:</code></td><td>:u6e80: <code>:u6e80:</code></td><td>:u7121: <code>:u7121:</code></td></tr><tr class="even"><td>:u7533: <code>:u7533:</code></td><td>:u7a7a: <code>:u7a7a:</code></td><td>:u7981: <code>:u7981:</code></td></tr><tr class="odd"><td>:sa: <code>:sa:</code></td><td>:restroom: <code>:restroom:</code></td><td>:mens: <code>:mens:</code></td></tr><tr class="even"><td>:womens: <code>:womens:</code></td><td>:baby_symbol: <code>:baby_symbol:</code></td><td>:no_smoking: <code>:no_smoking:</code></td></tr><tr class="odd"><td>:parking: <code>:parking:</code></td><td>:wheelchair: <code>:wheelchair:</code></td><td>:metro: <code>:metro:</code></td></tr><tr class="even"><td>:baggage_claim: <code>:baggage_claim:</code></td><td>:accept: <code>:accept:</code></td><td>:wc: <code>:wc:</code></td></tr><tr class="odd"><td>:potable_water: <code>:potable_water:</code></td><td>:put_litter_in_its_place: <code>:put_litter_in_its_place:</code></td><td>:secret: <code>:secret:</code></td></tr><tr class="even"><td>:congratulations: <code>:congratulations:</code></td><td>:m: <code>:m:</code></td><td>:passport_control: <code>:passport_control:</code></td></tr><tr class="odd"><td>:left_luggage: <code>:left_luggage:</code></td><td>:customs: <code>:customs:</code></td><td>:ideograph_advantage: <code>:ideograph_advantage:</code></td></tr><tr class="even"><td>:cl: <code>:cl:</code></td><td>:sos: <code>:sos:</code></td><td>:id: <code>:id:</code></td></tr><tr class="odd"><td>:no_entry_sign: <code>:no_entry_sign:</code></td><td>:underage: <code>:underage:</code></td><td>:no_mobile_phones: <code>:no_mobile_phones:</code></td></tr><tr class="even"><td>:do_not_litter: <code>:do_not_litter:</code></td><td>:non-potable_water: <code>:non-potable_water:</code></td><td>:no_bicycles: <code>:no_bicycles:</code></td></tr><tr class="odd"><td>:no_pedestrians: <code>:no_pedestrians:</code></td><td>:children_crossing: <code>:children_crossing:</code></td><td>:no_entry: <code>:no_entry:</code></td></tr><tr class="even"><td>:eight_spoked_asterisk: <code>:eight_spoked_asterisk:</code></td><td>:eight_pointed_black_star: <code>:eight_pointed_black_star:</code></td><td>:heart_decoration: <code>:heart_decoration:</code></td></tr><tr class="odd"><td>:vs: <code>:vs:</code></td><td>:vibration_mode: <code>:vibration_mode:</code></td><td>:mobile_phone_off: <code>:mobile_phone_off:</code></td></tr><tr class="even"><td>:chart: <code>:chart:</code></td><td>:currency_exchange: <code>:currency_exchange:</code></td><td>:aries: <code>:aries:</code></td></tr><tr class="odd"><td>:taurus: <code>:taurus:</code></td><td>:gemini: <code>:gemini:</code></td><td>:cancer: <code>:cancer:</code></td></tr><tr class="even"><td>:leo: <code>:leo:</code></td><td>:virgo: <code>:virgo:</code></td><td>:libra: <code>:libra:</code></td></tr><tr class="odd"><td>:scorpius: <code>:scorpius:</code></td><td>:sagittarius: <code>:sagittarius:</code></td><td>:capricorn: <code>:capricorn:</code></td></tr><tr class="even"><td>:aquarius: <code>:aquarius:</code></td><td>:pisces: <code>:pisces:</code></td><td>:ophiuchus: <code>:ophiuchus:</code></td></tr><tr class="odd"><td>:six_pointed_star: <code>:six_pointed_star:</code></td><td>:negative_squared_cross_mark: <code>:negative_squared_cross_mark:</code></td><td>:a: <code>:a:</code></td></tr><tr class="even"><td>:b: <code>:b:</code></td><td>:ab: <code>:ab:</code></td><td>:o2: <code>:o2:</code></td></tr><tr class="odd"><td>:diamond_shape_with_a_dot_inside: <code>:diamond_shape_with_a_dot_inside:</code></td><td>:recycle: <code>:recycle:</code></td><td>:end: <code>:end:</code></td></tr><tr class="even"><td>:on: <code>:on:</code></td><td>:soon: <code>:soon:</code></td><td>:clock1: <code>:clock1:</code></td></tr><tr class="odd"><td>:clock130: <code>:clock130:</code></td><td>:clock10: <code>:clock10:</code></td><td>:clock1030: <code>:clock1030:</code></td></tr><tr class="even"><td>:clock11: <code>:clock11:</code></td><td>:clock1130: <code>:clock1130:</code></td><td>:clock12: <code>:clock12:</code></td></tr><tr class="odd"><td>:clock1230: <code>:clock1230:</code></td><td>:clock2: <code>:clock2:</code></td><td>:clock230: <code>:clock230:</code></td></tr><tr class="even"><td>:clock3: <code>:clock3:</code></td><td>:clock330: <code>:clock330:</code></td><td>:clock4: <code>:clock4:</code></td></tr><tr class="odd"><td>:clock430: <code>:clock430:</code></td><td>:clock5: <code>:clock5:</code></td><td>:clock530: <code>:clock530:</code></td></tr><tr class="even"><td>:clock6: <code>:clock6:</code></td><td>:clock630: <code>:clock630:</code></td><td>:clock7: <code>:clock7:</code></td></tr><tr class="odd"><td>:clock730: <code>:clock730:</code></td><td>:clock8: <code>:clock8:</code></td><td>:clock830: <code>:clock830:</code></td></tr><tr class="even"><td>:clock9: <code>:clock9:</code></td><td>:clock930: <code>:clock930:</code></td><td>:heavy_dollar_sign: <code>:heavy_dollar_sign:</code></td></tr><tr class="odd"><td>:copyright: <code>:copyright:</code></td><td>:registered: <code>:registered:</code></td><td>:tm: <code>:tm:</code></td></tr><tr class="even"><td>:x: <code>:x:</code></td><td>:heavy_exclamation_mark: <code>:heavy_exclamation_mark:</code></td><td>:bangbang: <code>:bangbang:</code></td></tr><tr class="odd"><td>:interrobang: <code>:interrobang:</code></td><td>:o: <code>:o:</code></td><td>:heavy_multiplication_x: <code>:heavy_multiplication_x:</code></td></tr><tr class="even"><td>:heavy_plus_sign: <code>:heavy_plus_sign:</code></td><td>:heavy_minus_sign: <code>:heavy_minus_sign:</code></td><td>:heavy_division_sign: <code>:heavy_division_sign:</code></td></tr><tr class="odd"><td>:white_flower: <code>:white_flower:</code></td><td>:100: <code>:100:</code></td><td>:heavy_check_mark: <code>:heavy_check_mark:</code></td></tr><tr class="even"><td>:ballot_box_with_check: <code>:ballot_box_with_check:</code></td><td>:radio_button: <code>:radio_button:</code></td><td>:link: <code>:link:</code></td></tr><tr class="odd"><td>:curly_loop: <code>:curly_loop:</code></td><td>:wavy_dash: <code>:wavy_dash:</code></td><td>:part_alternation_mark: <code>:part_alternation_mark:</code></td></tr><tr class="even"><td>:trident: <code>:trident:</code></td><td>:black_square: <code>:black_square:</code></td><td>:white_square: <code>:white_square:</code></td></tr><tr class="odd"><td>:white_check_mark: <code>:white_check_mark:</code></td><td>:black_square_button: <code>:black_square_button:</code></td><td>:white_square_button: <code>:white_square_button:</code></td></tr><tr class="even"><td>:black_circle: <code>:black_circle:</code></td><td>:white_circle: <code>:white_circle:</code></td><td>:red_circle: <code>:red_circle:</code></td></tr><tr class="odd"><td>:large_blue_circle: <code>:large_blue_circle:</code></td><td>:large_blue_diamond: <code>:large_blue_diamond:</code></td><td>:large_orange_diamond: <code>:large_orange_diamond:</code></td></tr><tr class="even"><td>:small_blue_diamond: <code>:small_blue_diamond:</code></td><td>:small_orange_diamond: <code>:small_orange_diamond:</code></td><td>:small_red_triangle: <code>:small_red_triangle:</code></td></tr><tr class="odd"><td>:small_red_triangle_down: <code>:small_red_triangle_down:</code></td><td>:shipit: <code>:shipit:</code></td><td></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是小表情的markdown代码, 来自&lt;a href=&quot;https://gist.github.com/rxaviers/7360908&quot;&gt;GitHub&lt;/a&gt;, 也可以使用&lt;code&gt;&amp;lt;Win + .&amp;gt;&lt;/code&gt;快捷键来输入.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="我的小工具" scheme="https://gipbear.github.io/categories/%E6%88%91%E7%9A%84%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="markdown" scheme="https://gipbear.github.io/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>seleniumn的简单使用</title>
    <link href="https://gipbear.github.io/2022/02/04/seleniumn%E4%BD%BF%E7%94%A8/"/>
    <id>https://gipbear.github.io/2022/02/04/seleniumn%E4%BD%BF%E7%94%A8/</id>
    <published>2022-02-04T09:18:58.000Z</published>
    <updated>2022-02-05T13:03:00.176Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是关于爬虫工具selenium的介绍, 包括安装和常见的使用方法, 稍作整理以备之后使用.</p></blockquote><span id="more"></span><h2 id="selenium-安装">1. selenium 安装</h2><p>selenium是一款常用的爬虫工具, 与常见的爬虫库相比, 它是直接模拟并调用浏览器直接运行, 从而可以避免很多的反爬机制, 某些程度上类似于按键精灵. 但功能更强大, 自定义性更强.</p><p>首先我们需要在python环境中安装selenium库.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install selenium</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span></span><br><span class="line">conda install selenium</span><br></pre></td></tr></table></figure><p>除了基本python依赖库, 我们还需要安装<strong>浏览器驱动</strong>, 由于我使用chrome较多, 这里选择的是<code>chomedriver</code>, 其他浏览器需要寻找对应驱动.</p><ol type="1"><li>首先打开chrome浏览器, 在地址栏输入<code>Chrome://version</code>, 查看浏览器对应版本号, 例如目前我的是:<code>98.0.4758.82 (正式版本) （64 位）</code>.</li><li>然后在<a href="https://chromedriver.storage.googleapis.com/index.html">chromedriver网址</a>中寻找到对应版本<strong>下载并解压</strong>即可.(这是<a href="https://sites.google.com/chromium.org/driver/">官网</a>, 有墙)</li><li>最后将<code>chromedriver.exe</code>放在python环境的<code>Scripts</code>文件夹中, 或项目文件夹中, 或者<del>放在喜欢的文件夹下</del>(不是).</li></ol><p>ok, 然后就开始我们的学习之路吧!</p><h2 id="基本用法">2. 基本用法</h2><ol type="1"><li><p><strong>导入库</strong></p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br></pre></td></tr></table></figure></p></li><li><p><strong>初始化浏览器</strong> 若已经放入<code>Scripts</code>文件夹中, 则直接调用.</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化选择chrome浏览器</span></span><br><span class="line">browser = webdriver.Chrome()</span><br></pre></td></tr></table></figure></p><p>否则需要手动选择浏览器的路径, 相对路径或绝对路径都可以.</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化选择chrome浏览器</span></span><br><span class="line">browser = webdriver.Chrome(path)</span><br></pre></td></tr></table></figure></p><p>这时运行会发现有一个chrome浏览器自动弹出, 若我们想要程序安静运行的时候, 就可以设置<strong>无界面</strong>, 也叫<code>无头浏览器</code>.</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参数设置</span></span><br><span class="line">option = webdriver.ChromeOptions()</span><br><span class="line">option.add_argument(<span class="string">&quot;headless&quot;</span>)</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome(options=option)</span><br></pre></td></tr></table></figure></p></li><li><p><strong>访问网址</strong></p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 访问百度</span></span><br><span class="line">browser.get(<span class="string">r&#x27;https://www.baidu.com/&#x27;</span>)</span><br></pre></td></tr></table></figure></p></li><li><p><strong>关闭浏览器</strong></p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭浏览器</span></span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure></p></li></ol><h2 id="浏览器设置">3. 浏览器设置</h2><ol type="1"><li><p><strong>浏览器大小</strong></p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全屏</span></span><br><span class="line">browser.maximize_window()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分辨率 600*800</span></span><br><span class="line">browser.set_window_size(<span class="number">600</span>,<span class="number">800</span>)</span><br></pre></td></tr></table></figure></p></li><li><p><strong>浏览器刷新</strong> 同刷新键, 最好写个异常检测</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 刷新页面</span></span><br><span class="line">    browser.refresh()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;刷新页面&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;刷新失败&#x27;</span>)</span><br></pre></td></tr></table></figure></p></li><li><p><strong>前进/后退</strong></p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 后退</span></span><br><span class="line">browser.back()</span><br><span class="line"><span class="comment"># 前进</span></span><br><span class="line">browser.forward()</span><br></pre></td></tr></table></figure></p></li></ol><h2 id="网页基本信息">4. 网页基本信息</h2><p>当前网页的标题等信息.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 网页标题</span></span><br><span class="line"><span class="built_in">print</span>(browser.title)</span><br><span class="line"><span class="comment"># 当前网址</span></span><br><span class="line"><span class="built_in">print</span>(browser.current_url)</span><br><span class="line"><span class="comment"># 浏览器名称</span></span><br><span class="line"><span class="built_in">print</span>(browser.name)    </span><br></pre></td></tr></table></figure><p>也可以直接获取网页源码, 这就可以直接使用<code>正则表达式</code>、<code>Bs4</code>和<code>xpath</code>等工具进行解析了.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(browser.page_source)</span><br></pre></td></tr></table></figure><h2 id="定位页面元素">5. 定位页面元素</h2><p>定位页面元素, 即直接寻找浏览器的中渲染后的元素, 而不是源代码, 以如下搜索框标签为例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 百度页面的搜索框 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;kw&quot;</span> <span class="attr">name</span>=<span class="string">&quot;wd&quot;</span> <span class="attr">class</span>=<span class="string">&quot;s_ipt&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">maxlength</span>=<span class="string">&quot;255&quot;</span> <span class="attr">autocomplete</span>=<span class="string">&quot;off&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ol type="1"><li><p><strong>按照id/name/class定位</strong></p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在百度搜索框中输入python</span></span><br><span class="line">browser.find_element_by_id(<span class="string">&#x27;kw&#x27;</span>).send_keys(<span class="string">&#x27;python&#x27;</span>)</span><br><span class="line">browser.find_element_by_name(<span class="string">&#x27;wd&#x27;</span>).send_keys(<span class="string">&#x27;python&#x27;</span>)</span><br><span class="line">browser.find_element_by_class_name(<span class="string">&#x27;s_ipt&#x27;</span>).send_keys(<span class="string">&#x27;python&#x27;</span>)</span><br></pre></td></tr></table></figure></p></li><li><p><strong>按照tag定位</strong> 但是实际上一个页面可能会存在很多个相同的tag, 这时候会使得tag<strong>指向模糊</strong>, 从而引发报错.</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在百度搜索框中输入python</span></span><br><span class="line">browser.find_element_by_tag_name(<span class="string">&#x27;input&#x27;</span>).send_keys(<span class="string">&#x27;python&#x27;</span>)</span><br></pre></td></tr></table></figure></p></li><li><p><strong>link定位</strong> 定位连接名称, 例如在百度左上角链接的例子中进行定位.</p><p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;s-top-left&quot;</span> <span class="attr">class</span>=<span class="string">&quot;s-top-left-new s-isindex-wrap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://news.baidu.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">class</span>=<span class="string">&quot;mnav c-font-normal c-color-t&quot;</span>&gt;</span>新闻<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.hao123.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">class</span>=<span class="string">&quot;mnav c-font-normal c-color-t&quot;</span>&gt;</span>hao123<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://map.baidu.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">class</span>=<span class="string">&quot;mnav c-font-normal c-color-t&quot;</span>&gt;</span>地图<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>直接根据链接的名称来定位.</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 点击新闻链接</span></span><br><span class="line">browser.find_element_by_link_text(<span class="string">&#x27;新闻&#x27;</span>).click()</span><br></pre></td></tr></table></figure></p><p>但有时候链接名称很长, 可以使用<strong>模糊</strong>定位<code>partial</code>, 当然, 链接指向得唯一.</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 点击含有闻的链接</span></span><br><span class="line">browser.find_element_by_partial_link_text(<span class="string">&#x27;闻&#x27;</span>).click()</span><br></pre></td></tr></table></figure></p></li><li><p><strong>xpath定位</strong> 以上的方法必须保证<strong>元素唯一</strong>, 当元素不唯一的时候, 就需要使用xpath来进行唯一定位了, 例如使用xpath来寻找搜索框的位置.</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在百度搜索框中输入python</span></span><br><span class="line">browser.find_element_by_xpath(<span class="string">&quot;//*[@id=&#x27;kw&#x27;]&quot;</span>).send_keys(<span class="string">&#x27;python&#x27;</span>)</span><br></pre></td></tr></table></figure></p></li><li><p><strong>css定位</strong> 该方法比xpath简洁且更快一些</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在百度搜索框中输入python</span></span><br><span class="line">browser.find_element_by_css_selector(<span class="string">&#x27;#kw&#x27;</span>).send_keys(<span class="string">&#x27;python&#x27;</span>)</span><br></pre></td></tr></table></figure></p></li><li><p><strong>定位多个元素</strong> 当然, 有时候我们就是需要多个元素, 那么就只需要使用<code>复数s</code>即可.</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># element s</span></span><br><span class="line">browser.find_elements_by_class_name(name)</span><br><span class="line">browser.find_elements_by_id(id_)</span><br><span class="line">browser.find_elements_by_name(name)</span><br></pre></td></tr></table></figure></p></li></ol><h2 id="获取元素信息">6. 获取元素信息</h2><p>通常在上一步定位元素之后, 会对元素进行一些操作.</p><ol type="1"><li><p><strong>获取元素属性</strong> 例如想要获取百度logo的信息, 先定位图片元素, 再获取信息</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先使用上述方法获取百度logo元素</span></span><br><span class="line">logo = browser.find_element_by_class_name(<span class="string">&#x27;index-logo-src&#x27;</span>)</span><br><span class="line"><span class="comment"># 然后使用get_attribute来获取想要的属性信息</span></span><br><span class="line">logo = browser.find_element_by_class_name(<span class="string">&#x27;index-logo-src&#x27;</span>)</span><br><span class="line">logo_url = logo.get_attribute(<span class="string">&#x27;src&#x27;</span>)</span><br></pre></td></tr></table></figure></p></li><li><p><strong>获取元素文本</strong> 首先直接使用class寻找热榜元素, 但是有多个元素, 所以使用复数<code>elements</code>来获得, 并使用<code>for循环</code>打印. 获取文本时使用<code>text</code>来获取</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取热榜</span></span><br><span class="line">hots = browser.find_elements_by_class_name(<span class="string">&#x27;title-content-title&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> h <span class="keyword">in</span> hots:</span><br><span class="line">    <span class="built_in">print</span>(h.text)</span><br></pre></td></tr></table></figure></p></li><li><p><strong>获取其他属性</strong> 获取例如id或tag</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">logo = browser.find_element_by_class_name(<span class="string">&#x27;index-logo-src&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(logo.<span class="built_in">id</span>)</span><br><span class="line"><span class="built_in">print</span>(logo.location)</span><br><span class="line"><span class="built_in">print</span>(logo.tag_name)</span><br><span class="line"><span class="built_in">print</span>(logo.size)</span><br></pre></td></tr></table></figure></p></li></ol><h2 id="页面交互">7. 页面交互</h2><p>除了直接获取页面的元素, 有时候还需要对页面进行一些操作.</p><ol type="1"><li><p><strong>输入/清除文本</strong> 例如在百度搜索框输入"冬奥会", 然后清除</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先获取搜索框元素, 然后使用send_keys输入内容</span></span><br><span class="line">search_bar = browser.find_element_by_id(<span class="string">&#x27;kw&#x27;</span>)</span><br><span class="line">search_bar.send_keys(<span class="string">&#x27;冬奥会&#x27;</span>)</span><br><span class="line"><span class="comment"># 稍微等两秒, 不然就看不见了</span></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">search_bar.clear()</span><br></pre></td></tr></table></figure></p></li><li><p><strong>提交(回车)</strong> 上述内容输入后, 需要点击回车来提交, 才能得到想要的搜索信息.</p><blockquote><p>这篇博文<code>2022年2月5日</code>编写时百度已经发现selenium啦, 所以需要增加一些伪装手段, 在本文最后.:point_right: <a href="#反爬">直达反爬</a>.</p></blockquote><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">search_bar.send_keys(<span class="string">&#x27;冬奥会&#x27;</span>)</span><br><span class="line">search_bar.submit()</span><br></pre></td></tr></table></figure></p></li><li><p><strong>点击</strong> 当我们需要进行点击操作的时候, 使用click. 例如之前的提交, 也可以找到<code>百度一下</code>这个按钮, 然后click!</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 点击热榜第一条</span></span><br><span class="line">hots = browser.find_elements_by_class_name(<span class="string">&#x27;title-content-title&#x27;</span>)</span><br><span class="line">hots[<span class="number">0</span>].click()</span><br></pre></td></tr></table></figure></p><p><strong>单选</strong>和<strong>多选</strong>同理, 定位到对应元素, 然后click即可.</p><p>而偶尔也会使用<strong>右击</strong>, 那就需要新的依赖库.</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.common.action_chains <span class="keyword">import</span> ActionChains</span><br><span class="line"></span><br><span class="line">hots = browser.find_elements_by_class_name(<span class="string">&#x27;title-content-title&#x27;</span>)</span><br><span class="line"><span class="comment"># 鼠标右击</span></span><br><span class="line">ActionChains(browser).context_click(hots[<span class="number">0</span>]).perform()</span><br><span class="line"><span class="comment"># 双击</span></span><br><span class="line"><span class="comment"># ActionChains(browser).double_click(hots[0]).perform()</span></span><br></pre></td></tr></table></figure></p><p>双击是<code>double_click</code>, 找不到合适的例子就不提了. 这里是<code>ActionChains</code>可以深入挖掘, 是定义一系列的操作一起<code>perform</code>, 当然, 普通的一些操作其实也够了.</p></li><li><p><strong>悬停</strong> 我就放放不进去.</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ActionChains(browser).move_to_element(move).perform()</span><br></pre></td></tr></table></figure></p></li><li><p><strong>下拉框选择</strong> 需要导入一个相关的库, 以访问MySQL官网, 选择下载对应操作系统为例.</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.support.select <span class="keyword">import</span> Select</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问mysql下载官网</span></span><br><span class="line">browser.get(<span class="string">r&#x27;https://dev.mysql.com/downloads/mysql/&#x27;</span>)</span><br><span class="line">select_os = browser.find_element_by_id(<span class="string">&#x27;os-ga&#x27;</span>)</span><br><span class="line"><span class="comment"># 使用索引选择第三个</span></span><br><span class="line">Select(select_os).select_by_index(<span class="number">3</span>)</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 使用value选择value=&quot;3&quot;的</span></span><br><span class="line">Select(select_os).select_by_value(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 使用文本值选择macOS</span></span><br><span class="line">Select(select_os).select_by_visible_text(<span class="string">&quot;macOS&quot;</span>)</span><br></pre></td></tr></table></figure></p></li><li><p><strong>拖拽</strong> 多用于验证码之类的, 参考菜鸟小例子</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.common.action_chains <span class="keyword">import</span> ActionChains</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time  </span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">url = <span class="string">&#x27;https://www.runoob.com/try/try.php?filename=jqueryui-api-droppable&#x27;</span></span><br><span class="line">browser.get(url)  </span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">browser.switch_to.frame(<span class="string">&#x27;iframeResult&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始位置</span></span><br><span class="line">source = browser.find_element_by_css_selector(<span class="string">&quot;#draggable&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结束位置</span></span><br><span class="line">target = browser.find_element_by_css_selector(<span class="string">&quot;#droppable&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行元素的拖放操作</span></span><br><span class="line">actions = ActionChains(browser)</span><br><span class="line">actions.drag_and_drop(source, target)</span><br><span class="line">actions.perform()</span><br><span class="line"><span class="comment"># 拖拽</span></span><br><span class="line">time.sleep(<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭浏览器</span></span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure></p></li></ol><h2 id="键盘操作">8. 键盘操作</h2><p>键盘的大部分操作都有相应的命令使用, 需要导入<code>Keys</code>类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 常见键盘操作</span></span><br><span class="line">send_keys(Keys.BACK_SPACE)  <span class="comment"># 删除键</span></span><br><span class="line">send_keys(Keys.SPACE)  <span class="comment"># 空格键</span></span><br><span class="line">send_keys(Keys.TAB)  <span class="comment"># 制表键</span></span><br><span class="line">send_keys(Keys.ESCAPE)  <span class="comment"># 回退键</span></span><br><span class="line">send_keys(Keys.ENTER)  <span class="comment"># 回车键</span></span><br><span class="line">send_keys(Keys.CONTRL,<span class="string">&#x27;a&#x27;</span>)  <span class="comment"># 全选(Ctrl+A)</span></span><br><span class="line">send_keys(Keys.CONTRL,<span class="string">&#x27;c&#x27;</span>)  <span class="comment"># 复制(Ctrl+C)</span></span><br><span class="line">send_keys(Keys.CONTRL,<span class="string">&#x27;x&#x27;</span>)  <span class="comment"># 剪切(Ctrl+X)</span></span><br><span class="line">send_keys(Keys.CONTRL,<span class="string">&#x27;v&#x27;</span>)  <span class="comment"># 粘贴(Ctrl+V)</span></span><br><span class="line">send_keys(Keys.F1)  <span class="comment"># 键盘F1</span></span><br><span class="line">send_keys(Keys.F12)  <span class="comment"># 键盘F12</span></span><br></pre></td></tr></table></figure><h2 id="其他">9. 其他</h2><ol type="1"><li><p><strong>延时等待</strong> 可以发现, 在上面的程序中, 有些效果需要延时等待才能够出现, 在实际中也是需要一定的延时, 一方面是为了<strong>不过于频繁访问</strong>而被认为是爬虫, 另一方面也是由于<strong>网络资源加载</strong>需要一定时间来等待.</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 简单的就可以直接使用</span></span><br><span class="line">time.sleep(<span class="number">2</span>)  <span class="comment"># 睡眠2秒</span></span><br><span class="line"><span class="comment"># 还有一些 隐式等待 implicitly_wait 和显示等待 WebDriverWait等操作, 另寻</span></span><br></pre></td></tr></table></figure></p></li><li><p><strong>截图</strong> 可以保存为base64/png/file三种</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">browser.get_screenshot_as_file(<span class="string">&#x27;截图.png&#x27;</span>)</span><br></pre></td></tr></table></figure></p></li><li><p><strong>窗口切换</strong> 我们的程序是针对当前窗口进行工作的, 但有时候程序需要切换窗口, 那么就需要切换当前工作窗口.</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 访问网址:百度</span></span><br><span class="line">browser.get(<span class="string">r&#x27;https://www.baidu.com/&#x27;</span>)</span><br><span class="line">hots = browser.find_elements_by_class_name(<span class="string">&#x27;title-content-title&#x27;</span>)</span><br><span class="line">hots[<span class="number">0</span>].click()  <span class="comment"># 点击第一个热榜</span></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 回到第 i 个窗口(按顺序)</span></span><br><span class="line">browser.switch_to_window(browser.window_handles[<span class="number">0</span>])</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">hots[<span class="number">1</span>].click()  <span class="comment"># 点击第一个热榜</span></span><br></pre></td></tr></table></figure></p><p>当然, 若页面内有iframe元素的话, 则需要切换到该iframe元素中, 可以根据其id切换, 类似的如下</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换到子框架</span></span><br><span class="line">browser.switch_to.frame(<span class="string">&#x27;iframeResult&#x27;</span>)</span><br></pre></td></tr></table></figure></p></li><li><p><strong>下拉进度条</strong> 有些网页的内容是随着进度条的下滑而出现的, 所以需要下拉进度条这个操作. 这个操作是使用js代码实现的, 所以我们需要让浏览器<strong>执行js代码</strong>即可, 其他js代码类似.</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">browser.execute_script(<span class="string">&#x27;window.scrollTo(0, document.body.scrollHeight)&#x27;</span>)</span><br></pre></td></tr></table></figure></p></li></ol><h2 id="反爬">10. 反爬</h2><p>例如上面的百度被发现了, 就需要更好的伪装我们的浏览器browser.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">browser = webdriver.Chrome()</span><br><span class="line"></span><br><span class="line">browser.execute_cdp_cmd(</span><br><span class="line">    <span class="string">&quot;Page.addScriptToEvaluateOnNewDocument&quot;</span>,</span><br><span class="line">    &#123;<span class="string">&quot;source&quot;</span>: <span class="string">&quot;&quot;&quot;Object.defineProperty(</span></span><br><span class="line"><span class="string">        navigator,</span></span><br><span class="line"><span class="string">        &#x27;webdriver&#x27;,</span></span><br><span class="line"><span class="string">        &#123;get: () =&gt; undefined&#125;)&quot;&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>网站检测selenium的原理是:</p><ol type="1"><li>selenium 在开启后的浏览器加了一些变量值, 如：window.navigator.webdriver 等等.</li><li>像window.navigator.webdriver, 在正常的谷歌浏览器是undefined, 在selenium打开的谷歌浏览器是true. 网站就下发js代码, 检测这个变量值给网站, 网站判断这个值, 为true就是爬虫程序就封杀或需要验证码.</li></ol><p>当然还有其他的一些手段, 以后遇到再补充.</p><h2 id="参考">参考</h2><ol type="1"><li><a href="https://mp.weixin.qq.com/s/3AaLPivHNTuWEH-4hhJlig">2万字带你了解Selenium全攻略！</a></li><li><a href="https://blog.csdn.net/u013595395/article/details/108714775">selenium webdriver 开启网页失败，被发现为爬虫，的解决办法</a></li></ol><h2 id="个人收获">个人收获</h2><p>这次回顾了selenium的使用方法, 仔细深究的话操作是很细的, 模仿真正的浏览器运行是没有问题的, 包括登录访问什么的都很简单, 还可以作为浏览器上的按键精灵来使用:joy:.</p><p>相比于直接获取资源的爬虫来说肯定是较慢的, 但胜于功能强大, 还是可以提高<del>摸鱼</del>工作效率的:+1:.</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是关于爬虫工具selenium的介绍, 包括安装和常见的使用方法, 稍作整理以备之后使用.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="我的小工具" scheme="https://gipbear.github.io/categories/%E6%88%91%E7%9A%84%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="python" scheme="https://gipbear.github.io/tags/python/"/>
    
    <category term="爬虫" scheme="https://gipbear.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="selenium" scheme="https://gipbear.github.io/tags/selenium/"/>
    
  </entry>
  
  <entry>
    <title>cpp数据结构之string的常见用法</title>
    <link href="https://gipbear.github.io/2022/02/02/cpp%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8Bstring%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95/"/>
    <id>https://gipbear.github.io/2022/02/02/cpp%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8Bstring%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95/</id>
    <published>2022-02-02T09:05:08.000Z</published>
    <updated>2022-02-10T10:08:15.768Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是关于c++中常用的数组<code>string</code>的一些常见用法的总结, 主要是一些常用的调用方法, 主要是我的平时的<a href="https://gipbear.github.io/tags/leetcode题解/">leetcode题解</a>中经常会使用的.</p></blockquote><span id="more"></span><h2 id="字符串-string">字符串 string</h2><p>字符串可以说是基本的数据类型, 也可以说是数据结构, 其本质是<code>多个字符顺序组成</code>的数据结构.</p><h2 id="常见用法">常见用法</h2><p>首先导入标准库</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="初始化">初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line">string s = <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; s; <span class="comment">// 写入s</span></span><br><span class="line"><span class="built_in">getline</span>(cin, s);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="查询属性">查询属性</h3><ol type="1"><li><p>字符串长度</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure></p></li><li><p>判断字符串是否为空</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">empty</span>();</span><br></pre></td></tr></table></figure></p></li></ol><h3 id="增删改查">增删改查</h3><ol type="1"><li><p>增加元素</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 末尾添加</span></span><br><span class="line">s1 += <span class="string">&quot;hhh&quot;</span> <span class="comment">// 添加字符串</span></span><br><span class="line">s1 += <span class="string">&#x27;g&#x27;</span> <span class="comment">// 添加字符</span></span><br><span class="line">s.<span class="built_in">push_back</span>(<span class="string">&#x27;a&#x27;</span>) <span class="comment">// 该方法只能添加字符</span></span><br><span class="line">s.<span class="built_in">append</span>(); <span class="comment">// 方法很丰富, 可以自行查询</span></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">6</span>, <span class="string">&quot;hhh&quot;</span>);  <span class="comment">// 只支持插入字符串</span></span><br></pre></td></tr></table></figure></p></li><li><p>删除元素</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">erase</span>(<span class="number">6</span>); <span class="comment">// 索引6之后字符串都删除</span></span><br><span class="line">s.<span class="built_in">erase</span>(<span class="number">4</span>,<span class="number">6</span>); <span class="comment">// 索引4之后删除6个字符</span></span><br><span class="line">s.<span class="built_in">clear</span>(); <span class="comment">// 清空</span></span><br></pre></td></tr></table></figure></p></li><li><p>修改元素</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">replace</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="string">&quot;python&quot;</span>); <span class="comment">// 索引1开始的2个字符串替换成python</span></span><br></pre></td></tr></table></figure></p></li><li><p>查找元素</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s[<span class="number">0</span>]; <span class="comment">// 直接去除第0个元素</span></span><br></pre></td></tr></table></figure></p></li></ol><h3 id="其他">其他</h3><ol type="1"><li><p>字符子串</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">substr</span>(<span class="number">4</span>,<span class="number">5</span>); <span class="comment">// 从索引4开始的5个字符</span></span><br></pre></td></tr></table></figure></p></li><li><p>正则匹配 使用正则表达式进行一些处理, 相比于直接模拟较慢, 但是很方便. 有些大部分的内容和之前在<a href="https://gipbear.github.io/2021/02/19/快乐Linux学习（六）/">linux中的正则</a>很相似.</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;regex&gt;</span></span></span><br><span class="line">string s = <span class="string">&quot;文本&quot;</span>;</span><br><span class="line"><span class="function">regex <span class="title">s_reg</span><span class="params">(<span class="string">&quot;正则表达式&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">bool</span> res = <span class="built_in">regex_match</span>(s, s_reg);</span><br></pre></td></tr></table></figure></p></li><li><p>字母大小写转换</p><p>最近学到一个小知识, 利用<strong>位运算</strong>来将大小写字母进行转化.</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">ch ^= <span class="number">32</span>;   <span class="comment">// 大小写相互转换;</span></span><br><span class="line">ch &amp;= <span class="number">-32</span>;  <span class="comment">// 转大写</span></span><br><span class="line">ch |= <span class="number">32</span>;   <span class="comment">// 转小写</span></span><br></pre></td></tr></table></figure></p></li></ol><h2 id="个人收获">个人收获</h2><p>字符串本质上和数组很相似, 有些处理的技巧也很相似, 多刷题, 多熟悉, 多总结!</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是关于c++中常用的数组&lt;code&gt;string&lt;/code&gt;的一些常见用法的总结, 主要是一些常用的调用方法, 主要是我的平时的&lt;a href=&quot;https://gipbear.github.io/tags/leetcode题解/&quot;&gt;leetcode题解&lt;/a&gt;中经常会使用的.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="语言特性" scheme="https://gipbear.github.io/categories/%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/"/>
    
    
    <category term="c++" scheme="https://gipbear.github.io/tags/c/"/>
    
    <category term="string" scheme="https://gipbear.github.io/tags/string/"/>
    
  </entry>
  
  <entry>
    <title>机器学习西瓜书——第06章支持向量机</title>
    <link href="https://gipbear.github.io/2022/01/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E2%80%94%E2%80%94%E7%AC%AC06%E7%AB%A0%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"/>
    <id>https://gipbear.github.io/2022/01/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E2%80%94%E2%80%94%E7%AC%AC06%E7%AB%A0%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/</id>
    <published>2022-01-26T07:52:34.000Z</published>
    <updated>2022-01-27T15:12:44.840Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是关于周志华老师编写的机器学习书籍『西瓜书』的第六章支持向量机.</p><p>主要的内容有: 支持向量机的模型理解、支持向量、硬间隔与软间隔、在不等式约束下使用拉格朗日乘子法转化为对偶问题、KKT条件、支持向量回归等.</p></blockquote><span id="more"></span><h2 id="间隔与支持向量">6.1 间隔与支持向量</h2><p>面对二分类问题, 最基本的想法是基于训练集, 在样本空间中找到一个合适的<strong>划分超平面</strong>, 从而将样本划分为两类. 但是划分超平面有很多, 选择最合适的超平面就是我们接下来要解决的问题了.</p><p>所谓『最合适』就是指: 不仅在训练集中表现良好, 更要在新的测试集中表现良好, 即泛化性能最好. 那么最直观的就行找到「正中间」的那个超平面.</p><p>首先使用线性方程来描述一下超平面:</p><p><span class="math display">\[\boldsymbol{w}^T\boldsymbol{x} + b = 0  \tag{1}\]</span></p><p>其中<span class="math inline">\(\boldsymbol{w}\)</span>为<strong>法向量</strong>, 决定平面的方向, <span class="math inline">\(d\)</span>是<strong>位移项</strong>, 决定偏移原点的距离.</p><p>若样本点在超平面上侧, 即<span class="math inline">\(\boldsymbol{w}^T\boldsymbol{x} + b &gt; 0\)</span>, 那么<span class="math inline">\(x_i\)</span>为正样本, 记为<span class="math inline">\(y_i=1\)</span>, 反之为负样本, 记为<span class="math inline">\(y_i=-1\)</span>.</p><p>若超平面能够正确分类, 那么使用一个<code>sign函数</code>将会得到模型:</p><p><span class="math display">\[y = sign(\boldsymbol{w}^T\boldsymbol{x}_i + b) =\begin{cases}  +1, \quad \boldsymbol{w}^T\boldsymbol{x}_i + b \geq +1; \\  -1, \quad \boldsymbol{w}^T\boldsymbol{x}_i + b \leq -1; \tag{2}\end{cases}\]</span></p><blockquote><p>后面的<span class="math inline">\(\pm1\)</span>是<span class="math inline">\((\boldsymbol{w}, b)\)</span>变换过的, 因为任意<span class="math inline">\(\boldsymbol{w}^T\boldsymbol{x}_i + b \geq c\)</span>可以变化为<span class="math inline">\(\frac{1}{c}\boldsymbol{w}^T\boldsymbol{x}_i + \frac{b}{c} \geq 1\)</span>. 此处的变换仅仅是「常规操作」, 也可以取其他值, 主要目的是使得后续的最优化问题有约束可解. 其中<span class="math inline">\(c\)</span>即为下面所说的「最近距离」.</p></blockquote><p>注意到公式<span class="math inline">\((2)\)</span>中的<strong>等号</strong>, 当且仅当某些样本点距离超平面<strong>最近</strong>时取得, 称为『<strong>支持向量</strong>』(support vector)!. 那么, 两侧异类样本点距离超平面的最近距离相同时, 是不是就是最合适的划分呀!</p><p>接下来计算样本<span class="math inline">\(\boldsymbol{x}\)</span>距离超平面的距离计算为:</p><p><span class="math display">\[\gamma = \frac{y_i(\boldsymbol{w}^T\boldsymbol{x} + b)}{\|\boldsymbol{w}\|} \tag{3}\]</span></p><p>那么左右两侧最近的「异类点」到达超平面的距离之和为:</p><p><span class="math display">\[\gamma = \frac{2}{\|\boldsymbol{w}\|} \tag{4}\]</span></p><p>这距离之和就称为『<strong>间隔</strong>』(margin) !</p><img src="/2022/01/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E2%80%94%E2%80%94%E7%AC%AC06%E7%AB%A0%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E4%B8%8E%E9%97%B4%E9%9A%94.png" class="" title="支持向量与间隔.png"><p>那么我们的问题就是去寻找最大的间隔<span class="math inline">\(\frac{2}{\|\boldsymbol{w}\|}\)</span>, 使得泛化误差最小, 也等价于寻找最小的<span class="math inline">\(\|\boldsymbol{w}\|^2\)</span>, 问题就转化为:</p><p><span class="math display">\[\begin{aligned}  \min_{(\boldsymbol{w}, b)} &amp;\quad{\frac{1}{2}\|\boldsymbol{w}\|^2} \\  s.t &amp;\quad 1-y_i(\boldsymbol{w}^T\boldsymbol{x} + b) \leq 0, \quad i = 1,2,\dots, m. \tag{5}\end{aligned}\]</span></p><blockquote><p>凸优化的问题一般将优化函数转化为最小值, 约束条件转化为小于等于的形式.</p></blockquote><h2 id="对偶问题">6.2 对偶问题</h2><p>以上的问题我们可以使用拉格朗日乘子法得到『对偶问题』的拉格朗日函数:</p><p><span class="math display">\[L(\boldsymbol{w}, b, \boldsymbol{\alpha}) = \frac{1}{2}\|\boldsymbol{w}\|^2 + \sum^m_{i=1}\alpha_i{(1-y_i(\boldsymbol{w}^T\boldsymbol{x}_i + b))} \tag{6}\]</span></p><p>并对上式对<span class="math inline">\(\boldsymbol{w}\)</span>和<span class="math inline">\(b\)</span>求偏导为<span class="math inline">\(0\)</span>可得:</p><p><span class="math display">\[\begin{aligned}\boldsymbol{w} &amp;= \sum^m_{i=1}{\alpha_i y_i\boldsymbol{x}_i} \\0 &amp;= \sum^m_{i=1}{\alpha_i y_i}\end{aligned} \tag{7}\]</span></p><p>将求得的结果带入拉格朗日函数中, 就可以得到对偶问题:</p><p><span class="math display">\[\begin{aligned}\max_{\boldsymbol{\alpha}} &amp;\quad {\sum^m_{i=1}{\alpha_i}-\frac{1}{2}\sum^m_{i=1}{\sum^m_{j=1}{\alpha_i \alpha_j y_i y_j\boldsymbol{x}_i^T\boldsymbol{x}_j}}} \\s.t. &amp;\quad\sum^m_{i=1}{\alpha_i y_i} = 0\end{aligned} \tag{8}\]</span></p><p>那么模型就转化为求解<span class="math inline">\(\boldsymbol{\alpha}\)</span>, 而<span class="math inline">\(\boldsymbol{\alpha}\)</span>是拉格朗日乘子, 与不等式约束条件个数有关, 即与<strong>样本个数成正比</strong>. 而我们原本的模型是求出<span class="math inline">\(\boldsymbol{w}\)</span>, 其实也是可以直接优化的, 但是<span class="math inline">\(\boldsymbol{w}\)</span>表示模型的特征, 所以<strong>原模型与样本的特征数成正比</strong>.</p><p>所以当我们遇到样本数较少, 而特征数较多的情况下可以选择使用对偶问题进行求解. 所以支持向量机在<strong>小样本</strong>中使用效果相对较好.</p><h3 id="kkt条件">KKT条件</h3><p>在上述的过程中, 我们使用了<strong>拉格朗日乘子法</strong>, 但是在<a href="https://gipbear.github.io/2022/01/17/机器学习中可能会使用的理论/#拉格朗日乘子法">这里</a>我介绍过, 拉格朗日乘子法是针对<strong>等式约束</strong>的, 如果是<strong>不等式约束</strong>, 则需要满足<code>KKT条件</code>, 这里是:</p><p><span class="math display">\[\begin{cases}  \alpha_i \geq 0; \\  1-y_i(\boldsymbol{w}^T\boldsymbol{x}_i + b) \leq 0; \\  \alpha_i(1-y_i(\boldsymbol{w}^T\boldsymbol{x}_i + b)) = 0.\end{cases}\]</span></p><p>:warning:在这里可以发现<strong>很重要的结论</strong>:</p><ol type="1"><li>由第三个条件可以推出, 要么<span class="math inline">\(\alpha_i = 0\)</span>, 要么<span class="math inline">\(y_if(\boldsymbol{x}_i) = 1\)</span>!</li><li>若<span class="math inline">\(\alpha_i = 0\)</span>, 那么该样本点不对模型产生影响;</li><li>若<span class="math inline">\(y_if(\boldsymbol{x}_i) = 1\)</span>, 也就是等式约束, 那么该样本点在<strong>最大间隔边界上</strong>!, 此处的样本就是支持向量!</li></ol><p>也就是说, 我们的模型仅仅与<strong>支持向量</strong>有关, 这也是为什么叫做支持向量机的原因.</p><h3 id="smo算法">SMO算法</h3><ul class="task-list"><li><input type="checkbox" disabled="" />todo 至于求解的SMO算法以及核函数/核方法之类的后续再补.</li></ul><h2 id="核函数">6.3 核函数</h2><ul class="task-list"><li><input type="checkbox" disabled="" />todo</li></ul><h2 id="软间隔">6.4 软间隔</h2><p>在上述的内容中, 我们要求样本严格可分, 来得到一个『间隔』使得样本分开, 这个间隔称为"<strong>硬间隔</strong>"(hard margin). 但是在实际的情况中, 有很多样本并不是严格线性可分, 可能存在部分(<strong>少量</strong>)的『出错点』.</p><img src="/2022/01/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E2%80%94%E2%80%94%E7%AC%AC06%E7%AB%A0%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/%E8%BD%AF%E9%97%B4%E9%9A%94.png" class="" title="软间隔.png"><p>所以我们需要寻找一个允许存在误差的间隔, 称之为"<strong>软间隔</strong>"(soft margin). 当然, 存在的误差要尽可能的少, 所以我们在优化目标上增加『损失函数』, 使得不满足约束的, 赋予一定损失, 满足约束的没有损失:</p><p><span class="math display">\[\min_{(\boldsymbol{w}, b)} {\frac{1}{2}\|\boldsymbol{w}\|^2} + C\sum^m_{i=1}\ell_{0/1}(y_i(\boldsymbol{w}^T\boldsymbol{x}_i + b)-1) \tag{9}\]</span></p><p>其中<span class="math inline">\(C\)</span>是一个常数, 若定义<span class="math inline">\(C\)</span>很大, 则对损失要求严格, 反之则越宽松. <span class="math inline">\(\ell_{0/1}\)</span>则代表『0/1损失函数』, 但是非凸, 非连续, 数学性质不好, 所以常使用『hinge(合页)损失』.</p><p>那么损失函数变成</p><p><span class="math display">\[\min_{(\boldsymbol{w}, b)} {\frac{1}{2}\|\boldsymbol{w}\|^2} + C\sum^m_{i=1}{\max{(0, 1-y_i(\boldsymbol{w}^T\boldsymbol{x}_i + b))}} \tag{10}\]</span></p><p>还有常见的指数损失和对率损失等.</p><img src="/2022/01/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E2%80%94%E2%80%94%E7%AC%AC06%E7%AB%A0%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/%E5%B8%B8%E8%A7%81%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0.png" class="" title="常见损失函数.png"><p>引入<strong>松弛变量</strong>(slack variable)<span class="math inline">\(\xi_i\)</span>, 那么可以重写为</p><p><span class="math display">\[\begin{aligned}  \min_{(\boldsymbol{w}, b)} &amp;\quad{\frac{1}{2}\|\boldsymbol{w}\|^2} + C\sum^m_{i=1}{\xi_i} \\  s.t. &amp;\quad 1-y_i(\boldsymbol{w}^T\boldsymbol{x} + b) \leq \xi_i \\  &amp;\quad \xi_i \geq 0, i = 1,2,\dots, m. \tag{11}\end{aligned}\]</span></p><p>这就是常见的<strong>软间隔支持向量机</strong>.</p><p>故意化简为上述形式, 那么就可以和普通支持向量机一样使用拉格朗日函数化为对偶问题再进行求解.</p><h2 id="支持向量回归">6.5 支持向量回归</h2><p>之前提到过的<a href="https://gipbear.github.io/2022/01/14/机器学习西瓜书——第03章线性模型/#线性回归">线性回归模型</a>, 是学习得到一条线<span class="math inline">\(f(x)\)</span>, 而将支持向量运用于回归的问题上, 是学习得到一条「间隔带」<span class="math inline">\(f(x)\pm\epsilon\)</span>.</p><img src="/2022/01/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E2%80%94%E2%80%94%E7%AC%AC06%E7%AB%A0%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E5%9B%9E%E5%BD%92.png" class="" title="支持向量回归"><p>为了类似支持向量的分类模型, 写出如下形式:</p><p><span class="math display">\[\min_{(\boldsymbol{w}, b)} {\frac{1}{2}\|\boldsymbol{w}\|^2} + C\sum^m_{i=1}\ell_{\epsilon}(f(\boldsymbol{x}_i)-y_i) \tag{12}\]</span></p><p>其中<span class="math inline">\(C\)</span>为正则化尝试, <span class="math inline">\(\ell_{\epsilon}\)</span>是<span class="math inline">\(\epsilon\)</span>-不敏感损失函数</p><p><span class="math display">\[\ell_{\epsilon}(z) =\begin{cases}  0, &amp;if |z| \leq \epsilon; \\  |z| - \epsilon, &amp; otherwise.\end{cases}\]</span></p><p>模仿软间隔支持向量机的形式, 再引入松弛变量<span class="math inline">\(\xi_i\)</span>和<span class="math inline">\(\hat{\xi}_i\)</span>, 两个松弛变量的原因是正负两侧的松弛程度可以不一样, 从而重写为:</p><p><span class="math display">\[\begin{aligned}  \min_{(\boldsymbol{w}, b, \xi_i, \hat{\xi}_i)} &amp;\quad{\frac{1}{2}\|\boldsymbol{w}\|^2} + C\sum^m_{i=1}{(\xi_i + \hat{\xi}_i)} \\  s.t. &amp;\quad f(\boldsymbol{x}_i) - y_i \leq \xi_i + \epsilon \\  &amp;\quad y_i - f(\boldsymbol{x}_i) \leq \hat{\xi}_i + \epsilon \\  &amp;\quad \xi_i \geq 0, \hat{\xi_i} \geq 0, i = 1,2,\dots, m. \tag{11}\end{aligned}\]</span></p><p>又是类似的优化形式, 同样使用拉格朗日函数转化后求解.</p><h2 id="核方法">6.6 核方法</h2><ul class="task-list"><li><input type="checkbox" disabled="" />todo</li></ul><h2 id="个人收获">个人收获</h2><p>首先这一章对我来说是比较困难的, 主要是有些地方懵懵懂懂, 需要花一定的时间来消化.</p><ol type="1"><li>这次对拉格朗日函数有了更进一步的理解!, 终于明白为什么之前说拉格朗日乘子法只能用于等式约束, 而这里可以用于不等式约束, 原来是KKT条件的作用.</li><li>之前两次都是看到KKT条件然后放弃, 因为不理解这几个条件是干什么的, 这次终于明白了, 是增加约束, 使得不等式项消失, 而保留等式, 从而满足拉格朗日乘子法的使用条件, 也是因此获得支持向量.</li><li>软间隔这次也明白了, 是为了容错, 从而增加了松弛变量, 变化为相同形式求解.</li><li>关于支持向量回归这里, 我倒是感觉意义不大(不是), 所以没有太深入理解.</li><li>在拉格朗日乘子法这里还有一个对偶函数, 听的有些懵懵的, 后续再进一步整理这个理论.</li></ol>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是关于周志华老师编写的机器学习书籍『西瓜书』的第六章支持向量机.&lt;/p&gt;
&lt;p&gt;主要的内容有: 支持向量机的模型理解、支持向量、硬间隔与软间隔、在不等式约束下使用拉格朗日乘子法转化为对偶问题、KKT条件、支持向量回归等.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://gipbear.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="西瓜书" scheme="https://gipbear.github.io/tags/%E8%A5%BF%E7%93%9C%E4%B9%A6/"/>
    
    <category term="支持向量机" scheme="https://gipbear.github.io/tags/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>机器学习西瓜书——第05章神经网络</title>
    <link href="https://gipbear.github.io/2022/01/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E2%80%94%E2%80%94%E7%AC%AC05%E7%AB%A0%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>https://gipbear.github.io/2022/01/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E2%80%94%E2%80%94%E7%AC%AC05%E7%AB%A0%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</id>
    <published>2022-01-22T16:01:54.000Z</published>
    <updated>2022-01-27T15:12:16.369Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是关于周志华老师编写的机器学习书籍『西瓜书』的第五章神经网络.</p><p>主要的内容有: M-P神经元模型的构成、简单感知机和多层网络、以及著名BP算法的推导过程(激活函数是Sigmoid).</p></blockquote><span id="more"></span><p>这里所说的神经网络是指: 由具有<strong>适应性</strong>的<code>简单单元</code>组成的广泛<strong>并行互联</strong>的网络, 能够<strong>模拟</strong>生物神经对现实世界做出的交互反映.</p><h2 id="神经元模型">5.1 神经元模型</h2><p>在神经网络中, 最基本的组成成分就是神经元(neuron)模型, 即上述的<code>简单单元</code>.</p><h3 id="工作过程">工作过程</h3><p>首先介绍以下最简单的神经元的工作过程:</p><ol type="1"><li>首先神经元通过接收来自n个其他神经元传输来的<code>输入</code>信号<span class="math inline">\(x_i\)</span>;</li><li>并通过带<code>权重</code><span class="math inline">\(w_i\)</span>的连接(connection)进行传递;</li><li>然后, 神经元收到的总输入值将与神经元的<code>阈值</code><span class="math inline">\(\theta\)</span>(threshold))进行比较;</li><li>再通过<code>激活函数</code><span class="math inline">\(f\)</span>(activation function)处理以产生神经元的<code>输出</code><span class="math inline">\(y\)</span>.</li></ol><img src="/2022/01/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E2%80%94%E2%80%94%E7%AC%AC05%E7%AB%A0%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/mp%E7%A5%9E%E7%BB%8F%E5%85%83%E6%A8%A1%E5%9E%8B.png" class="" title="mp神经元模型.png"><p>这就是非常经典的<strong>M-P神经元模型</strong>, 模拟生物的神经元的连接与激活过程.</p><h3 id="激活函数">激活函数</h3><p>其中最理想的激活函数是<strong>阶跃函数</strong>, 直接表示神经元是否激活, 但是阶跃函数并不光滑连续, 数学性质并不好. 所以实际上常用的是<code>sigmoid</code>函数<span class="math inline">\(f(z) = \frac{1}{1+e^{-z}}\)</span>, 这在<a href="https://gipbear.github.io/2022/01/14/机器学习西瓜书——第03章线性模型/#对数几率回归">对数几率模型</a>中也使用过.</p><img src="/2022/01/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E2%80%94%E2%80%94%E7%AC%AC05%E7%AB%A0%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/%E9%98%B6%E8%B7%83%E5%87%BD%E6%95%B0%E5%92%8Csigmoid%E5%87%BD%E6%95%B0.png" class="" title="阶跃函数和sigmoid函数.png"><blockquote><p>激活函数是对<code>总输入与阈值的比较</code>进行处理! (我之前错误的以为是激活函数对输入进行处理后再与阈值比较);</p><p>激活函数本质上是在加入非线性因素, 使得神经网络来解决非线性问题.</p></blockquote><h2 id="感知机与多层网络">5.2 感知机与多层网络</h2><h3 id="感知机">感知机</h3><p>感知机(Perceptron)由两层神经元组成, 其中<code>输入层</code>接收外界传输的输入信号, 并传递给输出层, <code>输出层</code>即为上述所说的<code>M-P神经元</code>, 亦称<code>阈值逻辑单元</code>(threshold logic unit). 所以实际上<strong>具有处理能力的功能神经元只有一层输出层</strong>, 学习能力有限.</p><p>在感知机中, 输入的数据集和输出的激活函数都是给定的, 感知机需要学习的就是未知的<strong>权重</strong><span class="math inline">\(w_i\)</span>和<strong>阈值</strong><span class="math inline">\(\theta\)</span>来使其有效的工作.</p><p>但是从输出<span class="math inline">\(y = f(\sum_{i=1}^n{w_ix_i-\theta})\)</span>中来看, 阈值可以被看作<code>第n+1项</code>输入, 值为<code>-1</code>, 这样就可以将阈值和权重统一为<strong>权重学习</strong>即可!</p><p>学习规则:</p><p><span class="math display">\[w_i \leftarrow w_i + \Delta w_i \\\Delta w_i = \eta(y-\hat{y})x_i\]</span></p><p>其中<span class="math inline">\(\hat{y}\)</span>是感知机的输出, <span class="math inline">\(\eta\in(0, 1)\)</span>称为<strong>学习率</strong>(learning rate), 若预测正确, 则感知机不变, 若预测错误, 则根据错误程度调整权重.</p><h3 id="多层网络">多层网络</h3><p>若两类模式是线性可分的, 即存在一个线性超平面能将它们分开, 那么感知机的学习过程一定会<strong>收敛</strong>(converge), 从而求得合适的权值; 反之, 感知机的学习过程将会<strong>振荡</strong>(fluctuation), 难以求得合适的解.</p><p>若要解决非线性可分的问题, 就需要考虑使用多层<strong>功能神经元</strong>, 一般称输入层和输出层之间的一层神经元层为<strong>隐层或隐含层</strong>(hidden layer).</p><p>常见的神经元是层级结构的, 每层神经元与下一层的神经元全互连, 神经元之间不存在同层连接, 也不存在跨层连接, 这样的神经网络结构通常称为"<strong>多层前馈神经网络</strong>"(multi-layer feedforward neural networks). 其中输入层仅接收输入, 隐层与输出层使用功能神经元进行函数处理.</p><blockquote><p>"前馈"并不是信号不能向后传播, 而是指网络拓扑结构中不存在<strong>环</strong>或回路.</p></blockquote><img src="/2022/01/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E2%80%94%E2%80%94%E7%AC%AC05%E7%AB%A0%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/%E5%A4%9A%E5%B1%82%E5%89%8D%E9%A6%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" class="" title="多层前馈神经网络结构示意图"><p>(a)图可以称为"单隐层网络"或"两层网络". 我们的学习过程就是通过训练数据来调整神经元之间的连接权值(connection weight), 以及每个功能神经元的阈值, 看依旧是这权值和阈值.</p><h2 id="误差逆传播算法">5.3 误差逆传播算法</h2><p>对于多层的网络结构, 简单的感知机学习算法就不够使用了. 而<strong>误差逆传播</strong>(error BackPropagation, BP)算法是迄今为止最成功的神经网络学习算法.</p><p>为了说明<strong>BP算法</strong>, 先规定一些变量符号:</p><ol type="1"><li>训练集: <span class="math inline">\(D = \{(\boldsymbol{x}_1, \boldsymbol{y}_1), (\boldsymbol{x}_2, \boldsymbol{y}_2), \dots, (\boldsymbol{x}_m, \boldsymbol{y}_m)\}, \boldsymbol{x}_i \in \mathbb{R}^d, \boldsymbol{y}_i \in \mathbb{R}^l\)</span>.</li><li>输入层: 输入示例<span class="math inline">\(x\)</span>由<span class="math inline">\(d\)</span>个属性描述. 则输入层有<span class="math inline">\(d\)</span>个输入神经元.</li><li>输出层: 输出<span class="math inline">\(y\)</span>是<span class="math inline">\(l\)</span>维向量. 则输出层有<span class="math inline">\(l\)</span>个输出神经元. 第<span class="math inline">\(j\)</span>个神经元的<strong>阈值</strong>用<span class="math inline">\(\theta_j\)</span>表示.</li><li>隐层: 隐层<span class="math inline">\(b\)</span>假设使用<span class="math inline">\(q\)</span>个隐层神经元. 第<span class="math inline">\(h\)</span>个神经元的<strong>阈值</strong>使用<span class="math inline">\(\gamma_h\)</span>表示.</li><li>输入层--隐层: 输入层第<span class="math inline">\(i\)</span>个神经元与隐层第<span class="math inline">\(h\)</span>个神经元的<strong>权值</strong>使用<span class="math inline">\(v_{ih}\)</span>表示, 那么第<span class="math inline">\(h\)</span>个隐层神经元的总输入为<span class="math inline">\(\alpha_h = \sum\limits_{i=1}^d{(v_{ih}x_i)}\)</span>.</li><li>隐层--输出层: 隐层第<span class="math inline">\(h\)</span>个神经元与输出层第<span class="math inline">\(j\)</span>个神经元的<strong>权值</strong>使用<span class="math inline">\(w_{hj}\)</span>表示, 那么第<span class="math inline">\(j\)</span>个输出神经元的总输入为<span class="math inline">\(\beta_j = \sum\limits_{h=1}^q{(w_{hj}b_h)}\)</span>.</li><li>激活函数: 此处依旧使用<a href="#激活函数">sigmoid函数</a>.</li></ol><p>示意图如下:</p><img src="/2022/01/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E2%80%94%E2%80%94%E7%AC%AC05%E7%AB%A0%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/BP%E7%BD%91%E7%BB%9C%E5%8F%8A%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E7%AC%A6%E5%8F%B7.png" class="" title="BP网络及算法中的变量符号.png"><h2 id="参数学习过程">5.3 参数学习过程</h2><p>其中需要确定的权值有<span class="math inline">\((dq+ql)\)</span>个, 阈值有<span class="math inline">\((q+l)\)</span>个.</p><p>同样假设输出为<span class="math inline">\(\hat{\boldsymbol{y}} = \{\hat{y}_1, \hat{y}_2, \dots, \hat{y}_l\}\)</span>, 其中<span class="math inline">\(\hat{y}_j = f(\beta_j-\theta_j)\)</span>.</p><p>其中对于<strong>第K例输入样本</strong>可以求出网络的<strong>均方误差</strong>为:</p><p><span class="math display">\[E_k = \frac{1}{2} \sum^l_{j=1}(\hat{y}_j-y_j)^2\]</span></p><p>将均方误差作为我们的损失函数, 与感知机的更新方法类似, 对任意参数<span class="math inline">\(\omega\)</span>, 更新估计式为</p><p><span class="math display">\[\omega \leftarrow \omega + \Delta \omega\]</span></p><p>也同样将阈值加入其中一起计算, 那么只需要估计<strong>两个参数</strong>即可, 即输入层神经元与隐层神经元的<strong>权值</strong><span class="math inline">\(v_{ih}\)</span>, 以及隐层神经元与输出层神经元的<strong>权值</strong><span class="math inline">\(w_{hj}\)</span>.</p><h3 id="梯度下降法求解">梯度下降法求解</h3><p>BP算法基于<a href="https://gipbear.github.io/2022/01/17/机器学习中可能会使用的理论/#梯度下降法">梯度下降法</a>(gradient descent), 以目标的负梯度方向对参数进行调整.</p><p>以隐层到输出层的权值<span class="math inline">\(w_{hj}\)</span>为例进行推导, 对于给定的学习率<span class="math inline">\(\eta\)</span>, 有</p><p><span class="math display">\[\Delta w_{hj} = -\eta \frac{\partial E_k}{\partial w_{hj}}\]</span></p><p>而我们注意到, 权值<span class="math inline">\(w_{hj}\)</span>先影响到输入总值<span class="math inline">\(\beta\)</span>, 然后影响到输出值<span class="math inline">\(\hat{y}_j\)</span>, 最后影响到误差<span class="math inline">\(E\)</span>, 由此展开有:</p><p><span class="math display">\[\frac{\partial E_k}{\partial w_{hj}} = \frac{\partial E_k}{\partial \hat{y}_j} \cdot \frac{\partial \hat{y}_j}{\partial \beta_j} \cdot \frac{\partial \beta_j}{\partial w_{hj}}\]</span></p><p>根据<span class="math inline">\(\beta_j\)</span>的定义, 显然有<span class="math inline">\(\frac{\partial \beta_j}{\partial w_{hj}} = b_h\)</span>.</p><p>又根据<a href="https://gipbear.github.io/2022/01/17/机器学习中可能会使用的理论/#sigmoid性质">Sigmoid函数的性质</a>, 有:</p><p><span class="math display">\[\begin{aligned}  g_j  &amp;= - \frac{\partial E_k}{\partial \hat{y}_j} \cdot \frac{\partial \hat{y}_j}{\partial \beta_j} \\  &amp;= -(\hat{y}_j-y_j)f&#39;(\beta_j-\theta_j) \\  &amp;= (y_j-\hat{y}_j)\hat{y}_j(1-\hat{y}_j)\end{aligned}\]</span></p><p>由此可得权值<span class="math inline">\(w_{hj}\)</span>的更新公式</p><p><span class="math display">\[\Delta w_{hj} = \eta g_j b_h;\]</span></p><p>同理其他三个参数的更新公式, 此处不再赘述.</p><p>算法伪代码如下:</p><img src="/2022/01/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E2%80%94%E2%80%94%E7%AC%AC05%E7%AB%A0%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/%E8%AF%AF%E5%B7%AE%E9%80%86%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95.png" class="" title="误差逆传播算法.png"><blockquote><p>其中<strong>停止条件</strong>根据缓解BP的<strong>过拟合策略</strong>有关.</p></blockquote><h3 id="过拟合策略">过拟合策略</h3><p>由于表达效果往往非常好, 所以经常会遭遇<strong>过拟合</strong>的问题. 通常有两种策略来解决:</p><ol type="1"><li><p>第一种是早停(early stopping): 将数据集分为训练集和验证集, 当训练集误差降低但验证集误差升高时停止训练, 并返回具有最小验证集误差的连接权值和阈值.</p></li><li><p>第二种是正则化(regularization), 在误差函数中增加一个用于描述<strong>网络复杂度</strong>的部分, 使得训练过程中偏好较小的参数, 降低网络复杂度. 例如使用连接权值与阈值的平方和:</p><p><span class="math display">\[E = \lambda \frac{1}{m}\sum_{k=1}^m {E_k} + (1-\lambda) \sum_i{w_i^2}\]</span></p><p>其中的<span class="math inline">\(\lambda\)</span>是对<strong>经验误差</strong>和<strong>网络复杂度</strong>的折中, 通常用交叉验证来估计值.</p></li></ol><h3 id="不同的bp算法">不同的BP算法</h3><p>可以发现, 上述过程中我们是对<strong>每个训练样例</strong>来更新连接权值和阈值, 更新参数非常频繁, 不同样例的训练可能会对之前更新的效果进行<strong>抵消</strong>, 最终得到我们需要的积累误差:</p><p><span class="math display">\[E = \frac{1}{m}\sum_{k=1}^m {E_k}\]</span></p><p>所以为了积累误差达到极小值点, 往往需要<strong>更多次数的迭代</strong>, 这个方法称为『<strong>标准BP算法</strong>』.</p><p>类似的, 基于累积误差最小化的更新规则也可以推导出『<strong>累积BP算法</strong>』, 该方法直接针对累积误差最小化, 在读取整个训练集后才对参数进行更新, 更新参数频率低得多, 而且在很多任务中, 积累误差下降到一定之后,下一步下降会非常缓慢, 而此时的标准BP算法则可以更快的获得较好的解.</p><blockquote><p>区别类似于随机梯度下降算法(stochastic gradient descent, SGD)和标准梯度下降算法之间的区别.</p></blockquote><p>虽然两者都很常用, 但是在<strong>大数据集</strong>中, 标准BP算法的速度会更快.</p><h3 id="隐层神经元个数">隐层神经元个数</h3><p>有证明称, 只需要一个包含足够多神经元的隐层, 多层前馈网络就能以任意精度逼近任意复杂的连续函数.</p><p>但是如何设置神经元个数依旧没有定论, 一般使用『试错法』(trial-by-error)进行调整.</p><h2 id="个人收获">个人收获</h2><p>关于神经网络的学习, 之前在初步了解的时候被公式劝退, 这次再认真学习之后终于有些明朗了.</p><p>感知机中起作用的功能神经层只有输出层, 包括单隐层网络中输入层的结点仅起到输入作用, 所以这也是为什么明明<strong>画了三层</strong>网络,但是却叫<strong>双层网络</strong>的原因.</p><p>在学习公式推导之前一定要将符号弄清楚, 清楚符号的含义之后再推公式就清清楚楚了.</p><p>待更新: 关于全局最小和局部最小放在另外要写的<a href="https://gipbear.github.io/2022/01/17/机器学习中可能会使用的理论/#梯度下降法">梯度下降法</a>模块中再进一步阐述. 其他神经网络也有待进一步的学习, 最后向深度学习迈进.</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是关于周志华老师编写的机器学习书籍『西瓜书』的第五章神经网络.&lt;/p&gt;
&lt;p&gt;主要的内容有: M-P神经元模型的构成、简单感知机和多层网络、以及著名BP算法的推导过程(激活函数是Sigmoid).&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://gipbear.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="西瓜书" scheme="https://gipbear.github.io/tags/%E8%A5%BF%E7%93%9C%E4%B9%A6/"/>
    
    <category term="神经网络" scheme="https://gipbear.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>机器学习西瓜书——第04章决策树</title>
    <link href="https://gipbear.github.io/2022/01/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E2%80%94%E2%80%94%E7%AC%AC04%E7%AB%A0%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <id>https://gipbear.github.io/2022/01/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E2%80%94%E2%80%94%E7%AC%AC04%E7%AB%A0%E5%86%B3%E7%AD%96%E6%A0%91/</id>
    <published>2022-01-19T16:06:16.000Z</published>
    <updated>2022-01-27T15:12:19.547Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是关于周志华老师编写的机器学习书籍『西瓜书』的第四章决策树的学习.</p><p>主要的内容有: 决策树的基本流程、信息熵、信息增益(ID3决策树)、信息增益率(C4.5决策树)和基尼指数(CART决策树)等.</p></blockquote><span id="more"></span><h2 id="基本流程模型">4.1 基本流程(模型)</h2><p>决策树(decision tree)是基于<strong>树结构</strong>来进行决策的, 是符合人类习惯的一种决策机制.</p><p>其中, 叶结点对应的是决策结果, 其他结点对应的是一个属性决策『决定按照什么属性, 将结点中的样本集合划分为子结点』, 从根结点到每个叶子结点的路径对应了一个决策序列.</p><p>既然是一棵树, 那么自然就符合递归的定义, 那么什么时候停止决策呢? 有如下三种情况:</p><ol type="1"><li>当前结点包含的样本均属于<code>同一标记</code>, 无需划分.</li><li>当前结点包含的样本均属于<code>同一属性</code>, 不可划分; 其归属标记为<strong>该结点</strong>中包含样本数量最多的标记.</li><li>当前结点样本集合为<code>空</code>, 不可划分; 其归属标记为<strong>父结点</strong>中包含样本数量最多的标记.</li></ol><blockquote><p>其中第三种情况我的理解是:</p><p>在父结点的样本中, 不存在该属性标记, 所以结点划分的时候该结点的样本为空, 但是我们依旧需要考虑这种情况, 因为我们是针对训练集进行的训练, 但是模型在应用的新样本中, 有可能会遇到该情况, 所以也需要考虑在分支上.</p><p>那如何归类呢? 就是按照父结点中样本数量最多的标记来标记该结点!</p></blockquote><p>我们的目的就是在生成树结点的过程中去做出<code>正确</code>的决策划分, 通过训练集构建的决策树需要能够在进行分类决策的时候<strong>泛化能力</strong>更强.</p><p>什么决策才是正确的决策呢?</p><h2 id="划分选择">4.2 划分选择</h2><p>正确的划分是将决策树的分支结点所包含的样本尽可能<strong>属于同一标记</strong>. 即, 结点的<strong>纯度</strong>(purity)最高.</p><h3 id="信息熵">信息熵</h3><p>想要度量结点的<code>纯度</code>, 我们一般使用<strong>信息熵</strong>(information entropy)这个指标.</p><blockquote><p>首先, 假设当前的样本集合<span class="math inline">\(D\)</span>中包含<span class="math inline">\(n\)</span>类样本，其中，第<span class="math inline">\(k\)</span>类样本所占的比例为<span class="math inline">\(p_k,(k=1, 2, 3, ···, n)\)</span>则D的信息熵定义为：</p></blockquote><p><span class="math display">\[Ent(D) = -\sum^n_{k=1} {p_k\log_2{p_k}}\]</span></p><p>其数值则表示数据的混乱程度，<code>信息熵值越大则数据越混乱</code>，则表示不确定性越大，所包含的信息量也就越大，也就越难决策。</p><blockquote><p>这里需要注意信息熵是<strong>负数</strong>.</p></blockquote><p>好嘞, 有了信息熵的基础, 那接下来我们就可以利用信息熵来构建决策树模型.</p><h3 id="信息增益id3决策树">信息增益(ID3决策树)</h3><p>有了信息熵的定义, 我们就可以计算<strong>当前结点</strong>对于分类信息的信息熵, 然后按照哪个属性进行划分呢? 这时候就需要使用到<strong>信息增益</strong>(information gain)了.</p><p>按照如下思路进行考虑:</p><ol type="1"><li><strong>目的</strong>: 我们的目的是找出最适合进行决策的<strong>属性</strong>;</li><li><strong>计算</strong>: 那么不妨假设按照<code>属性A</code>进行决策, 那么当前结点中属于<code>属性A</code>的样本中按照<span class="math inline">\(v\)</span>个<code>属性取值</code>计算得到的信息熵总和是多少呢?</li><li><strong>权重</strong>: 由于属于<code>属性A</code>中每个<code>属性取值</code>的样本个数不同, 那么对于信息熵总和的影响自然也就不同, 所以在计算的时候需要赋予一定的权重, 最简单的就是第v个属性取值占该属性样本的比重<span class="math inline">\(\frac{|D^v|}{|D|}\)</span></li><li><strong>循环</strong>: 依次类推计算当前结点各个属性的信息熵.</li><li><strong>结果</strong>: 所以, 信息增益就是用<strong>当前结点</strong>的信息熵, 分别减去<strong>按照各个属性</strong>决策的信息熵总和, 由于这里是<strong>减</strong>, 自然是选择<strong>信息增益越大</strong>的属性越好啦!</li></ol><p>得到的信息增益计算公式:</p><p><span class="math display">\[Gain(D,a) = Ent(D) - \sum_{v=1}^V{\frac{|D^v|}{|D|}Ent(D^v)}\]</span></p><p>著名的<strong>ID3决策树</strong>就是使用信息增益来实现属性划分的.</p><h3 id="增益率c4.5决策树">增益率(C4.5决策树)</h3><p>但是我们容易发现, 若将『编号』这种属性进行计算的时候</p><p><span class="math display">\[\begin{aligned}Gain(D,编号)&amp;= Ent(D) - \sum_{v=1}^V{\frac{1}{V}Ent(1)} \\&amp;= Ent(D) - Ent(1) \\&amp;= Ent(D)\end{aligned}\]</span></p><p>很明显这种取值不重复的属性的信息增益极大, 换句话说, 是『<strong>属性取值很多</strong>』的属性, 但这很明显不符合我们的预期, 因为我们都知道编号这种属性基本上是没有意义的.</p><p>由此, 我们引入了<strong>信息增益率</strong>(gain ratio)的概念.</p><p>那么我们理解一下是什么是信息增益率? 信息增益自然就是上面提到的部分, 那么『率』呢? 就需要相对于某个值了.</p><p>这里引入一个属性"<strong>固有值</strong>"(intrinsic value)的概念:</p><p><span class="math display">\[IV(a) = -\sum_{v=1}^V {\frac{|D^v|}{|D|}\log_2{\frac{|D^v|}{|D|}}}\]</span></p><blockquote><p>是不是跟信息增益很相似? 类比一下: 这就是衡量该属性取值的『混乱程度』, 数值越大越混乱, 自然就越不能要.</p></blockquote><p>所以将信息增益率定义为:</p><p><span class="math display">\[Gain_ratio(D, a) = \frac{Gain(D, a)}{IV(a)}\]</span></p><p>由于固有值在分母, 所以信息增益率整体会偏好选择属性数目较少的属性.</p><p>著名的<strong>C4.5决策树</strong>就是利用了信息增益率的方法来实现决策树的, 但不是直接选择增益率最大的属性, 而是使用<strong>启发式</strong>的方法: 先选择<strong>信息增益</strong>高于平均水平的属性, 再从中选择出<strong>增益率</strong>最高的.</p><h3 id="基尼指数cart决策树">基尼指数(CART决策树)</h3><p>最后要提的就是<strong>基尼指数</strong>(Gini index)了, 这是使用了一个与信息熵类似的概念——基尼值, 它们都是来衡量数据集的<code>纯度</code>.</p><p><span class="math display">\[\begin{aligned}Gini(D)&amp;= \sum^n_{i=1}\sum_{j\neq{i}}{p_ip_j}&amp;= 1 - \sum^n_{i=1}{p_i^2}\end{aligned}\]</span></p><p>正如公式表示的, 基尼值反映了在样本中随机抽取两个样本, 其标记不一致的概率. 反过来就是用<code>1</code>减去<code>一致</code>的概率, 同样考虑样本个数<strong>权重</strong>的影响, 得到基尼指数计算公式:</p><p><span class="math display">\[Gini_index(D, a) = \sum^V_{v=1}{\frac{|D^v|}{|D|}Gini(D^v)}\]</span></p><p>著名的<strong>CART决策树</strong>就是使用了基尼指数来划分属性的.</p><h2 id="个人收获">个人收获</h2><p>学习了决策树模型的三种建模方式, 起码知道了ID3有比较明显的缺陷, 所以一般可以使用C4.5或CART决策树.</p><p>决策树一般不会直接使用, 多使用在森林等集成算法中, 之后再进一步学习.</p><p>关于后续的剪枝处理也会抽空尽快学习.</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是关于周志华老师编写的机器学习书籍『西瓜书』的第四章决策树的学习.&lt;/p&gt;
&lt;p&gt;主要的内容有: 决策树的基本流程、信息熵、信息增益(ID3决策树)、信息增益率(C4.5决策树)和基尼指数(CART决策树)等.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://gipbear.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="西瓜书" scheme="https://gipbear.github.io/tags/%E8%A5%BF%E7%93%9C%E4%B9%A6/"/>
    
    <category term="决策树" scheme="https://gipbear.github.io/tags/%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>cpp数据结构之vector的常见用法</title>
    <link href="https://gipbear.github.io/2022/01/19/cpp%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8Bvector%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95/"/>
    <id>https://gipbear.github.io/2022/01/19/cpp%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8Bvector%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95/</id>
    <published>2022-01-19T12:34:03.000Z</published>
    <updated>2022-02-10T07:26:42.384Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是关于c++中常用的数组<code>vector</code>的一些常见用法的总结, 主要是一些常用的调用方法, 主要是我的平时的<a href="https://gipbear.github.io/tags/leetcode题解/">leetcode题解</a>中经常会使用的.</p></blockquote><span id="more"></span><h2 id="数组-vector">数组 vector</h2><p>一般大家应该都学习过C语言, 在C语言中, <strong>数组</strong>通常使用<code>int[]</code>来表示, 但是在使用的过程中, 通常会出现一些麻烦(大佬轻喷), 比如静态初始化大小不能直接使用参数而是一个常量, 动态申请空间需要使用<code>malloc</code>等. 虽然手动分配内存可能会给代码带来一定的效率提升, 但是复杂的细节操作让我这个从<code>python</code>转来刷题应试的小白很难接受呀.</p><p>所以一般直接使用标准库提供的<code>vector</code>(很多人都是这么建议的), 这个是比<code>int[]</code>更加的高级的容器, 可以自动扩容, 让你不需要操心细节, 非常nice:man_technologist:!</p><p>那么接下来我们来看一下vector的一些常见用法吧:</p><h2 id="常见用法">常见用法</h2><p>首先需要导入标准库</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="初始化">初始化</h3><p>一维数组初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; res1;  <span class="comment">//简单初始化一个空数组</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res2</span><span class="params">(n+<span class="number">1</span>)</span></span>;  <span class="comment">//初始化大小为 n+1 大小的数组</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res3</span><span class="params">(n+<span class="number">1</span>, <span class="number">666</span>)</span></span>;  <span class="comment">//初始化大小为 n+1 大小的数组, 初始值为 666</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; res4&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;  <span class="comment">// 直接初始化内容</span></span><br></pre></td></tr></table></figure><p>二维数组初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res1;  <span class="comment">// 初始化一个二维数组;</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">res2</span>(m, vmctor&lt;<span class="keyword">int</span>&gt;(n, <span class="number">2</span>));  <span class="comment">// 初始化一个二维数组, 大小为m*n, 默认值为2.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置大小</span></span><br><span class="line">res.<span class="built_in">resize</span>(m, vector&lt;<span class="keyword">int</span>&gt;(n));</span><br></pre></td></tr></table></figure><p>其中的元素也可以是其他类型, 例如<code>string</code>, <code>bool</code>等.</p><h3 id="查询属性">查询属性</h3><ol type="1"><li><p><strong>数组大小</strong></p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.<span class="built_in">size</span>();  <span class="comment">// 返回数组的大小</span></span><br></pre></td></tr></table></figure></p></li><li><p><strong>判断数组是否为空</strong></p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.<span class="built_in">empty</span>();</span><br></pre></td></tr></table></figure></p></li><li><p>返回数组头的指针</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.<span class="built_in">begin</span>();</span><br></pre></td></tr></table></figure></p></li><li><p>返回数组尾+1的指针, 注意是指向<strong>最后的后一个</strong>, 也就是空</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.<span class="built_in">end</span>();</span><br></pre></td></tr></table></figure></p></li><li><p>得到数组头的引用</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.<span class="built_in">front</span>();</span><br></pre></td></tr></table></figure></p></li><li><p>得到数组尾的引用</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.<span class="built_in">back</span>();</span><br></pre></td></tr></table></figure></p></li></ol><h3 id="增删改查">增删改查</h3><ol type="1"><li><p><strong>增加元素</strong></p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.<span class="built_in">push_back</span>(元素);  <span class="comment">// 在尾部插入一个元素</span></span><br></pre></td></tr></table></figure></p></li><li><p><strong>删除元素</strong></p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res.<span class="built_in">pop_back</span>(元素);  <span class="comment">// 删除最后一个元素</span></span><br><span class="line">res.<span class="built_in">erase</span>(res.<span class="built_in">begin</span>() + i);  <span class="comment">// 删除第i个元素</span></span><br></pre></td></tr></table></figure></p></li><li><p><strong>修改元素</strong></p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res[pos] = 值;  <span class="comment">//  直接在第pos个位置修改为某个值</span></span><br></pre></td></tr></table></figure></p></li><li><p>查找元素(按索引查找)</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res[pos];  <span class="comment">// 直接查找第pos个位置的元素</span></span><br></pre></td></tr></table></figure></p></li><li><p>那如果想查找值是否在数组中(按值查找) <code>vector</code>没有直接的方法, 就需要使用标准库中的find方法来查找(这也是我写这篇的起因, 以后还有不懂的就加进来).</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span>  <span class="comment">// 首先必须导入标准库, 该库提供了大量基于迭代器的模板函数</span></span></span><br><span class="line"><span class="built_in">find</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>(), key);  <span class="comment">// 返回范围内第一个等于给定key的元素位置指针, 一般用于判断是否存在</span></span><br></pre></td></tr></table></figure></p></li></ol><h3 id="其他">其他</h3><ol type="1"><li><p>重新定义数组大小</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.<span class="built_in">resize</span>(m);  <span class="comment">// 数组大小重新定义为m</span></span><br></pre></td></tr></table></figure></p></li><li><p>清空数组</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.<span class="built_in">clear</span>();  <span class="comment">// 清空数组</span></span><br></pre></td></tr></table></figure></p></li><li><p>与另一个数组交换数据</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swap</span>(res1, res2);  <span class="comment">// res1与res2交换数组</span></span><br></pre></td></tr></table></figure></p></li><li><p><strong>数组求和</strong> 需要借助库函数<code>numeric</code>实现</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>)  <span class="comment">// 从0为基准开始求和</span></span><br></pre></td></tr></table></figure></p></li><li><p><strong>数组排序</strong> 需要借助库函数<code>algorithm</code>实现</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());  <span class="comment">// 数组升序</span></span><br><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());  <span class="comment">// 数组降序</span></span><br></pre></td></tr></table></figure></p></li></ol><p>以上<strong>加粗</strong>的也是比较常用的, 其实也很简单啦, 不用很复杂的操作.</p><h2 id="个人收获">个人收获</h2><p>这些方法对比<code>python</code>的<code>list</code>来学其实很简单, 只不过换了一个函数名而已, 当然还是有很多操作不一样, 比如指针操作, 记住就好了, 积少成多, 熟能生巧!</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是关于c++中常用的数组&lt;code&gt;vector&lt;/code&gt;的一些常见用法的总结, 主要是一些常用的调用方法, 主要是我的平时的&lt;a href=&quot;https://gipbear.github.io/tags/leetcode题解/&quot;&gt;leetcode题解&lt;/a&gt;中经常会使用的.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="语言特性" scheme="https://gipbear.github.io/categories/%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/"/>
    
    
    <category term="c++" scheme="https://gipbear.github.io/tags/c/"/>
    
    <category term="vector" scheme="https://gipbear.github.io/tags/vector/"/>
    
  </entry>
  
  <entry>
    <title>机器学习中可能会使用的理论</title>
    <link href="https://gipbear.github.io/2022/01/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%8F%AF%E8%83%BD%E4%BC%9A%E4%BD%BF%E7%94%A8%E7%9A%84%E7%90%86%E8%AE%BA/"/>
    <id>https://gipbear.github.io/2022/01/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%8F%AF%E8%83%BD%E4%BC%9A%E4%BD%BF%E7%94%A8%E7%9A%84%E7%90%86%E8%AE%BA/</id>
    <published>2022-01-17T12:24:01.000Z</published>
    <updated>2022-01-27T15:12:46.990Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是关于一些西瓜书学习过程中的一些数学理论的汇总.</p></blockquote><span id="more"></span><h2 id="线性可分和线性模型1">线性可分和线性模型<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></h2><p>线性可分是指可以使用一个<strong>线性函数</strong>(二维的是直线, 三维的是平面等更高维的线性函数), 将两类样本分开.</p><p>线性模型并不是说一定要使用线性函数去拟合数据, 这是一个<strong>误区</strong>, 区分模型是否线性, 主要是看模型中的自变量<span class="math inline">\(x\)</span>前的系数<span class="math inline">\(w\)</span>, <strong>一个<span class="math inline">\(x\)</span>只受一个<span class="math inline">\(w\)</span>影响</strong>, 那么模型就是线性模型!</p><p>例如有一个模型的函数是:<span class="math inline">\(y = w_0 + w_1x + w_2x^2\)</span>, 很明显是一个非线性的二次方函数, 但是若我们令<span class="math inline">\(x_1 = x, x_2 = x^2\)</span>, 那么模型的函数就可以转化为<span class="math inline">\(y = w_0 + w_1x_1 + w_2x_2\)</span>, 从而变成了一个线性函数, 也就是线性模型.</p><h2 id="分类变量化为连续值2">分类变量化为连续值<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></h2><p>有时我们的有些数据可能是离散的, 这时候我们会考虑将数据化为<strong>连续值</strong>.</p><ul><li>在<strong>有序</strong>(order)数据中, 比如"低" "中" "高"等, 可以使用<span class="math inline">\(\{0, 0.5, 1\}\)</span>来表示.<ul><li>直接使用<code>map</code>映射, 或使用<code>LabelEncoder</code>.</li></ul></li><li>在<strong>无序</strong>数据中, 比如"西瓜" "南瓜" "冬瓜"等, 就需要使用<span class="math inline">\((1,0,0), (0,1,0), (0,0,1)\)</span>来表示.<ul><li>独热编码<code>OneHotEncoder</code>或 pandas 中的<code>get_dummies</code>.</li></ul></li></ul><blockquote><p>无序属性在连续化的时候, 不能像连续值一样直接使用值代替, 因为值之间存在大小, 从而会引入<strong>不当的有序关系</strong>.</p><p>但其实对分类变量化为连续值, 或多或少会引入一些额外的有序关系.</p></blockquote><h2 id="广义特征值与广义瑞利商3">广义特征值与广义瑞利商<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></h2><p>广义特征值和广义瑞利商在<a href="https://gipbear.github.io/2022/01/14/机器学习西瓜书——第03章线性模型/">机器学习西瓜书——第03章线性模型</a>中有涉及</p><h3 id="广义特征值">广义特征值</h3><p>设<span class="math inline">\(\boldsymbol{A}\)</span>, <span class="math inline">\(\boldsymbol{B}\)</span>为<span class="math inline">\(n\)</span>阶方阵, 若存在数<span class="math inline">\(\lambda\)</span>, 使得方程<span class="math inline">\(\boldsymbol{A}x = \lambda \boldsymbol{B}x\)</span>存在非零解, 则称<span class="math inline">\(\lambda\)</span>为<span class="math inline">\(\boldsymbol{A}\)</span>相对于<span class="math inline">\(\boldsymbol{B}\)</span>的<strong>广义特征值</strong>, <span class="math inline">\(x\)</span>为<span class="math inline">\(\boldsymbol{A}\)</span><strong>相对于</strong><span class="math inline">\(\boldsymbol{B}\)</span>的属于广义特征值<span class="math inline">\(\lambda\)</span>的<strong>特征向量</strong>.</p><p>当<span class="math inline">\(\boldsymbol{B} = \boldsymbol{I}\)</span>(单位矩阵) 时, 广义特征值退化为标准特征值问题.</p><h3 id="广义瑞利商">广义瑞利商</h3><blockquote><p>其实准确来说是在厄密矩阵下的, 我们仅考虑实数域, 那么就退化为<strong>对称矩阵</strong>.</p></blockquote><p>设<span class="math inline">\(\boldsymbol{A}\)</span>, <span class="math inline">\(\boldsymbol{B}\)</span>为<span class="math inline">\(n\)</span>阶对称矩阵, 且<span class="math inline">\(\boldsymbol{B}\)</span>正定, 称<span class="math inline">\(R(\boldsymbol{x}) = \frac{\boldsymbol{x}^TA\boldsymbol{x}}{\boldsymbol{x}^TB\boldsymbol{x}}(\boldsymbol{x}\neq \boldsymbol{0})\)</span>为<span class="math inline">\(\boldsymbol{A}\)</span><strong>相对于</strong><span class="math inline">\(\boldsymbol{B}\)</span>的<strong>广义瑞利商</strong>.</p><p>当<span class="math inline">\(\boldsymbol{B} = \boldsymbol{I}\)</span>(单位矩阵) 时, 广义瑞利商退化为瑞利商.</p><h4 id="广义瑞利商性质">广义瑞利商性质</h4><p>知道了广义瑞利商的形式, 那么我们可以直接应用它的性质:</p><p>设<span class="math inline">\(\lambda_i, \boldsymbol{x}_i(i = 1,2,3,\dots,n)\)</span>为<span class="math inline">\(\boldsymbol{A}\)</span>相对于<span class="math inline">\(\boldsymbol{B}\)</span>的广义特征值和特征向量, 且<span class="math inline">\(\lambda_1\leq\lambda_2\leq\dots\leq\lambda_n\)</span>. 那么就有:</p><p><span class="math display">\[\min_{\boldsymbol{x}\neq\boldsymbol{0}}{R(\boldsymbol{x})} = \frac{\boldsymbol{x}^TA\boldsymbol{x}}{\boldsymbol{x}^TB\boldsymbol{x}} = \lambda_1, \boldsymbol{x}^* = \boldsymbol{x}_1; \\\max_{\boldsymbol{x}\neq\boldsymbol{0}}{R(\boldsymbol{x})} = \frac{\boldsymbol{x}^TA\boldsymbol{x}}{\boldsymbol{x}^TB\boldsymbol{x}} = \lambda_n, \boldsymbol{x}^* = \boldsymbol{x}_n;\]</span></p><blockquote><p>更一般来说, 就是前<span class="math inline">\(k\)</span>个大的广义瑞利商对应于其前k个大的广义特征值.</p></blockquote><p>证明的话就可以使用下面的<strong>拉格朗日乘子法</strong>: 当固定<span class="math inline">\(\boldsymbol{x}^TB\boldsymbol{x} = 1\)</span>时, 使用拉格朗日乘子法可推得<span class="math inline">\(\boldsymbol{A}x = \lambda \boldsymbol{B}x\)</span>这样一个广义特征值的问题, 因此, <span class="math inline">\(\boldsymbol{x}\)</span>的所有可能的解即为<span class="math inline">\(\boldsymbol{x}_i(i=1,2,\dots,n)\)</span>这<span class="math inline">\(n\)</span>个广义特征向量, 将其带入<span class="math inline">\(R(\boldsymbol{x})\)</span>就可以得到结论.</p><blockquote><p>固定<span class="math inline">\(\boldsymbol{x}^TB\boldsymbol{x} = 1\)</span>并不关心其值, 而需要的是比值, 这里做的是一般性假设, 也可以令分子为1, 但是令分母为1可以使得更加简化, 不必纠结.</p></blockquote><p>之前在线性判别分析中使用的<a href="https://gipbear.github.io/2022/01/14/机器学习西瓜书——第03章线性模型/#损失函数策略">损失函数</a>中<span class="math inline">\(\max{J}\)</span>的形式就是广义瑞利商. 西瓜书后续还有的多分类问题其实就可以根据广义瑞利商的性质来说明.</p><h2 id="sigmoid函数">Sigmoid函数</h2><p>对于阶跃函数, 具有不光滑不连续的数学性质, 对模型不友好, 所以经常使Sigmoid函数『像S型的函数』来代替. 多使用于神经网络, 在逻辑回归中也有使用.</p><p><span class="math display">\[f(x)=\frac{1}{1+e^{-\lambda x}}\]</span></p><p>其中系数<span class="math inline">\(\lambda\)</span>决定着S函数的<code>压缩程度</code>。该函数的特点是，它是有上、下界，单调增长，连续光滑的，即是连续可微的。它可使同一网络既能处理小信号，也能处理大信号，因为该函数中区的<code>高增益</code>部分解决了小信号需要高放大倍数的问题；而两侧的<code>低增益</code>区正好适于处理大的净输入信号。这正像生物神经元在输入电平范围很大的情况下也能正常工作一样。</p><h3 id="sigmoid性质">Sigmoid性质</h3><p>Sigmoid还有一个很好的性质:</p><p><span class="math display">\[f&#39;(x) = \lambda f(x)(1-f(x))\]</span></p><p>当前<span class="math inline">\(\lambda = 1\)</span>时, 则有</p><p><span class="math display">\[f&#39;(x) = f(x)(1-f(x))\]</span></p><h2 id="优化问题">优化问题</h2><h3 id="拉格朗日乘子法">拉格朗日乘子法</h3><p>拉格朗日乘数法在考研数学中其实做过题目, 还是比较简单的套路, 这里只不过是扩充到了向量形式.</p><p>对于仅含等式约束的优化问题:</p><p><span class="math display">\[\begin{aligned}\min_{\boldsymbol{x}} \quad &amp;{f(\boldsymbol{x})} \\s.t. \quad &amp;h_i(\boldsymbol{x} = 0) \quad i=1,2,\dots,n\end{aligned}\]</span></p><p>其中自变量<span class="math inline">\(\boldsymbol{x}\in\mathbb{R}^n\)</span>, <span class="math inline">\(f(\boldsymbol{x})\)</span>和<span class="math inline">\(h(\boldsymbol{x}_i)\)</span>均一阶连续可偏导. 那么就可以写成拉格朗日函数:</p><p><span class="math display">\[L(\boldsymbol{x}, \boldsymbol{\lambda}) = f(\boldsymbol{x}) + \sum^n_{i=1}{\lambda_ih_i(\boldsymbol{x})}\]</span></p><p>其中的<span class="math inline">\(\boldsymbol{\lambda}=(\lambda_1, \lambda_2, \dots, \lambda_n)^T\)</span>为拉格朗日乘子.</p><p>对其求偏导, 并令为0, 再搭配约束条件<span class="math inline">\(h_i(\boldsymbol{x})=0\)</span>, 可以解出<span class="math inline">\(\boldsymbol{x}\)</span>为上述优化问题的所有可能的<strong>极值点</strong>.</p><p>这就是拉格朗日乘子法, 用来求<strong>仅含等式约束</strong>的优化问题.</p><h3 id="梯度下降法">梯度下降法</h3><p>梯度下降法(gradient descent)是一种常用的一阶(first-order)优化方法, 求解<strong>无约束</strong>优化问题最简单最经典的方法之一.</p><p>考虑无约束优化问题<span class="math inline">\(\min\limits_{\boldsymbol{x}} f(\boldsymbol{x})\)</span>, 其中<span class="math inline">\(f(\boldsymbol{x})\)</span>连续可微, 那么若能构造一个序列<span class="math inline">\(\boldsymbol{x}^0,\boldsymbol{x}^1,\dots\)</span>使得</p><p><span class="math display">\[f(\boldsymbol{x}^t+1) &lt; f(\boldsymbol{x}^t), \quad t = 0,1,2...\]</span></p><p>那么通过不断执行该过程就可以收敛到<strong>局部极小</strong>点.</p><p>根据泰勒展开式有:</p><p><span class="math display">\[f(\boldsymbol{x}+\Delta\boldsymbol{x}) \approxeq f(\boldsymbol{x}) + \Delta \boldsymbol{x}^T\nabla f(\boldsymbol{x})\]</span></p><p>欲使得<span class="math inline">\(f(\boldsymbol{x}+\Delta\boldsymbol{x}) &lt; f(\boldsymbol{x})\)</span>, 则可以选择<span class="math inline">\(\Delta\boldsymbol{x} = -\gamma\nabla f(\boldsymbol{x})\)</span>. 其中步长<span class="math inline">\(\gamma\)</span>是一个小常数.</p><p>每步的步长可以不同, 选取合适的步长来确保使得梯度下降收敛到局部极小值, 太大的步长容易产生<strong>振荡</strong>, 太小的步长则收敛速度<strong>较慢</strong>, 所以需要选取合适的步长, 常设置为<code>0.1</code>. 特别地, 若f(x)满足<strong>L-lipschitz条件</strong>, 那么将步长设置为<span class="math inline">\(\frac{1}{2L}\)</span>就可以确保收敛到局部最小值.</p><blockquote><p>L-lipschitz条件是指, 对任意<span class="math inline">\(\boldsymbol{x}\)</span>, 存在常数<span class="math inline">\(L\)</span>, 使得<span class="math inline">\(\|\nabla f(\boldsymbol{x})\|\leq L\)</span>. 这个在毕设中使用过, 效果还是不错的!</p></blockquote><p>以上所说的都是局部极小点, 因为我们可能陷入一个"低谷"无法下降, 所以当目标函数为<strong>凸函数</strong>时, 我们就可以收敛到<strong>全局最优</strong>解了.</p><blockquote><p>二阶(以后接触再详细表述): 当目标函数<span class="math inline">\(f(\boldsymbol{x})\)</span>二阶连续可导时, 使用二阶泰勒展开式得到牛顿法(Newton's method), 迭代轮数更少, 但使用复杂的海森矩阵求逆运算, 计算复杂度高, 高维问题几乎不可行, 除非找到近似逆矩阵来代替, 这就是拟牛顿法(quasi-Newton method).</p></blockquote><h2 id="参考资料">参考资料</h2><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p>海绵彭帆.理解线性可分和线性不可分与机器学习什么叫线性模型[EB/OL].https://blog.csdn.net/qq_45079973/article/details/104051441, 2020.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2" role="doc-endnote"><p>周志华.机器学习[M].北京: 清华大学出版社, 2016: 53-54.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3" role="doc-endnote"><p>二次元的Datawhale.【吃瓜教程】《机器学习公式详解》（南瓜书）与西瓜书公式推导直播合集 第3章-二分类线性判别分析[EB/OL].https://www.bilibili.com/video/BV1Mh411e7VU?p=5, 2021.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是关于一些西瓜书学习过程中的一些数学理论的汇总.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://gipbear.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="ML理论" scheme="https://gipbear.github.io/tags/ML%E7%90%86%E8%AE%BA/"/>
    
    <category term="西瓜书" scheme="https://gipbear.github.io/tags/%E8%A5%BF%E7%93%9C%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>机器学习西瓜书——第03章线性模型</title>
    <link href="https://gipbear.github.io/2022/01/14/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E2%80%94%E2%80%94%E7%AC%AC03%E7%AB%A0%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/"/>
    <id>https://gipbear.github.io/2022/01/14/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E2%80%94%E2%80%94%E7%AC%AC03%E7%AB%A0%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/</id>
    <published>2022-01-14T10:35:28.000Z</published>
    <updated>2022-01-27T15:12:23.896Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是关于周志华老师编写的机器学习书籍『西瓜书』的第三章线性模型.</p><p>主要的内容有: 线性回归的基本形式、最小二乘法、广义线性回归、对数几率回归（逻辑回归）、最大似然估计、线性判别分析、广义瑞利商、拉格朗日乘子法等.</p></blockquote><span id="more"></span><h2 id="基本形式">3.1 基本形式</h2><p>线性模型(linear model)是一个通过属性的线性组合来进行预测的函数, 形如:</p><p><span class="math display">\[f(x) = w_{1}x_{1} + x_{2}w_{2} + \dots + w_{d}x_{d} + b\]</span></p><p>其中<span class="math inline">\(x_i\)</span>表示第<span class="math inline">\(i\)</span>个属性值.</p><p>容易发现, 每个<span class="math inline">\(w_i\)</span>都表示了属性的权重, 这使得建立的模型有很好的<strong>可解释性</strong>(comprehensibility).</p><p>一般可以写成<strong>向量</strong>形式:</p><p><span class="math display">\[f(x) = \boldsymbol{w}^{T}\boldsymbol{x} + b\]</span></p><p>那么我们的目的就是学习得到<span class="math inline">\(\boldsymbol{w}\)</span>和<span class="math inline">\(b\)</span>来确定模型.</p><h2 id="线性回归">3.2 线性回归</h2><p>线性回归是来学习一个线性模型, 来预测<strong>连续值</strong>. 使得预测的连续值<span class="math inline">\(f(x_i)\)</span>尽可能是与真实值<span class="math inline">\(y_i\)</span>接近, 即, 使得<span class="math inline">\(f(x_i) \approxeq y_{i}\)</span>.</p><h3 id="最小二乘法">最小二乘法</h3><p>那么我们如何来衡量<span class="math inline">\(f(x_i)\)</span>与<span class="math inline">\(y_i\)</span>之间的差距呢, 这时候可以上文提过的<a href="https://gipbear.github.io/2022/01/11/机器学习西瓜书——第02章模型评估和选择/#性能度量">均方误差(MSE)</a>来衡量<span class="math inline">\(f(x_i)\)</span>与<span class="math inline">\(y_i\)</span>之间的差距. 并使其最小化, 就可以得到我们先想要的<span class="math inline">\(\boldsymbol{w}\)</span>和<span class="math inline">\(b\)</span>:</p><p><span class="math display">\[\begin{aligned}(w^*, b^*)&amp;= \argmin_{(\boldsymbol{w}, b)}{\sum^m_{i=1}{(f(x_i)-y_i)^2}} \\&amp;= \argmin_{(\boldsymbol{w}, b)}{\sum^m_{i=1}{(y_i-wx_i-b)^2}}\end{aligned}\]</span></p><blockquote><p>这就是<strong>最小二乘法</strong>(least square method): 使用均方误差这个具有几何意义的<strong>欧氏距离</strong>来度量差距.</p></blockquote><p>OK, 那么我们下一步就是如何求解<span class="math inline">\(E_{(w,b)}= {\sum^m_{i=1}{(y_i-wx_i-b)^2}}\)</span>最小值了, 这一步叫做最小二乘的<strong>参数估计</strong>(parameter estimate), 对<span class="math inline">\(\boldsymbol{w}\)</span>和<span class="math inline">\(b\)</span>和b分别求偏导, 并令为零可以得到<span class="math inline">\(\boldsymbol{w}\)</span>和<span class="math inline">\(b\)</span>的最优解:</p><p><span class="math display">\[w = \frac{\sum\limits^m_{i=1}{y_i(x_i-\bar{x})}}{\sum\limits^m_{i=1}{x_i^2}-\frac{1}{m}(\sum\limits^m_{i=1}{x_i})^2}\]</span></p><p><span class="math display">\[b = \frac{1}{m}\sum^m_{i=1}{(y_i-wx_i)}\]</span></p><h3 id="矩阵形式">矩阵形式</h3><p>当我们将数据扩展为矩阵形式, 把<span class="math inline">\(\boldsymbol{w}\)</span>和<span class="math inline">\(b\)</span>写入向量形式<span class="math inline">\(\boldsymbol{w} = (\boldsymbol{w}, b)\)</span>, 相应地, 把数据集<span class="math inline">\(D\)</span>表示为一个<span class="math inline">\(m*(d+1)\)</span>大小的矩阵<span class="math inline">\(\boldsymbol{X}\)</span>, 其中每一行代表一个实例，每行前d个元素对应实例中的d个属性, 最后一个元素恒为1. <span class="math display">\[\boldsymbol{X} =\begin{pmatrix}x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1d} &amp; 1 \\x_{21} &amp; x_{22} &amp; \cdots &amp; x_{2d} &amp; 1 \\\vdots &amp; \vdots &amp;  &amp; \vdots &amp; \vdots \\x_{m1} &amp; x_{m2} &amp; \cdots &amp; x_{md} &amp; 1 \\\end{pmatrix} =\begin{pmatrix}\boldsymbol{x_1}^T &amp; 1 \\\boldsymbol{x_2}^T &amp; 1 \\\vdots &amp; \vdots \\\boldsymbol{x_m}^T &amp; 1 \\\end{pmatrix}\]</span></p><p>再将输入也写成向量形式</p><p><span class="math display">\[\boldsymbol{y} = (y_1, y_2, \cdots, y_m)\]</span></p><p>根据均方差误差最小化原则有:</p><p><span class="math display">\[\boldsymbol{w}^\ast = arg \min_w(\boldsymbol{y}-\boldsymbol{X}\boldsymbol{w})^T(\boldsymbol{y}-\boldsymbol{X}\boldsymbol{w})\]</span></p><p>令<span class="math inline">\(\boldsymbol{E_w} = (\boldsymbol{y}-\boldsymbol{X}\boldsymbol{w})^T(\boldsymbol{y}-\boldsymbol{X}\boldsymbol{w})\)</span>, 对<span class="math inline">\(\boldsymbol{w}\)</span>求导得到</p><p><span class="math display">\[\frac{\partial\boldsymbol{E_w}}{\partial\boldsymbol{w}} = 2\boldsymbol{X}^{T}(\boldsymbol{X}\boldsymbol{w}-\boldsymbol{y})\]</span></p><p>令其为零可得到<span class="math inline">\(\boldsymbol{W}\)</span>的最优解的闭式解。</p><p>以上是当矩阵<span class="math inline">\(X^TX\)</span><strong>满秩(可逆)</strong>时进行的计算, 而实际中, 很多的数据矩阵是<strong>非满秩</strong>的, 则有可能会解出多个解, 那么选择解由学习算法的归纳偏好决定, 常见做法是引入<strong>正则化</strong>.</p><h3 id="广义线性回归">广义线性回归</h3><p>以上我们针对的是一个简单线性回归的模型, 显然预测得到的标记一定是一个线性的结果.</p><blockquote><p>此时我们实验中获得了一组数据, 通过观察是符合<strong>指数</strong>函数形式的, 很明显是一个非线性的标记序列, 那这时是否可以使用线性回归呢?</p></blockquote><p>答案是可以的.</p><p>我们对标记<span class="math inline">\(y\)</span>取<code>ln函数</code>, 这时就会发现:</p><p><span class="math display">\[\ln{y} = \boldsymbol{w}^{T}\boldsymbol{x} + b\]</span></p><p>这就是<strong>对数线性回归</strong>, 在形式上我们可以使用线性回归进行表示, 但本质上却实现了非线性回归. 发生这时神奇变化的东西就是<code>ln</code>这个<strong>单调可微函数</strong>.</p><p>由此推到<strong>广义线性模型</strong>(generalized linear model), 使用单调可微函数<span class="math inline">\(g(\cdot)\)</span>来将预测值和实际值联系起来.</p><p><span class="math display">\[y = g^{-1}(\boldsymbol{w}^{T}\boldsymbol{x} + b)\]</span></p><h2 id="对数几率回归">3.3 对数几率回归</h2><p><strong>对数几率回归</strong>也就是我们之前经常听说的<strong>逻辑回归</strong>. 但是逻辑(logistic)其实并不合适, 而对数几率(log odds, logit)才是这个模型的本质, 下面详细介绍.</p><p>我们在上面所提到的广义线性回归中, 使用一个特定的函数来代替单调可微函数<span class="math inline">\(g^{-1}(\cdot)\)</span>——<strong>sigmoid函数</strong>.</p><p><span class="math display">\[y = \frac{1}{1+e^{-z}}\]</span></p><img src="/2022/01/14/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E2%80%94%E2%80%94%E7%AC%AC03%E7%AB%A0%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/%E5%8D%95%E4%BD%8D%E9%98%B6%E8%B7%83%E5%87%BD%E6%95%B0%E4%B8%8E%E5%AF%B9%E6%95%B0%E5%87%A0%E7%8E%87%E5%87%BD%E6%95%B0.png" class="" title="单位阶跃函数与对数几率函数.png"><p>这是一个形如s型曲线的图像, 通过设置不同的<strong>阈值</strong>, 使得取值被划分为0或1, 所以这也是为什么虽然叫做回归函数, 却经常被用作<strong>分类</strong>.</p><h3 id="模型的表示模型">模型的表示(模型)</h3><p>将线性模型带入sigmoid函数中, 可以得到:</p><p><span class="math display">\[y = \frac{1}{1+e^{-(\boldsymbol{w}^{T}\boldsymbol{x} + b)}}\]</span></p><p>通过变化得到:</p><p><span class="math display">\[\ln{\frac{y}{1-y}} = \boldsymbol{w}^{T}\boldsymbol{x} + b\]</span></p><p>此时很关键的一步:</p><ul><li>将<span class="math inline">\(y\)</span>视作样本<span class="math inline">\(\boldsymbol{x}\)</span>为正例的可能性, 用后验概率表示为<span class="math inline">\(p(y=1|\boldsymbol{x})\)</span>;</li><li>将<span class="math inline">\(1-y\)</span>视作样本<span class="math inline">\(\boldsymbol{x}\)</span>为反例的可能性, 用后验概率表示为<span class="math inline">\(p(y=0|\boldsymbol{x})\)</span>.</li></ul><blockquote><p>我们所谓的"几率"就是<span class="math inline">\(\frac{y}{1-y}\)</span>, <strong>反映了x作为正例的相对可能性</strong>. 再取对数, 所以就称为对数几率!</p></blockquote><h3 id="最大似然估计策略">最大似然估计(策略)</h3><p>那么问题回到如何确定模型中的<span class="math inline">\(\boldsymbol{w}\)</span>和<span class="math inline">\(b\)</span>呢? 我们这里使用<strong>最大似然估计</strong>来解释, 同样的还可以使用信息论的角度来解释.</p><p>根据以上的内容, 可以将模型表达写成:</p><p><span class="math display">\[p(y=1|\boldsymbol{x}) = \frac{e^{\boldsymbol{w}^{T}\boldsymbol{x} + b}}{1+e^{\boldsymbol{w}^{T}\boldsymbol{x} + b}}\]</span></p><p><span class="math display">\[p(y=0|\boldsymbol{x}) = \frac{1}{1+e^{\boldsymbol{w}^{T}\boldsymbol{x} + b}}\]</span></p><p>通过极大似然估计法, 并取对数就可以得到:</p><p><span class="math display">\[\begin{aligned}L(\boldsymbol{w}, b) &amp;= \prod^m_{i=1}{p(y_i|\boldsymbol{x}_i;w,b)} \\l(\boldsymbol{w}, b) &amp;= \sum^m_{i=1}{\ln{[y_ip_1(\hat{\boldsymbol{x}}_i;\boldsymbol{w}, b) + (1-y_i)p_0(\hat{\boldsymbol{x}}_i;\boldsymbol{w}, b)]}}\end{aligned}\]</span></p><p>其中<span class="math inline">\(p_1\)</span>是<span class="math inline">\(p(y=1|\boldsymbol{x};\boldsymbol{w}, b)\)</span>, <span class="math inline">\(p_0\)</span>是<span class="math inline">\(p(y=0|\boldsymbol{x};\boldsymbol{w}, b)\)</span>.</p><p>为了便于讨论, 令<span class="math inline">\(\beta=(\boldsymbol{x};b), \hat{\boldsymbol{x}}=(\boldsymbol{x};1)\)</span>, 使得<span class="math inline">\(\boldsymbol{w}^{T}\boldsymbol{x} + b\)</span>可以表示为<span class="math inline">\(\beta^T\boldsymbol{x}\)</span>. 再分别令<span class="math inline">\(y_i\)</span>为0或1:</p><p><span class="math display">\[l(\beta) =\begin{cases}\sum\limits^m_{i=1}{- \ln{(1+e^{\beta^T\boldsymbol{x}_i})}}, \qquad &amp;y_i = 0 \\\sum\limits^m_{i=1}{\beta^T\boldsymbol{x}_i - \ln{(1+e^{\beta^T\boldsymbol{x}_i})}}, \qquad &amp;y_i = 1\end{cases}\]</span></p><p>综合可得如下式子, 并且将其取负数得最小化:</p><p><span class="math display">\[l(\beta) = -\sum^m_{i=1}{[y_i\beta^T\boldsymbol{x}_i - \ln{(1+e^{\beta^T\boldsymbol{x}_i})}]}\]</span></p><p>这就是关于<span class="math inline">\(\beta\)</span>的高阶可导凸函数, 使用梯度下降等优化理论方法进行求解即可.</p><h3 id="模型的优点">模型的优点</h3><ol type="1"><li>该模型直接对分类的可能性进行建模, 也没有要求数据分布, 避免假设数据分布带来的不确定性问题;</li><li>而且得到了近似概率预测, 对许多需要利用概率辅助决策的任务有很大的帮助;</li><li>求解的目标函数是任意阶可导的凸函数, 有很好的数学性质, 许多值优化算法都可以用来求解最优解.</li></ol><h2 id="线性判别分析">3.4 线性判别分析</h2><p>线性判别分析(linear Discrimination Analysis, LDA)是一种典型的二分类方法.</p><p>主要思想是: 在给定的训练样本集中, 试图寻找一条直线, 并让所有的样本点投影到该直线上, 其中<strong>同类样本点的投影之间尽可能的接近, 异类样本点的投影之间尽可能远离</strong>.当需要对新样本进行分类时, 同样将新样本投影到该直线上, 根据其位置判断属于哪一类.</p><img src="/2022/01/14/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E2%80%94%E2%80%94%E7%AC%AC03%E7%AB%A0%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/LDA%E7%A4%BA%E6%84%8F%E5%9B%BE.png" class="" title="LDA示意图.png"><h3 id="针对二分类问题模型">针对二分类问题(模型)</h3><p>接下来, 首先对一些符号进行说明. 数据集: <span class="math inline">\(D=\{(\boldsymbol{x}_i,y_i)\}^m_{i=1}\)</span>, 其中标记取值为0或1: <span class="math inline">\(y_i=\{0,1\}\)</span>, 第<span class="math inline">\(i=\{0, 1\}\)</span>类示例的集合为<span class="math inline">\(X_i\)</span>, 均值向量为<span class="math inline">\(\mu_i\)</span>, 协方差矩阵为<span class="math inline">\(\Sigma_i\)</span>.</p><blockquote><p>协方差矩阵<span class="math inline">\(\Sigma\)</span>(读<code>Sigma</code>)与求和符号<span class="math inline">\(\sum\)</span>(读<code>sum</code>)还是不一样的,注意通过上下文进行区分.</p><p>协方差矩阵表示的是各个<strong>属性</strong>之间的相关性, 为0表示不相关. 因此协方差矩阵的大小与属性的个数有关, 而与样本的个数无关.</p></blockquote><p>根据以上对符号的定义,</p><ol type="1"><li>将样本点投影到直线上得到: <span class="math inline">\(\boldsymbol{w}^T\mu_0\)</span> 和 <span class="math inline">\(\boldsymbol{w}^T\mu_1\)</span>;</li><li>将所有样本点投影到直线上得到两类样本的协方差为: <span class="math inline">\(\boldsymbol{w}^T\Sigma_0\boldsymbol{w}\)</span> 和 <span class="math inline">\(\boldsymbol{w}^T\Sigma_1\boldsymbol{w}\)</span>.</li></ol><p>由于我们的目的是使得两类样本之间的距离尽可能的大, 而样本内的距离尽可能的小, 那么就需要使得<span class="math inline">\(\|\boldsymbol{w}^T\mu_0 - \boldsymbol{w}^T\mu_1\|^2_2\)</span>尽可能的大, 而<span class="math inline">\(\boldsymbol{w}^T\Sigma_0\boldsymbol{w} + \boldsymbol{w}^T\Sigma_1\boldsymbol{w}\)</span>尽可能的小.</p><blockquote><p><span class="math inline">\(\|X\|^2_2这叫做二范数的平方, 表示向量之间的距离, 可以使用向量的内积进行计算\)</span></p></blockquote><p>我们需要注意 :warning: ! 我们的目的是为了求出投影直线的<strong>方向</strong>, 所以<span class="math inline">\(\boldsymbol{w}\)</span>的大小无关紧要, 这也是下面很多步骤中的必要条件.</p><h3 id="损失函数策略">损失函数(策略)</h3><p>同时考虑以上两者, 可以得到我们的最大化目标:</p><p><span class="math display">\[\begin{aligned}\max J &amp;= \frac{\|\boldsymbol{w}^T\mu_0 - \boldsymbol{w}^T\mu_1\|^2_2}{\boldsymbol{w}^T\Sigma_0\boldsymbol{w} + \boldsymbol{w}^T\Sigma_1\boldsymbol{w}} \\&amp;= \frac{\|(\mu_0-\mu_1)^T\boldsymbol{w}\|^2_2}{\boldsymbol{w}^T(\Sigma_0+\Sigma_1)\boldsymbol{w}} \\&amp;= \frac{w^T (\mu_0-\mu_1)(\mu_0-\mu_1)^T \boldsymbol{w}}{\boldsymbol{w}^T(\Sigma_0+\Sigma_1)\boldsymbol{w}}\end{aligned}\]</span></p><p>并定义"类内散度矩阵"(within-class scatter matrix): <span class="math inline">\(\boldsymbol{S}_w = \Sigma_0 + \Sigma_1\)</span>, "类间散度矩阵"(between-class scatter matrix): <span class="math inline">\(\boldsymbol{S}_b = (\mu_0-\mu_1)(\mu_0-\mu_1)^T\)</span>.</p><p>那么上式可以表示为:</p><p><span class="math display">\[\max J = \frac{\boldsymbol{w}^T \boldsymbol{S}_b \boldsymbol{w}}{\boldsymbol{w}^T \boldsymbol{S}_w \boldsymbol{w}}\]</span></p><p>以上这个最大化的目标函数其实就是<span class="math inline">\(\boldsymbol{S}_b\)</span>与<span class="math inline">\(\boldsymbol{S}_w\)</span>的"<a href="https://gipbear.github.io/2022/01/17/机器学习中可能会使用的理论/#广义瑞利商">广义瑞利商</a>".</p><p>并注意到我们需要求解的<span class="math inline">\(\boldsymbol{w}\)</span>只与方向有关, 而与大小无关, 那么不失一般性的, 可以令分母<span class="math inline">\(\boldsymbol{w}^T \boldsymbol{S}_w \boldsymbol{w}=1\)</span>, 由此等价于:</p><p><span class="math display">\[\begin{aligned}  \min_{\boldsymbol{w}}\quad&amp;{-\boldsymbol{w}^T \boldsymbol{S}_b \boldsymbol{w}} \\  s.t. \quad &amp;\boldsymbol{w}^T \boldsymbol{S}_w \boldsymbol{w}=1\end{aligned}\]</span></p><h3 id="拉格朗日乘子法求解">拉格朗日乘子法(求解)</h3><p>关于这种<strong>仅含有等式约束</strong>的问题, 可以使用<a href="https://gipbear.github.io/2022/01/17/机器学习中可能会使用的理论/#拉格朗日乘子法">拉格朗日乘子法</a>进行求解.</p><p>即, 可得:</p><p><span class="math display">\[L(\boldsymbol{w}, \lambda) = -\boldsymbol{w}^T \boldsymbol{S}_b \boldsymbol{w} + \lambda(\boldsymbol{w}^T \boldsymbol{S}_w \boldsymbol{w} - 1)\]</span></p><p>再对<span class="math inline">\(\boldsymbol{w}\)</span>求偏导可得:</p><p><span class="math display">\[\frac{\partial{L(\boldsymbol{w}, \lambda)}}{\partial{\boldsymbol{w}}} = -(\boldsymbol{S}_b+\boldsymbol{S}_b^T)\boldsymbol{w} + \lambda(\boldsymbol{S}_w+\boldsymbol{S}_w^T)\boldsymbol{w}\]</span></p><p>令等式为0可得:</p><p><span class="math display">\[\boldsymbol{S}_b\boldsymbol{w} = \lambda\boldsymbol{S}_w\boldsymbol{w}\]</span></p><p>因为<span class="math inline">\((\mu_0-\mu_1)^T\boldsymbol{w}\)</span>为实数, 所以<span class="math inline">\(\boldsymbol{S}_b\boldsymbol{w} = (\mu_0-\mu_1)(\mu_0-\mu_1)^T\boldsymbol{w}\)</span>的方向恒为<span class="math inline">\((\mu_0-\mu_1)\)</span>, 所以可以解得:</p><p><span class="math display">\[\boldsymbol{w} = \boldsymbol{S}^{-1}_w(\mu_0-\mu_1)\]</span></p><blockquote><p>可以发现, 我们求得的<span class="math inline">\(\boldsymbol{w}\)</span>的值, 就是<span class="math inline">\(\boldsymbol{S}_b\)</span>对应于<span class="math inline">\(\boldsymbol{S}_b\)</span>的广义特征值对应的特征向量</p></blockquote><h3 id="多分类问题">多分类问题</h3><p>而多分类的问题中, 只不过是求矩阵<span class="math inline">\(\boldsymbol{W}\)</span>, 使得<span class="math inline">\(\boldsymbol{S}_b\boldsymbol{W} = \lambda\boldsymbol{S}_w\boldsymbol{W}\)</span>.</p><p>我们将<span class="math inline">\(\boldsymbol{W}\)</span>拆分为多个二分类问题可得: <span class="math inline">\(\boldsymbol{W} = \{\boldsymbol{w}_1, \boldsymbol{w}_1, \dots, \boldsymbol{w}_n\}\)</span>, 结合<a href="https://gipbear.github.io/2022/01/17/机器学习中可能会使用的理论/#广义特征值与广义瑞利商">广义特征值与广义瑞利商的性质</a>可以得到<span class="math inline">\(\boldsymbol{W}\)</span>其实就是<span class="math inline">\(\boldsymbol{S}_b\)</span>相对于<span class="math inline">\(\boldsymbol{S}_w\)</span>最大的非零广义特征值所对应的特征向量组成的矩阵!</p><h2 id="个人收获">个人收获</h2><ol type="1"><li>从单纯的线性模型, 推广到广义的线性模型, 再引出特殊的对数几率回归模型. 从特殊到一般再到特殊的方式, 很好的理清楚了简单线性回归和逻辑回归之间的关系.</li><li>逻辑回归真正的名字应该是对数几率回归, 这对记忆和理解模型都有更好的可解释性.</li><li>线性判别分析法这次终于学明白了! 从"模型-策略-求解"三方面进行学习果然思路清楚了很多.</li><li>公式的推导依旧有难度, 目前处于抛开书想不到怎么推, 但结合西瓜书和南瓜书还是能够看懂推导过程.</li></ol><p>继续加油!</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是关于周志华老师编写的机器学习书籍『西瓜书』的第三章线性模型.&lt;/p&gt;
&lt;p&gt;主要的内容有: 线性回归的基本形式、最小二乘法、广义线性回归、对数几率回归（逻辑回归）、最大似然估计、线性判别分析、广义瑞利商、拉格朗日乘子法等.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://gipbear.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="西瓜书" scheme="https://gipbear.github.io/tags/%E8%A5%BF%E7%93%9C%E4%B9%A6/"/>
    
    <category term="线性模型" scheme="https://gipbear.github.io/tags/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>机器学习西瓜书——第02章模型评估和选择</title>
    <link href="https://gipbear.github.io/2022/01/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E2%80%94%E2%80%94%E7%AC%AC02%E7%AB%A0%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E5%92%8C%E9%80%89%E6%8B%A9/"/>
    <id>https://gipbear.github.io/2022/01/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E2%80%94%E2%80%94%E7%AC%AC02%E7%AB%A0%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E5%92%8C%E9%80%89%E6%8B%A9/</id>
    <published>2022-01-11T11:36:17.000Z</published>
    <updated>2022-01-27T15:12:28.741Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是关于周志华老师编写的机器学习书籍『西瓜书』的第二章模型评估和选择.</p><p>主要的内容有: 经验误差与过拟合、模型的评估方法(留出法/交叉验证/自助法)、性能度量(查准率/查全率/F1/ROC曲线等), 部分内容待更新.</p></blockquote><span id="more"></span><h2 id="经验误差与过拟合">2.1 经验误差与过拟合</h2><h3 id="误差">误差</h3><p><strong>错误率</strong>: 分类错误的样本数 <span class="math inline">\(a\)</span> 占样本总数 <span class="math inline">\(m\)</span> 的比例称为"错误率"(error rate).</p><p><span class="math display">\[error rate = \frac{a}{m}\]</span></p><p>与之相对的是<strong>精度</strong>(accuracy):</p><p><span class="math display">\[accuracy = 1 - \frac{a}{m}\]</span></p><p>学习器在训练集上的误差称为<strong>训练误差</strong>(training error)或<strong>经验误差</strong>(empirical error); 而在新样本上的误差称为<strong>泛化误差</strong>(generalization error).</p><blockquote><p>我们最『想』得到『泛化误差』尽可能的小, 但是我们在训练的时候并不知道新样本, 所以『实际上』能做的是使得『经验误差』尽可能的小.</p></blockquote><h3 id="过拟合">过拟合</h3><p>当我们训练模型学习训练样本的时候, 将训练样本学的"太好", 除了学习到数据集的普遍规律, 还将训练数据集的一些自身特点学习到了, 导致泛化性能下降, 这种现象称为<strong>过拟合</strong>(overfitting); 反之就是<strong>欠拟合</strong>(underfitting), 训练样本的普遍规律也没有学会.</p><blockquote><p>简单来说就是: 只会硬板照抄的学生 和 不好好学习的后进生.</p></blockquote><p>欠拟合是学习的不够好, 一般来说比较好解决, 例如在决策树中扩展分支, 在神经网络中增加训练轮数等.</p><p>但是过拟合却是<strong>不可避免的</strong>, 只能做到缓解和减小其风险. 因为机器学习面临的问题是NP难, 但是有效算法是在有限时间内完成的, 不能完成 <span class="math inline">\(NP=P\)</span> 的证明.</p><p>那么, 实际上有各种算法以及各种参数来训练模型, 如何选择? 这就是模型选择; 如何评估模型训练的好坏呢? 这就模型评估.</p><h2 id="评估方法">2.2 评估方法</h2><p>通过实验, 设置测试组对学习器的泛化误差来对模型进行选择. 需要一个测试集(testing set), 在学习器上得到的测试误差(testing error)与泛化误差近似.</p><blockquote><p>保证测试集中的数据尽可能未在训练集中出现.</p></blockquote><p>那么对于一个包含m个样本数据集D, 既要训练, 又要测试, 那么需要合适的划分方法得到训练集和测试集.</p><h3 id="留出法hold-out">留出法(hold-out)</h3><p>留出法<strong>直接</strong>将数据集<strong>划分</strong>为两个互斥的集合, 一个作为训练集S, 一个作为测试集T.</p><p>需要注意的是: 训练集和测试集的划分要尽可能的保持<strong>数据分布一致</strong>, 避免因为数据划分过程引入额外的偏差, 从而对最终的结果产生影响.</p><blockquote><p>例如将男性的数据集作为训练集, 然后去评估女性的数据集得到的泛化误差, 很明显是不合理的. 应尽量保持男女同比例.</p></blockquote><p>一般划分数据的时候保留类别比例, 通常称为"分层采样"(stratified sampling). 虽然按照比例进行划分比较合适, 但是依旧可能会出现一些问题.</p><blockquote><p>例如购物消费数据降序排序, 划分前70%作为训练集,后30%作为测试集. 虽然此时男女比例可能是等比例划分的, 但是消费能力却是截然不同, 所以这种方式显然还欠缺考虑.</p></blockquote><p>所以在使用留出法的时候, 通常使用<strong>若干次随机抽样</strong>的方式进行划分, 然后对这几次的评估数据<strong>取均值</strong>.</p><p>以上是为了更好使用留出法的一些方法, 但是留出法本身有一个<strong>固有缺陷</strong>: 训练集S较大时, 模型可以训练的更接近数据集D的模型, 但测试集T较小, 导致评估结果不够稳定; 若测试集T大了, 那么训练集S训练出的模型可能和数据集D差别较大, 从而降低了评估结果的保真性(fidelity).</p><p>但是也没有完美的解决方法, 一般划2/3~4/5进行训练, 剩余作为测试.</p><h3 id="交叉验证cross-validation">交叉验证(cross validation)</h3><p>先将数据集划分为k个大小相同的互斥子集, 每个子集尽可能保持数据分布的一致性(分层抽样). 每次使用k-1个子集进行训练, 剩下的一个子集作为测试集. 从而获得k次测试结果并取均值. 所以通常也称为<strong>k-折交叉验证</strong>(k-fold cross validation).</p><p>同样的, 为减小样本划分带来的影响, 通常使用p次随机划分, 然后取这p次k折交叉验证结果的均值.</p><blockquote><p>其中, 若令k=m,那么则会得到<strong>留一法</strong>(Leave-One-Out, LOO), 显然由于划分唯一, 不受随机划分的影响. 实际效果和训练集几乎相似, 但是同样有一个固有缺陷: 数据集较大时, 训练时间开销太大.</p><p>所以: <strong>没有免费的午餐</strong>定理同样适用.</p></blockquote><h3 id="自助法bootstrapping">自助法(bootstrapping)</h3><p>对给定的包含m个样本的数据集D, 进行m次<strong>抽样放回</strong>的过程, 得到数据集D'. 这个过程会使得某些样本可能会出现多次, 而某些样本却不会出现. 简单估计始终不被抽样的概率是<span class="math inline">\((1-\frac{1}{m})^m\)</span>, 取极限得到:</p><p><span class="math display">\[\lim_{m\rightarrow \infin}{(1-\frac{1}{m})^m} \rightarrowtail \frac{1}{e} \approx 0.368\]</span></p><p>将未出现约36.8%的数据作为测试集即可, 那么训练模型的时候使用m个样本作为训练集,测试集依旧有约1/3的数据作为测试.</p><blockquote><p>在数据集较小, 难以有效划分的时候比较有效.</p><p>并能从初始数据集中产生多个不同的训练集, 对于集成学习等方法有很大好处.</p></blockquote><p>但在划分的时候改变了初始数据集的分布, 引入估计偏差, 所以在数据量足够的时候, 留出法和交叉验证更常用.</p><h3 id="调参与最终模型">调参与最终模型</h3><p>大部分的学习算法都需要一些参数进行设定, 参数的配置不同, 学习的模型往往有显著差距, 对参数(parameter)进行设定的过程称为参数调节或调参(parameter tuning).</p><p>参数是在一定范围内进行取值, 并根据一定的步长进行调节. 那么我们最终的参数也只可能在我们划分的<strong>离散值</strong>中, 往往不一定能够达到"最佳", 但这也平衡了开销和性能.</p><p>我们的调参是根据训练集S进行调参的, 最终的模型应该更根据选定的参数在<strong>完整的数据集</strong>中进行测试, 将最终的结果进行提交.</p><blockquote><p>通常将实际中遇到的数据称为测试数据, 而模型评估和选择中使用的数据集称为<strong>验证集</strong>(validation set).</p></blockquote><h2 id="性能度量">2.3 性能度量</h2><p>那么对机器学习训练泛化性能的评估, 就是接下来的性能度量(performance measure). 不同的性能度量得到的评判标准也不同, 所以模型的"好坏"是相对的, 取决于算法和数据, 还取决于模型的任务需求.</p><p>回归任务常用<strong>均方误差</strong>(mean squared error, MSE):</p><p><span class="math display">\[E(f; D) = \frac{1}{m} \sum^m_{i=1}{(f(x_i)-y_i)^2}\]</span></p><p>其中, <span class="math inline">\(f(x_i)\)</span>是模型对样本<span class="math inline">\(x_i\)</span>的预测, <span class="math inline">\(y_i\)</span>是真实标记.</p><h3 id="查准率查全率与f1">查准率、查全率与F1</h3><p>我们关心的问题有时候不仅仅是错误率或精度.</p><blockquote><p>例如我们不关心有多少比例的瓜判断错误, 而更加关心挑出的西瓜中有多少的比例是好瓜.</p></blockquote><p>此时就引入了查准率(precision)和查全率(recall):</p><ul><li><strong>查准率</strong>: 预测为正例中有多少是真的正例;</li><li><strong>查全率</strong>: 实际为正例的有多少被预测为正例.</li></ul><p>对于二分类问题, 可将结果分为: 真正例(true positive)、假正例(false positive)、真反例(true negative)和假反例(false negative). 由此组成<strong>混淆矩阵</strong>(confusion matrix).</p><img src="/2022/01/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E2%80%94%E2%80%94%E7%AC%AC02%E7%AB%A0%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E5%92%8C%E9%80%89%E6%8B%A9/%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5.png" class="" title="混淆矩阵.png"><p><span class="math display">\[查准率P = \frac{TP}{TP+FP}\]</span></p><p><span class="math display">\[查全率R = \frac{TP}{TP+FN}\]</span></p><p>这两个度量往往相互制约, 总是一高一低.</p><p>我们对学习器的预测样例的结果进行排序, 排在前面的样例认为是"最可能"为正例的样本, 按顺序逐个把样本作为正例进行预测, 则每个可计算出当前的查全率和查准率. 以此作为坐标轴可以绘制"P-R曲线".</p><img src="/2022/01/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E2%80%94%E2%80%94%E7%AC%AC02%E7%AB%A0%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E5%92%8C%E9%80%89%E6%8B%A9/P-R%E5%9B%BE.png" class="" title="P-R图.png"><p>根据曲线, 我们可以发现A和B曲线<strong>包含</strong>C曲线, 那么可以认为训练得到曲线C的模型相对较差; 而A和B曲线发生了<strong>交叉</strong>, 那么性能的优劣则不好判断.</p><p>引入"平衡点"(Break-Event Point, BEP)的概念, 在『查全率=查准率』处取得平衡点, 那么可以认为 A 优于 B.(挺草率的说)</p><p>更常用的是F1常量:</p><p><span class="math display">\[F1 = 2 \times \frac{1}{\frac{1}{P} + \frac{1}{R}} = \frac{2 \times P \times R}{P + R}\]</span></p><p>在特定场景, 模型对于查全率和查准率的要求不同, 所以会赋予不同的权重来进行调整, 使得更符合模型的需求.</p><p><span class="math display">\[F_\beta = \frac{(1+\beta^2) \times P \times R}{(\beta^2 \times P) + R}\]</span></p><h4 id="多分类">多分类</h4><p>以上是针对二分类问题提出了混淆矩阵, 那么对于多分类问题呢?</p><p>一种方法是两两形成混淆矩阵, 先计算得到各自的查全率和查准率, <strong>再将取均值</strong>, 得到"宏查准率"(macro-P)和"宏查全率"(macro-R), 再计算"宏F1"(macro-F1).</p><p>还有一种方法是各个混淆矩阵元素<strong>先取均值</strong>, 得到TP、FP、TN、FN的均值, 然后再基于这些均值计算得到"微查准率"(micro-P)和"微查全率"(micro-R), 再计算"微F1"(micro-F1).</p><h3 id="roc与auc">ROC与AUC</h3><p>很多的学习器是为了产生一个预测实值或概率预测, 然后将该概率预测与一个分类<strong>阈值</strong>(threshold)进行比较, 对测试样本进行排序, 最有可能的正例排在前面, 最不可能的正例排在最后面, 通过阈值将样本分为两部分.</p><p>一般情况下, 我们根据任务需求来采用不同的截断点. 更重视"查准率", 则选择排序靠前的位置进行截断, 更重视"查全率", 则选择排序靠后的位置进行截断. 那么对<strong>排序质量</strong>的好坏直接影响了学习器在不同任务下的<strong>泛化性能</strong>的好坏. ROC曲线就是来研究学习器泛化性能的有力工具.</p><p>『ROC曲线』原理与『P-R曲线』类似, 对学习器的预测样例的结果进行排序, 排在前面的样例认为是"最可能"为正例的样本, 按顺序逐个把样本作为正例进行预测, 则每个可计算出当前的<strong>真正例率</strong>(True Positive Rate, TPR)和<strong>假正例率</strong>(False Positive Rate, FPR):</p><ul><li>真正例率: 实际正例预测为正例的数量占所有实际正例的比例;</li><li>假正例率: 实际反例预测为正例的数量占所有实际反例的比例.</li></ul><p><span class="math display">\[TPR = \frac{TP}{TP + FN}\]</span></p><p><span class="math display">\[FPR = \frac{FP}{TN + FP}\]</span></p><img src="/2022/01/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E2%80%94%E2%80%94%E7%AC%AC02%E7%AB%A0%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E5%92%8C%E9%80%89%E6%8B%A9/ROC%E6%9B%B2%E7%BA%BF%E4%B8%8EAUC.png" class="" title="ROC曲线与AUC.png"><p>如果要比较不同学习器的优劣, 就看ROC曲面下的<strong>面积AUC</strong>(Area Under ROC Curve).</p><h3 id="代价敏感错误率与代价曲线">代价敏感错误率与代价曲线</h3><p>// todo</p><h2 id="比较检验">2.4 比较检验</h2><p>假设检验</p><p>交叉验证 t 检验</p><p>McNemar 检验</p><p>Friedman 检验与 Nemenyi 后续检验</p><h2 id="偏差与方差">2.5 偏差与方差</h2><h2 id="个人收获">个人收获</h2><p>这一章主要是在讲如何对数据集进行划分, 如何评估模型的性能, 包括我还没完全捋清楚的假设检验部分, 都是在对模型性能的好坏进行评价, 对模型的可行性, 真实性进行分析.</p><p>这些东西正是之后支撑我们来判断一个模型是好是坏, 是否可行的依据. 目前只是大概的了解了概念, 到了实际应用的时候还是要回过头来回顾前两章.</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是关于周志华老师编写的机器学习书籍『西瓜书』的第二章模型评估和选择.&lt;/p&gt;
&lt;p&gt;主要的内容有: 经验误差与过拟合、模型的评估方法(留出法/交叉验证/自助法)、性能度量(查准率/查全率/F1/ROC曲线等), 部分内容待更新.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://gipbear.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="西瓜书" scheme="https://gipbear.github.io/tags/%E8%A5%BF%E7%93%9C%E4%B9%A6/"/>
    
    <category term="模型评估" scheme="https://gipbear.github.io/tags/%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0/"/>
    
  </entry>
  
  <entry>
    <title>单链表解题技巧4——反转链表</title>
    <link href="https://gipbear.github.io/2022/01/11/%E5%8D%95%E9%93%BE%E8%A1%A8%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A74%E2%80%94%E2%80%94%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>https://gipbear.github.io/2022/01/11/%E5%8D%95%E9%93%BE%E8%A1%A8%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A74%E2%80%94%E2%80%94%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
    <published>2022-01-11T10:44:35.000Z</published>
    <updated>2022-01-11T11:20:17.403Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是关于单链表的反转问题, 存在反转全部链表和部分区间链表的情况.</p><p>涉及 leetcode 的<a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a>和<a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II</a>.</p></blockquote><span id="more"></span><h2 id="反转链表">反转链表</h2><h3 id="题目1">题目1</h3><p>首先来看题目<a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a>: 给你单链表的头节点 head , 请你反转链表, 并返回反转后的链表.</p><p>示例1:</p><blockquote><p>输入: head = [1,2,3,4,5]</p><p>输出: [5,4,3,2,1]</p></blockquote><p>示例2:</p><blockquote><p>输入: head = []</p><p>输出: []</p></blockquote><h3 id="理解一下1">理解一下1</h3><p>反转很好理解, 链表本来是指向其<strong>唯一后继</strong>, 现在只不过是去指向其<strong>唯一前趋</strong>.</p><p>基本的思路是:</p><ol type="1"><li>需要三个指针, 一个指向前趋, 一个指向当前结点, 一个指向后继;</li><li>然后循环迭代, 变换指针的移动即可.</li></ol><p>以上的是最基本的迭代思维, 那么尝试使用递归的思想来解决呢?</p><ol type="1"><li>首先递归反转某个结点后的所有链表;</li><li>直至base case: 空链或唯一结点;</li><li>然后将反转后的链表与该结点连接上即可.</li></ol><h3 id="解题1">解题1</h3><p>首先是迭代的算法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode *h = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode * p = head, *q = head;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">nullptr</span> &amp;&amp; p-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        p-&gt;next = h;</span><br><span class="line">        h = p;</span><br><span class="line">        p = q;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = h;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是递归的解法, 最后三行不好理解的话画个图就知道了:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用last指向翻转head后的链表</span></span><br><span class="line">    ListNode *last = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">    <span class="comment">// 这里需要画个图才能解释</span></span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    <span class="comment">// 最后head去指向空</span></span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反转部分链表">反转部分链表</h2><h3 id="题目2">题目2</h3><p>首先来看题目<a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II</a>: 给你单链表的头指针 head 和两个整数 left 和 right, 其中 left &lt;= right . 请你反转从位置 left 到位置 right 的链表节点, 返回<strong>反转后的链表</strong>.</p><p>示例1:</p><blockquote><p>输入: head = [1,2,3,4,5], left = 2, right = 4</p><p>输出: [1,4,3,2,5]</p></blockquote><p>示例2:</p><blockquote><p>输入: head = [5], left = 1, right = 1</p><p>输出: [5]</p></blockquote><h3 id="理解一下2">理解一下2</h3><p>与上一题不同的是, 这题需要将链表的部分区间进行翻转, 这就需要将链表分为三个部分处理: 前部分-翻转部分-后部分, 这会显得比较麻烦.</p><p>那么我们考虑一个问题: <strong>反转链表前N个结点</strong>, 那么链表就只需要分为: 翻转部分-后部分, 相比而言简单一些了.</p><p>反转前N个结点的基本的思路是:</p><ol type="1"><li>通过N设置对反转<strong>结束</strong>的判断, 同时需要一个指针来表示<strong>后继</strong>;</li><li>与第一题一样翻转;</li></ol><p>那么对于我们的区间就很简单了:</p><ol type="1"><li>不断递归或迭代后移至需要反转的结点;</li><li>然后不就是<strong>反转链表前N个结点</strong>的问题嘛!</li></ol><h3 id="解题2">解题2</h3><p>由于结点和指针相对较多, 要仔细判断清楚.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverseTopN</span>(head, right);</span><br><span class="line">    head-&gt;next = <span class="built_in">reverseBetween</span>(head-&gt;next, left<span class="number">-1</span>, right<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ListNode * rest;</span><br><span class="line"><span class="function">ListNode* <span class="title">reverseTopN</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        rest = head-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode * last = <span class="built_in">reverseTopN</span>(head-&gt;next, n<span class="number">-1</span>);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = rest;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="个人收获">个人收获</h2><p>在这里反转链表的问题上, 迭代和递归的时间复杂度都是O(n), 所以选择使用哪个都差不多, 但是递归的空间复杂度却是O(n), 所以实际应用的时候还是迭代较好.</p><p>不过这里让我对递归有了更好的认知, 写递归函数, 就是要<strong>相信这个递归函数可以做到它该做的</strong>, 然后我们将<code>base case</code>和其他需要准备的做好就可以了, 剩下的就相信它!</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是关于单链表的反转问题, 存在反转全部链表和部分区间链表的情况.&lt;/p&gt;
&lt;p&gt;涉及 leetcode 的&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-linked-list/&quot;&gt;206. 反转链表&lt;/a&gt;和&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-linked-list-ii/&quot;&gt;92. 反转链表 II&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据结构算法" scheme="https://gipbear.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="c++" scheme="https://gipbear.github.io/tags/c/"/>
    
    <category term="单链表" scheme="https://gipbear.github.io/tags/%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    
    <category term="leetcode题解" scheme="https://gipbear.github.io/tags/leetcode%E9%A2%98%E8%A7%A3/"/>
    
    <category term="迭代和递归" scheme="https://gipbear.github.io/tags/%E8%BF%AD%E4%BB%A3%E5%92%8C%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>机器学习西瓜书——第01章绪论</title>
    <link href="https://gipbear.github.io/2022/01/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E2%80%94%E2%80%94%E7%AC%AC01%E7%AB%A0%E7%BB%AA%E8%AE%BA/"/>
    <id>https://gipbear.github.io/2022/01/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E2%80%94%E2%80%94%E7%AC%AC01%E7%AB%A0%E7%BB%AA%E8%AE%BA/</id>
    <published>2022-01-10T13:21:36.000Z</published>
    <updated>2022-01-27T15:19:38.664Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是关于周志华老师编写的机器学习书籍『西瓜书』的第一章绪论的简单体会.</p><p>主要的内容有: 机器学习的过程的一些基本术语和假设空间的解释. (归纳偏好回头再来)</p></blockquote><span id="more"></span><h2 id="引言">1.1 引言</h2><p>通俗来说机器学习: 在学习了很多的『经验』情况下, 学会了某种『方法』, 遇到<strong>新的问题</strong>后, 根据之前的『经验』和『方法』做出有效的决策.</p><blockquote><p>所谓"经验"就是"数据";</p><p>所谓"方法"就是机器学习研究的主要内容, 也就是从数据中学会的"模型"(model) 算法.</p></blockquote><h2 id="基本术语">1.2 基本术语</h2><h3 id="数据部分">数据部分</h3><ul><li><p><strong>数据集</strong>: 记录的集合称为一个"数据集"(data set);</p></li><li><p><strong>样本</strong>: 每条记录是关于一个事件或对象(这里是一个西瓜)的描述, 称为一个"示例"(instance) 或"样本"(sample);</p></li><li><p><strong>特征</strong>: 反映事件或对象在某方面的表现或性质的事项, 例如"色泽" "根蒂" "敲声", 称为"属性"(attribute) 或"特征"(feature);</p></li><li><p><strong>样本空间</strong>: 属性上的取值，例如"青绿" "乌黑", 称为"属性值" (attribute value). 属性张成的空间称为"属性空间" (attribute space) 、 "样本空间" (sample space) 或"输入空间".</p><blockquote><p>把属性值作为坐标轴，张成多维空间，得到坐标位置，每个点对应一个坐标向量，由此也把一个示例称为一个<strong>"特征向量" (feature vector)</strong>.</p></blockquote></li></ul><h3 id="学习过程">学习过程</h3><ul><li><p><strong>训练</strong>: 从数据中学得模型的过程称为"学习"(learning)或"训练"(training) ,这个过程通过执行某个学习算法来完成;</p></li><li><p><strong>训练样本</strong>: 训练过程中使用的数据称为"训练数据"(training data), 其中每个样本称为一个"训练样本"(training sample), 训练样本组成的集合称为"训练集"(training set);</p><blockquote><p>但有时候也会将整个数据集称为<strong>样本</strong>，需要依靠上下文判断。</p></blockquote></li><li><p><strong>学习器</strong>: 有时将模型称为"学习器"(learner), 可看作学习算法在给定数据和参数空间上的实例化;</p></li><li><p><strong>测试样本</strong>: 学得模型后, 使用器进行预测的过程称为"测试"(testing), 被预测的样本称为"测试样本"(test sample).</p></li></ul><h3 id="标记部分">标记部分</h3><ul><li><strong>标记</strong>: 关于示例结果的信息，例如"好瓜"，称为"标记" (label), 拥有了标记信息的示例，则称为"样例" (example);</li><li><strong>标记空间</strong>: 标记集合称为标记空间(label space)或"输出空间".</li></ul><h3 id="学习任务">学习任务</h3><ul><li><strong>分类</strong>: 若预测的是离散值, 则此类学习任务称为"分类"(classification);</li><li><strong>回归</strong>: 若预测的是连续值, 则此类学习任务称为"回归"(regression);</li><li><strong>聚类</strong>: 若对数据样本进行划分为各个"簇"(cluster), 则将此类学习任务称为"聚类"; &gt; 聚类的学习过程中使用的训练样本通常没有标记信息.</li><li>根据学习任务进行划分, 通常有两大类: <strong>有监督学习</strong>(supervised learning)和<strong>无监督学习</strong>(unsupervised learning), 分类和回归是前者的代表, 聚类则是后者的代表.</li></ul><h3 id="模型目标">模型目标</h3><ul><li>机器学习的目标是使得模型能够很好的适用于<strong>新样本</strong>, 而不是仅仅在训练集上表现的很好. 即使是聚类这种无监督的学习任务, 也同样如此;</li><li>学得的模型适用于新样本的能力, 称为"泛化"(generalization);</li><li>所以我们希望获得的样本能够尽可能的表示样本空间的特性, 从而在整个样本空间上都表现的很好;</li><li>通常假设每个样本都是<strong>独立同分布</strong>(independent and identically);</li><li>训练样本越多, 越有可能获得强泛化能力的模型.</li></ul><h2 id="假设空间">1.3 假设空间</h2><p>归纳(induction)与演绎(deduction)是科学推理的两大基本手段:</p><ul><li>前者是从特殊到一般的<strong>泛化</strong>(generalization)过程，即从具体的事实归结出一般性规律;</li><li>后者则是从一般到特殊的<strong>特化</strong>(specialization)过程，即从基础原理推演出具体状况.</li></ul><p>把学习的过程看作一个在所有假设(hypothesis)组成的空间中进行<strong>搜索</strong>的过程, 搜索的目标是找到与训练集"匹配"(fit)的假设.</p><blockquote><p>假设的表示一旦确定, 假设空间及其规模大小就确定了.</p></blockquote><p>搜索的策略有: 自顶向下、从一般到特殊，或是自底向上、从特殊到一般等. 搜索过程也可以不断删除与正例不一致的假设. 最终获得<strong>与训练集一致</strong>的假设, 这就是学习的结果.</p><p>但是现实中假设空间可能很大, 但是学习过程中使用的训练样本有限, 所以实际上存在很多的假设空间，但仅存在一个与训练集一致的<strong>假设集合</strong>, 称之为<strong>版本空间</strong>(version space).</p><h2 id="归纳偏好">1.4 归纳偏好</h2><p>// todo</p><h2 id="个人收获">个人收获</h2><p>整理了机器学习基本的术语和一些名词, 这是<strong>磨刀</strong>.</p><p>新接触了版本空间的概念,这是之前学习一些内容的时候没有注意到的部分.</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是关于周志华老师编写的机器学习书籍『西瓜书』的第一章绪论的简单体会.&lt;/p&gt;
&lt;p&gt;主要的内容有: 机器学习的过程的一些基本术语和假设空间的解释. (归纳偏好回头再来)&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://gipbear.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="西瓜书" scheme="https://gipbear.github.io/tags/%E8%A5%BF%E7%93%9C%E4%B9%A6/"/>
    
    <category term="名词解释" scheme="https://gipbear.github.io/tags/%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"/>
    
  </entry>
  
  <entry>
    <title>数组解题技巧3——二分查找</title>
    <link href="https://gipbear.github.io/2022/01/10/%E6%95%B0%E7%BB%84%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A73%E2%80%94%E2%80%94%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>https://gipbear.github.io/2022/01/10/%E6%95%B0%E7%BB%84%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A73%E2%80%94%E2%80%94%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</id>
    <published>2022-01-10T11:18:35.000Z</published>
    <updated>2022-01-10T12:57:32.852Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是关于问题有序数组的二分查找问题，1.查找一个元素；2.查找区间全元素。</p><p>涉及 leetcode 的<a href="https://leetcode-cn.com/problems/binary-search/">704. 二分查找</a>和<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a>。</p></blockquote><span id="more"></span><h2 id="二分查找">二分查找</h2><h3 id="题目1">题目1</h3><p>首先来看题目<a href="https://leetcode-cn.com/problems/binary-search/">704. 二分查找</a>：给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><p>示例1：</p><blockquote><p>输入：nums = [-1,0,3,5,9,12], target = 9</p><p>输出：4</p></blockquote><p>示例2：</p><blockquote><p>输入：nums = [-1,0,3,5,9,12], target = 2</p><p>输出：-1</p></blockquote><h3 id="理解一下1">理解一下1</h3><p>题目的大概意思就是：在有序数组<code>nums</code>中找出与<code>target</code>相同的元素的索引位置。</p><p>直接遍历的时间复杂度是O(n)，而这里是<strong>有序数组</strong>，那么就可以使用二分查找，由此时间复杂度为O(log n)。</p><p>基本的思路是：</p><ol type="1"><li>约束查找区间左索引指针<code>left</code>和右索引指针<code>right</code>，获得中间索引指针<code>mid</code>；</li><li>判断<code>mid</code>指向的元素与<code>target</code>的大小：<ol type="1"><li>等于<code>target</code>：返回该<code>mid</code>索引；</li><li>大于<code>target</code>：说明在左侧，<code>right</code>向左收缩；</li><li>小于<code>target</code>：说明在右侧，<code>left</code>向右收缩；</li></ol></li></ol><h3 id="解题1">解题1</h3><p>需要注意的是right和left是<strong>闭区间</strong>，并且while循环中使用的是<span class="math inline">\(\leq\)</span>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>()<span class="number">-1</span>; <span class="comment">// 右侧需要减一</span></span><br><span class="line">    <span class="comment">// 计算 mid 时需要防止太大溢出</span></span><br><span class="line">    <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left = mid +<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找元素区间">查找元素区间</h2><h3 id="题目2">题目2</h3><p>首先来看题目<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a>：给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回[-1, -1]。</p><p>示例1：</p><blockquote><p>输入：nums = [5,7,7,8,8,10], target = 8</p><p>输出：[3,4]</p></blockquote><p>示例2：</p><blockquote><p>输入：nums = [5,7,7,8,8,10], target = 6</p><p>输出：[-1,-1]</p></blockquote><h3 id="理解一下2">理解一下2</h3><p>这道题目是想要寻找等于target的所有元素，由于是<strong>有序数组</strong>，所以由一个<strong>区间</strong>表示。主要的问题在于如何寻找到区间的<strong>左右边界</strong>。</p><p>这里有两个思路，都是利用<strong>二分查找</strong>。</p><h3 id="解题2.1">解题2.1</h3><ol type="1"><li>按照普通的二分查找，找到寻找一个等于target的元素位置；</li><li>若未找到则flag置为false；</li><li>若找到了，那么向左右依次寻找临界点即可。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)&#123;  <span class="comment">// 此处判断元素相等则跳出循环</span></span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        left = mid;</span><br><span class="line">        right = mid;</span><br><span class="line">        <span class="keyword">while</span>(--left &gt;= <span class="number">0</span> &amp;&amp; nums[left] == target);</span><br><span class="line">        <span class="keyword">while</span>(++right &lt; nums.<span class="built_in">size</span>() &amp;&amp; nums[right] == target);</span><br><span class="line">        <span class="keyword">return</span> &#123;++left, --right&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题解2.2">题解2.2</h3><p>与方法一不同，直接去寻找左右端点。</p><p>需要修改的地方仅仅是在<strong>二分查找相等</strong>时和<strong>收缩边界</strong>的情况<strong>统一</strong>起来，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="built_in">leftRange</span>(nums, target);</span><br><span class="line">    <span class="keyword">if</span>(left == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="built_in">rightRange</span>(nums, target);</span><br><span class="line">    <span class="keyword">return</span> &#123;left, right&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">leftRange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;  <span class="comment">// 右侧向左侧收缩，找到左端点</span></span><br><span class="line">        &#125;</span><br><span class="line">        mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= nums.<span class="built_in">size</span>() || nums[left] != target)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rightRange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;  <span class="comment">// 左侧向右侧收缩，找到右端点</span></span><br><span class="line">        &#125;</span><br><span class="line">        mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(right &lt; <span class="number">0</span> || nums[right] != target)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="个人收获">个人收获</h2><p>这里使用的二分查找比较简单，类似于一棵树，主要就是收缩区间和循环终止等一些细节问题。</p><p>第二个关于区间问题的方法，在leetcode上虽然第一个方法的效率较高，但是第二个方法的模块化和层次化要更好，更适合进行改编改写。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是关于问题有序数组的二分查找问题，1.查找一个元素；2.查找区间全元素。&lt;/p&gt;
&lt;p&gt;涉及 leetcode 的&lt;a href=&quot;https://leetcode-cn.com/problems/binary-search/&quot;&gt;704. 二分查找&lt;/a&gt;和&lt;a href=&quot;https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/&quot;&gt;34. 在排序数组中查找元素的第一个和最后一个位置&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据结构算法" scheme="https://gipbear.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="c++" scheme="https://gipbear.github.io/tags/c/"/>
    
    <category term="leetcode题解" scheme="https://gipbear.github.io/tags/leetcode%E9%A2%98%E8%A7%A3/"/>
    
    <category term="双指针" scheme="https://gipbear.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="数组" scheme="https://gipbear.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="二分查找" scheme="https://gipbear.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>字符串解题技巧1——滑动窗口</title>
    <link href="https://gipbear.github.io/2022/01/09/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A71%E2%80%94%E2%80%94%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <id>https://gipbear.github.io/2022/01/09/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A71%E2%80%94%E2%80%94%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</id>
    <published>2022-01-09T13:51:01.000Z</published>
    <updated>2022-01-10T09:32:13.774Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是关于字符串的子串问题，就数据结构的形态来说还是属于数组的问题，这里主要是关于使用双指针解决滑动窗口的问题。</p><p>涉及 leetcode 的<a href="https://leetcode-cn.com/problems/minimum-window-substring/">76. 最小覆盖子串</a>、<a href="https://leetcode-cn.com/problems/permutation-in-string/">567. 字符串的排列</a>、<a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a>和<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a>。</p></blockquote><span id="more"></span><h2 id="包含子串元素问题">包含子串元素问题</h2><p><a href="https://leetcode-cn.com/problems/minimum-window-substring/">76. 最小覆盖子串</a>、<a href="https://leetcode-cn.com/problems/permutation-in-string/">567. 字符串的排列</a>和<a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a>这一系列的问题都是关于在字符串中包含子串元素的问题。</p><h3 id="题目1">题目1</h3><p>首先来看这些题目<a href="https://leetcode-cn.com/problems/permutation-in-string/">567. 字符串的排列</a>：给你两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true；否则，返回 false。</p><p>换句话说，s1 的排列之一是 s2 的子串。</p><p>示例1：</p><blockquote><p>输入：s1 = "ab" s2 = "eidbaooo"</p><p>输出：true</p></blockquote><p>示例2：</p><blockquote><p>输入：s1= "ab" s2 = "eidboaoo"</p><p>输出：false</p></blockquote><h3 id="理解一下1">理解一下1</h3><p>题目的大概意思就是：给你一个子串 s1，需要判断在 s2 中是否一个子串包含子串 s1 中的所有元素。</p><p>基本的思路是：</p><ol type="1"><li>获得子串<code>s1</code>的长度<code>Len</code>；</li><li>按照<code>Len</code>的大小，使用左右索引指针组成的<strong>固定窗口</strong>，在字符串<code>s2</code>上滑动；</li><li>不断比较窗口内的子串和<code>s1</code>的元素是否相同；</li><li>比较的方法可以使用<strong>hash表</strong>或数组，比较各个元素出现的次数相同即可。</li></ol><p>以上的方法需要的时间复杂度为两个字符串长度的乘积，即O(NM)。</p><p>想要优化到O(n)，则可以使用<strong>不固定的滑动窗口</strong>来完：</p><ol type="1"><li>首先使用<strong>hash表</strong>记录子串<code>s1</code>中元素出现的次数；</li><li>初始化在<code>s2</code>上的左右索引指针为0；</li><li>右索引指针进行向右<strong>扩张</strong>，不断将字符纳入窗口；</li><li>判断新加入的字符是否子串<code>s1</code>中的，若是则在<strong>窗口hash表</strong>记录字符及其个数；</li><li>此时若窗口内的子串不满足子串<code>s1</code>的元素要求，那么左索引指针右移来缩小窗口范围，并更新相应内容即可。</li></ol><h3 id="解题1">解题1</h3><p>以上的思路可能我没有很清楚的表示，不过没关系，我们弄清楚以下几点：</p><ol type="1"><li>移动right扩大窗口时该做什么？：判断新纳入窗口的字符是否是我们需要的，若需要则<strong>加入</strong>，并增加字符个数<strong>valid</strong>；</li><li>何时停止扩大窗口，并移动left缩小窗口？：窗口大小 ≥ 子串大小时；</li><li>缩小窗口时该干什么？；<ul><li>首先判断此时是否已经满足条件，若满足则直接返回；</li><li>否则移除left处元素，若是需要的元素，则更新有效值，并<strong>删除</strong>窗口内的元素。</li></ul></li></ol><p>还是看代码逻辑吧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// need是子串元素hash表，window是滑动窗口</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="comment">// 初始化need子串</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : s1)</span><br><span class="line">        need[c]++;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;  <span class="comment">// 区间左闭右开</span></span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;  <span class="comment">// 窗口内有效元素个数</span></span><br><span class="line">    <span class="keyword">while</span>(right &lt; s2.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s2[right];  <span class="comment">// 右移字符进入子串hash</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">if</span>(need.<span class="built_in">count</span>(c))&#123;  <span class="comment">// 1. 若是需要元素则修改hash</span></span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span>(window[c] == need[c])</span><br><span class="line">                valid++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 区域可缩小</span></span><br><span class="line">        <span class="keyword">while</span>(right-left &gt;= s1.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="comment">// 3.1 满足条件直接返回</span></span><br><span class="line">            <span class="keyword">if</span>(valid == need.<span class="built_in">size</span>())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> d = s2[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 3.2 移除元素</span></span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(d))&#123;</span><br><span class="line">                <span class="keyword">if</span>(window[d] == need[d])</span><br><span class="line">                    valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok，有了以上的代码再看剩下两题几乎是一模一样，就不详细解说了，代码如下：</p><h4 id="最小覆盖子串"><a href="https://leetcode-cn.com/problems/minimum-window-substring/">76. 最小覆盖子串</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// need是子串元素hash，window是滑动窗口</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="comment">// 初始化need子串</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : t)</span><br><span class="line">        need[c]++;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>; <span class="comment">// 区间左闭右开</span></span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;  <span class="comment">// 窗口内有效元素个数</span></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, len = INT_MAX;  <span class="comment">// 最终起点和长度</span></span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[right];  <span class="comment">//右移字符进入子串hash</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">if</span>(need.<span class="built_in">count</span>(c))&#123;  <span class="comment">//若需要则修改hash</span></span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span>(window[c] == need[c])</span><br><span class="line">                valid++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(valid == need.<span class="built_in">size</span>())&#123;  <span class="comment">//窗口内的元素已经满足需要</span></span><br><span class="line">            <span class="keyword">if</span>(right-left &lt; len)&#123;  <span class="comment">// 可以收缩窗口就更新结果</span></span><br><span class="line">                start = left;</span><br><span class="line">                len = right - left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(d))&#123;</span><br><span class="line">                <span class="keyword">if</span>(window[d] == need[d])</span><br><span class="line">                    valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len == INT_MAX ? <span class="string">&quot;&quot;</span> : s.<span class="built_in">substr</span>(start, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="找到字符串中所有字母异位词"><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a></h4><p>所谓异位词也就是子串重新排列嘛，不用感到新奇。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : p)</span><br><span class="line">        need[c]++;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[right++];</span><br><span class="line">        <span class="keyword">if</span>(need.<span class="built_in">count</span>(c))&#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span>(window[c] == need[c])</span><br><span class="line">                valid++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(right-left &gt;= p.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(valid == need.<span class="built_in">size</span>())&#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> d = s[left++];</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(d))&#123;</span><br><span class="line">                <span class="keyword">if</span>(window[d] == need[d])</span><br><span class="line">                    valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="无重复字符的最长子串">无重复字符的最长子串</h2><p>这题其实与以上三题大差不差，只不过这里<strong>没有给定子串</strong>，而是需要我们<strong>求出子串</strong>而已。</p><h3 id="题目2">题目2</h3><p>首先来看题目<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a>：给定一个字符串 s ，请你找出其中不含有重复字符的<strong>最长子串</strong>的长度。</p><p>示例1：</p><blockquote><p>输入："abcabcbb"</p><p>输出：3</p></blockquote><p>示例2：</p><blockquote><p>输入：s = "bbbbb"</p><p>输出：1</p></blockquote><h3 id="理解一下2">理解一下2</h3><p>题目的大概意思就是：找出字符串中元素不重复的子串的长度，也就是需要子串中的元素<strong>不重复</strong>，个数要尽可能的<strong>多</strong>。</p><p>保持之前的解题思路，但是这里就不需要<code>needhash</code>表和<code>valid</code>值了，因为我们没有需要比较的子串，但是需要一个<code>res</code>来记录长度：</p><ol type="1"><li>右侧子串向前扩张，将新字符纳入窗口；</li><li>判断该窗口内加入的该子串是否重复；</li><li>若重复，则左侧索引指针收缩，直至将重复元素抛出；</li><li>判断此时的长度与<code>res</code>大小，更新最大子串长度。</li></ol><h3 id="解题2">解题2</h3><p>很简单吧，看代码更简单。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; window;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="comment">// 扩张</span></span><br><span class="line">        <span class="keyword">char</span> c = s[right++];</span><br><span class="line">        window[c]++;</span><br><span class="line">        <span class="comment">// 有重复的字符</span></span><br><span class="line">        <span class="keyword">while</span>(window[c] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 收缩</span></span><br><span class="line">            <span class="keyword">char</span> d = s[left++];</span><br><span class="line">            window[d]--;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(res, right - left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="个人收获">个人收获</h2><p>之前使用双指针解决链表的时候，用快慢指针来解决一些链表上的逻辑问题；但是在字符串这种类似数组的数据结构中也是可以使用<strong>索引来表示指针</strong>，解决一些逻辑问题。</p><p>滑动窗口的结合hash表既可以来表示区域内的元素数量了，对于一些<strong>不要求顺序的子串问题</strong>就可以使用该方法解决。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是关于字符串的子串问题，就数据结构的形态来说还是属于数组的问题，这里主要是关于使用双指针解决滑动窗口的问题。&lt;/p&gt;
&lt;p&gt;涉及 leetcode 的&lt;a href=&quot;https://leetcode-cn.com/problems/minimum-window-substring/&quot;&gt;76. 最小覆盖子串&lt;/a&gt;、&lt;a href=&quot;https://leetcode-cn.com/problems/permutation-in-string/&quot;&gt;567. 字符串的排列&lt;/a&gt;、&lt;a href=&quot;https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/&quot;&gt;438. 找到字符串中所有字母异位词&lt;/a&gt;和&lt;a href=&quot;https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/&quot;&gt;3. 无重复字符的最长子串&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据结构算法" scheme="https://gipbear.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="c++" scheme="https://gipbear.github.io/tags/c/"/>
    
    <category term="leetcode题解" scheme="https://gipbear.github.io/tags/leetcode%E9%A2%98%E8%A7%A3/"/>
    
    <category term="双指针" scheme="https://gipbear.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="字符串" scheme="https://gipbear.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="滑动窗口" scheme="https://gipbear.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>数组解题技巧2——差分数组</title>
    <link href="https://gipbear.github.io/2022/01/07/%E6%95%B0%E7%BB%84%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A72%E2%80%94%E2%80%94%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"/>
    <id>https://gipbear.github.io/2022/01/07/%E6%95%B0%E7%BB%84%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A72%E2%80%94%E2%80%94%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/</id>
    <published>2022-01-07T15:42:27.000Z</published>
    <updated>2022-01-10T09:31:53.337Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是关于数组的差分数组技巧，在对元素数组区间进行加减计算时使用。</p><p>涉及 leetcode 的<a href="https://leetcode-cn.com/problems/range-addition">370. 区间加法</a>、<a href="https://leetcode-cn.com/problems/corporate-flight-bookings">1109. 航班预订统计</a>和<a href="https://leetcode-cn.com/problems/car-pooling">1094. 拼车</a>。</p></blockquote><span id="more"></span><h2 id="合并两个有序链表">合并两个有序链表</h2><h3 id="题目1">题目1</h3><p>首先来看题目<a href="https://leetcode-cn.com/problems/range-addition">370. 区间加法</a>：假设你有一个长度为 n 的数组，初始情况下所有的数字均为 0，你将会被给出 k 个更新的操作。其中，每个操作会被表示为一个三元组：[startIndex, endIndex, inc]，你需要将子数组 A[startIndex ... endIndex]（包括 startIndex 和 endIndex）增加 inc。</p><p>请你返回 k 次操作后的数组。</p><p>示例1：</p><blockquote><p>输入：length = 5, updates = [ [1,3,2],[2,4,3],[0,2,-2] ]</p><p>输出：[-2,0,3,5,3]</p></blockquote><h3 id="理解一下1">理解一下1</h3><p>题目的大概意思就是：</p><ol type="1"><li>初始数组为元素均为 0；</li><li>三元组表示在区间<code>startIndex</code>到<code>endIndex</code>内的元素都加上<code>inc</code>。</li></ol><p>最直白的思路就是，将每个三元组表示的区间一个一个加上值，很快就能实现，但是复杂度太高会超时，那么怎么办呢？</p><p>这里引入<strong>差分数组</strong>的概念：</p><p>差分数组就是在原长度为<code>n</code>的<code>nums</code>数组上，构建一个长度为<code>n+1</code>的数组<code>diff</code>，<code>diff[i] = nums[i] - nums[i-1]</code>，也就是原数组相邻两项的之差。</p><p>当差分数组计算完成之后再通过<code>nums[i] = nums[i-1] + diff[i]</code>即可还原得到相应的数组。</p><blockquote><p>对差分数组的第<code>i</code>项进行计算，都会同等影响到之后的剩余项，这就是差分数组的<strong>性质</strong>！</p></blockquote><p>因此，我们可以在差分数组上对第<code>first</code>项加上<code>seats</code>，使得后续的每一项都会增加<code>seats</code>，但是我们只想增加到第<code>last</code>项，所以在第<code>last+1</code>项之后再减去<code>seats</code>，就可以抵消该影响啦！</p><p>ok，那我们就来看代码吧！</p><h3 id="解题1">解题1</h3><p>构建差分数组的时候，使得差分数组的长度为<code>n+1</code>可以使得不用判断数组越界的问题，这个和链表增加<strong>头结点</strong>有异曲同工之妙。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">getModifiedArray</span><span class="params">(<span class="keyword">int</span> length, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; updates)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实际上计算的nums是差分数组，只不过这里开始都为0</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(length+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; updates.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        nums[updates[i][<span class="number">0</span>]] += updates[i][<span class="number">2</span>];</span><br><span class="line">        nums[updates[i][<span class="number">1</span>]+<span class="number">1</span>] -= updates[i][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 差分数组还原</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++)&#123;</span><br><span class="line">        nums[i] += nums[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    nums.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于<a href="https://leetcode-cn.com/problems/corporate-flight-bookings">1109. 航班预订统计</a>和<a href="https://leetcode-cn.com/problems/car-pooling">1094. 拼车</a>这两个问题实际上就是将该简单问题应用到实际场景中了，学会了这个差分数组的思想就很容易了，只需要注意端点细节处理即可。</p><h2 id="个人收获">个人收获</h2><ol type="1"><li><p>前缀和数组用于计算区域和问题，差分数组用于区域元素同时加减问题，而且使用频率较高时使用效果较好。</p></li><li><p>注意将数组长度扩大一个，这个在计算相邻项的时候就无需判断在数组最后是否会出现数组越界的问题，与链表中增加头结点的效果类似。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是关于数组的差分数组技巧，在对元素数组区间进行加减计算时使用。&lt;/p&gt;
&lt;p&gt;涉及 leetcode 的&lt;a href=&quot;https://leetcode-cn.com/problems/range-addition&quot;&gt;370. 区间加法&lt;/a&gt;、&lt;a href=&quot;https://leetcode-cn.com/problems/corporate-flight-bookings&quot;&gt;1109. 航班预订统计&lt;/a&gt;和&lt;a href=&quot;https://leetcode-cn.com/problems/car-pooling&quot;&gt;1094. 拼车&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据结构算法" scheme="https://gipbear.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="c++" scheme="https://gipbear.github.io/tags/c/"/>
    
    <category term="leetcode题解" scheme="https://gipbear.github.io/tags/leetcode%E9%A2%98%E8%A7%A3/"/>
    
    <category term="数组" scheme="https://gipbear.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="差分数组" scheme="https://gipbear.github.io/tags/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>数组解题技巧1——前缀和数组</title>
    <link href="https://gipbear.github.io/2022/01/07/%E6%95%B0%E7%BB%84%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A71%E2%80%94%E2%80%94%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84/"/>
    <id>https://gipbear.github.io/2022/01/07/%E6%95%B0%E7%BB%84%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A71%E2%80%94%E2%80%94%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84/</id>
    <published>2022-01-07T14:44:22.000Z</published>
    <updated>2022-01-10T09:31:44.684Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是关于数组的前缀和技巧，在快速计算一个数组区间内的元素之和时使用</p><p>涉及 leetcode 的 <a href="https://leetcode-cn.com/problems/range-sum-query-immutable">303. 区域和检索 - 数组不可变</a>、<a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable">304. 二维区域和检索 - 矩阵不可变</a>和<a href="https://leetcode-cn.com/problems/subarray-sum-equals-k">560. 和为 K 的子数组</a>。</p></blockquote><span id="more"></span><h2 id="区域检索">区域检索</h2><h3 id="题目1">题目1</h3><p>首先来看题目<a href="https://leetcode-cn.com/problems/range-sum-query-immutable">303. 区域和检索 - 数组不可变</a>：给定一个整数数组 nums，求出数组从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点。</p><p>示例1：</p><blockquote><p>输入：[ [ [-2, 0, 3, -5, 2, -1] ], [0, 2], [2, 5], [0, 5] ]</p><p>输出：[null, 1, -1, -3]</p></blockquote><h3 id="理解一下1">理解一下1</h3><p>题目的大概意思就是：计算数组内某个区域的和。</p><p>代码要求有两点，一个是写出构造函数，一个是写出计算区域和的函数。</p><p>基本的思路是：</p><ol type="1"><li>构造函数直接将数组传递过去就行；</li><li>在<code>sumRange</code>中使用循环计算<code>left</code>到<code>right</code>的和。</li></ol><p>很简单的嘛，OK确实，但是提交了发现超越的人数不多呀，这怎么行！</p><p>仔细思考发现 OJ 测试的时候构造函数仅仅调用<strong>一次</strong>，而计算区域和函数调用了<strong>多次</strong>，所以我们需要优化<code>sumRange</code>函数。</p><p>于是考虑使用前缀和，使得构造函数麻烦一些，但是使得<code>sumRange</code>函数<strong>简单</strong>一些：</p><ol type="1"><li>使用构造函数时，直接在传递数组时，计算前<code>n</code>项的前缀累加和，时间复杂度为<code>O(n)</code>；</li><li>然后<code>sumRange</code>函数计算<code>left</code>到<code>right</code>的区域和时，只需要使用第<code>right</code>项的前缀和减去第<code>left-1</code>项前缀和即可，<code>sumRange</code>的时间复杂度就是<code>O(1)</code>。</li></ol><h3 id="解题1">解题1</h3><p>先看解法一：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;nums = nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; i++)&#123;</span><br><span class="line">            sum += <span class="keyword">this</span>-&gt;nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再看使用前缀和的解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; presums;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="comment">// 构造时为 n 的复杂度</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;presums.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;presums[i] = <span class="keyword">this</span>-&gt;presums[i<span class="number">-1</span>] + nums[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用时仅需要直接索引相减即可</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;presums[right+<span class="number">1</span>] - <span class="keyword">this</span>-&gt;presums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关于<a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable">304. 二维区域和检索 - 矩阵不可变</a>这题，只不过是从一维变化成了二维，大家举一反三即可。</p><p>需要注意的仅仅是边界的细节问题。</p><h2 id="和为-k-的子数组">和为 K 的子数组</h2><h3 id="题目2">题目2</h3><p>首先来看题目<a href="https://leetcode-cn.com/problems/subarray-sum-equals-k">560. 和为 K 的子数组</a>：给你一个整数数组 nums 和一个整数 k ，请你统计并返回该数组中和为 k 的连续子数组的个数。</p><p>示例1：</p><blockquote><p>输入：nums = [1,1,1], k = 2</p><p>输出：2</p></blockquote><p>示例2：</p><blockquote><p>输入：nums = [1,2,3], k = 3</p><p>输出：2</p></blockquote><h3 id="理解一下2">理解一下2</h3><p>题目的大概意思就是：计算出，给定数组中有多少个连续子数组的和为 K，也就是给定数组中有多少个区间和为K。</p><p>最基本的思路就是穷举嘛，嵌套循环，计算所有区间的数组之和，判断其是否为 K。不过很遗憾，时间复杂度<span class="math inline">\(O(n^2)\)</span>在10000大小的测试案例中超时了。</p><p>再仔细看看区域和为K，关于区域和那我们很自然的想到使用前缀和数组试试看了：</p><ol type="1"><li>计算前缀和数组；</li><li>我们要计算区域和，就得使用前缀和数组的端点值相减，并判断是否为K，如此一来时间复杂度又回到了<span class="math inline">\(O(n^2)\)</span>；</li><li>换个思路，验证<code>i</code>处的前缀和<code>sum_i</code>减去<code>K</code>的差值<code>sum_j</code>，判断<code>sum_j</code>是否已经<strong>存在</strong>已知的前缀和数组中，若存在则统计<strong>出现次数</strong>即可！</li><li><code>sum_j</code>出现的次数就是i为右端点的区间可以出现的次数，随着不断计算前缀和数组和计数，那么时间复杂度仅仅是计算前缀和的时间O(n)。</li></ol><h3 id="题解2">题解2</h3><p>判断存在计数可以使用<strong>hash表</strong>来实现，快速高效。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用hash表来记录前缀和出现的次数</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; presum;</span><br><span class="line">    <span class="comment">// 初始记录为 0，因为存在一个数等于 k 的情况</span></span><br><span class="line">    presum[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// count 记录个数，sum_i 计算前缀和</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>, sum_i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num: nums)&#123;</span><br><span class="line">        sum_i += num;</span><br><span class="line">        <span class="keyword">int</span> sum_j = sum_i - k;</span><br><span class="line">        <span class="comment">// 相差为 k 的前缀和若存在，则区域相加为 k</span></span><br><span class="line">        <span class="keyword">if</span>(presum.<span class="built_in">find</span>(sum_j) != presum.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="comment">// 加上此前出现 sum_j 的次数</span></span><br><span class="line">            count += presum[sum_j];</span><br><span class="line">        &#125;</span><br><span class="line">        presum[sum_i]++; <span class="comment">// 出现次数加 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="个人收获">个人收获</h2><p>前缀和的计算方法主要适用于处理数组<strong>区域之和</strong>的问题，并且计算区域和<strong>频率较高</strong>时使用，能够达到较好的效果。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是关于数组的前缀和技巧，在快速计算一个数组区间内的元素之和时使用&lt;/p&gt;
&lt;p&gt;涉及 leetcode 的 &lt;a href=&quot;https://leetcode-cn.com/problems/range-sum-query-immutable&quot;&gt;303. 区域和检索 - 数组不可变&lt;/a&gt;、&lt;a href=&quot;https://leetcode-cn.com/problems/range-sum-query-2d-immutable&quot;&gt;304. 二维区域和检索 - 矩阵不可变&lt;/a&gt;和&lt;a href=&quot;https://leetcode-cn.com/problems/subarray-sum-equals-k&quot;&gt;560. 和为 K 的子数组&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据结构算法" scheme="https://gipbear.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="c++" scheme="https://gipbear.github.io/tags/c/"/>
    
    <category term="leetcode题解" scheme="https://gipbear.github.io/tags/leetcode%E9%A2%98%E8%A7%A3/"/>
    
    <category term="数组" scheme="https://gipbear.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="前缀和" scheme="https://gipbear.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>加快国内访问GitHub速度</title>
    <link href="https://gipbear.github.io/2022/01/07/%E5%8A%A0%E5%BF%AB%E5%9B%BD%E5%86%85%E8%AE%BF%E9%97%AEGitHub%E9%80%9F%E5%BA%A6/"/>
    <id>https://gipbear.github.io/2022/01/07/%E5%8A%A0%E5%BF%AB%E5%9B%BD%E5%86%85%E8%AE%BF%E9%97%AEGitHub%E9%80%9F%E5%BA%A6/</id>
    <published>2022-01-07T08:16:03.000Z</published>
    <updated>2022-01-08T08:30:33.761Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要是为了提高国内访问GitHub的速度。</p><p>方法是修改host文件。</p></blockquote><span id="more"></span><p>在国内 GitHub 访问速度慢或者无法访问，一般是因为 github 的加速分发 CDN 域名<code>assets-cdn.github.com</code>遭到<a href="https://baike.baidu.com/item/DNS%E6%B1%A1%E6%9F%93/8620359">DNS污染</a>，无法访问导致的。</p><p>所以解决方法就是修改本地的 host 映射，让解析的域名直接指向 Github 的 IP 地址，来绕过 DNS 解析。</p><h2 id="查询最新的-github-的-ip-地址">查询最新的 Github 的 IP 地址</h2><p>使用<a href="https://www.ipaddress.com/">ipaddress.com</a>查询以下域名对应的 IP 地址：</p><blockquote><p>github.com assets-cdn.github.com github.global.ssl.fastly.net</p></blockquote><h2 id="修改本地-host-文件">修改本地 host 文件</h2><p>Windows 用户在<code>C:\Windows\System32\drivers\etc</code>下找到 host 目录，若没有修改权限在<code>属性 -&gt; 安全</code>中增加用户的修改权限。</p><p>在使用记事本打开，在最后加入查询的 IP 和域名，增加如下内容，其中 IP 是自己查的最新的：</p><blockquote><p>#github映射（随便啦，做个标记让自己以后看到知道这里修改了什么）</p><p>140.82.114.3 github.com</p><p>185.199.108.153 assets-cdn.github.com</p><p>199.232.69.194 github.global.ssl.fastly.net</p></blockquote><h2 id="刷新-dns-缓存">刷新 DNS 缓存</h2><p>Windows 下使用<code>Win+R</code>，输入<code>cmd</code>，打开命令行，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /flushdns</span><br></pre></td></tr></table></figure><p>刷新成功后就可以愉快的访问 Github 了。</p><h2 id="最后">最后</h2><p>由于 IP 经常会发生变化，所以如果访问变慢了就需要手动更新。</p><p>这里推荐一个网址<a href="https://raw.hellogithub.com/hosts">hellogithub</a>，有最新的 Github 访问 IP，可以直接复制粘贴。（不过还是建议自己搜一下这三个域名的ip，也很快，这个直接复制的效果好像并不好）</p><h2 id="参考文章">参考文章</h2><ol type="1"><li><a href="https://juejin.cn/post/6955761924722130974">国内加速访问Github的办法，超级简单</a></li><li><a href="https://juejin.cn/post/7019683061977579557">解决GitHub访问慢的问题</a></li></ol><h2 id="个人收获">个人收获</h2><p>其实很早之前就修改过但现在忘记了，所以还是自己写一篇文章，很久以后忘记了直接来找就好了。</p><p>其中的一些原理细节未必会懂，但是这就是一个工具呀，能用好就可以啦！</p><p>以上，继续加油！</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文主要是为了提高国内访问GitHub的速度。&lt;/p&gt;
&lt;p&gt;方法是修改host文件。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="配置" scheme="https://gipbear.github.io/categories/%E9%85%8D%E7%BD%AE/"/>
    
    
    <category term="GitHub" scheme="https://gipbear.github.io/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>单链表解题技巧3——相交链表</title>
    <link href="https://gipbear.github.io/2022/01/06/%E5%8D%95%E9%93%BE%E8%A1%A8%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A73%E2%80%94%E2%80%94%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"/>
    <id>https://gipbear.github.io/2022/01/06/%E5%8D%95%E9%93%BE%E8%A1%A8%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A73%E2%80%94%E2%80%94%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</id>
    <published>2022-01-06T12:54:24.000Z</published>
    <updated>2022-01-10T09:31:02.773Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是关于单链表的判断相交问题，使用了两种方法，快慢指针和更好的逻辑连接方法。</p><p>涉及 leetcode 的 <a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a>。</p></blockquote><span id="more"></span><h2 id="相交链表">相交链表</h2><h3 id="题目">题目</h3><p>首先来看题目<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a>：给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。</p><p>示例1：</p><blockquote><p>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3</p><p>输出：Intersected at '8'</p></blockquote><p>示例2：</p><blockquote><p>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3</p><p>输出：Intersected at '8'</p></blockquote><h3 id="理解一下1">理解一下1</h3><p>所谓链表相交，就是一个<code>Y型</code>的链表结构，在交点处汇流，需要注意的是:</p><blockquote><p>链表相交后不会分开！因为链表只有一个<code>next</code>，只有唯一后继。</p></blockquote><p>寻找两条链表相交的结点就是寻找<strong>相同的结点</strong>（而不是值！）</p><p>基本的思路是：</p><p>遍历第一条链表<code>l1</code>，嵌套遍历第二条链表<code>l2</code>，判断相同的结点即可。</p><p>这种方法的时间复杂度达到了<code>O(n)</code>不是很好，于是便思考其他方法。</p><ol type="1"><li>我们需要找到相交点，而最后相交点之后链的长度都是一样的；</li><li>两个指针判断相等时需要同时到达相交点；</li><li>那么自然就需要使得前面遍历的经过的结点数相同；</li></ol><h3 id="解法一双指针">解法一（双指针）</h3><p>使用双指针来解决，我思考的时候还是比较自然的，表述可能不够清晰，自己动手比划比划就很清楚了。</p><ol type="1"><li>当链长相同时，自然是一一比较即可（这种情况不用考虑，包含在下面）；</li><li>链长不同是，短链的指针<code>l1</code>会先到达终点，而长链指针<code>l2</code>则还有<code>k</code>个结点，这个<code>k</code>刚好是两条链的长度之差；</li><li>由此我们长链中再设一个指针<code>llong</code>，跟随<code>l2</code>继续前进;</li><li>当<code>l2</code>到达终点时，<code>llong</code>距离链尾刚好与短链长度<strong>相同</strong>；</li><li>此时在短链头设置一个指针<code>lshort</code>，与<code>llong</code>一同前进，一一比较即可。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">    ListNode *la = headA, *lb = headB;</span><br><span class="line">    ListNode *lc, *llong, *lshort;</span><br><span class="line">    <span class="comment">// 依旧是快慢指针</span></span><br><span class="line">    <span class="comment">// la和lb同时前进</span></span><br><span class="line">    <span class="keyword">while</span>(la != <span class="literal">nullptr</span> &amp;&amp; lb != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        la = la-&gt;next;</span><br><span class="line">        lb = lb-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 选出长链和短链</span></span><br><span class="line">    <span class="keyword">if</span>(lb != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        lc = lb;</span><br><span class="line">        llong = headB;</span><br><span class="line">        lshort = headA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        lc = la;</span><br><span class="line">        llong = headA;</span><br><span class="line">        lshort = headB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 指向长链的快指针带着慢指针走到头</span></span><br><span class="line">    <span class="keyword">while</span>(lc != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        llong = llong-&gt;next;</span><br><span class="line">        lc = lc-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//短链从头开始和后出发的慢指针同时前进即可找到相同点</span></span><br><span class="line">    <span class="keyword">while</span>(lshort != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(lshort == llong)&#123;</span><br><span class="line">            <span class="keyword">return</span> llong;</span><br><span class="line">        &#125;</span><br><span class="line">        lshort = lshort-&gt;next;</span><br><span class="line">        llong = llong-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解法二逻辑连接">解法二（逻辑连接）</h3><p>继基本的分析思路，接下来要使得双指针同时到达交点：</p><ol type="1"><li>只需要使得双指针在到达交点时经过相同个数的结点即可；</li><li>而我们知道<code>A+B = B+A</code>；</li><li>所以在A链前加上B链，在B链前加上A链，那么双指针同时从各自链出发，会在同一时刻到达相交点！</li></ol><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">    ListNode *la = headA, *lb = headB;</span><br><span class="line">    <span class="keyword">while</span>(la != lb)&#123;</span><br><span class="line">        <span class="comment">// A链完了去B链</span></span><br><span class="line">        <span class="keyword">if</span> (la != <span class="literal">nullptr</span>)</span><br><span class="line">            la = la-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            la = headB;</span><br><span class="line">        <span class="comment">// B链完了去A链</span></span><br><span class="line">        <span class="keyword">if</span> (lb != <span class="literal">nullptr</span>)</span><br><span class="line">            lb = lb-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            lb = headA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> la;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="个人收获">个人收获</h2><p>这次感觉自己有一点很好的使用了之前学过的双指针，毕竟学了会用才是真的学会了。</p><p>另外将两个链表逻辑连接，使得两个链表的长度相同，这一点还是很值得学习的，不能作为套路，但是是一个很好的思考方向。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是关于单链表的判断相交问题，使用了两种方法，快慢指针和更好的逻辑连接方法。&lt;/p&gt;
&lt;p&gt;涉及 leetcode 的 &lt;a href=&quot;https://leetcode-cn.com/problems/intersection-of-two-linked-lists/&quot;&gt;160. 相交链表&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据结构算法" scheme="https://gipbear.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="c++" scheme="https://gipbear.github.io/tags/c/"/>
    
    <category term="单链表" scheme="https://gipbear.github.io/tags/%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    
    <category term="leetcode题解" scheme="https://gipbear.github.io/tags/leetcode%E9%A2%98%E8%A7%A3/"/>
    
    <category term="双指针" scheme="https://gipbear.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="逻辑链接" scheme="https://gipbear.github.io/tags/%E9%80%BB%E8%BE%91%E9%93%BE%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>单链表解题技巧(2)——快慢指针</title>
    <link href="https://gipbear.github.io/2022/01/06/%E5%8D%95%E9%93%BE%E8%A1%A8%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A72%E2%80%94%E2%80%94%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"/>
    <id>https://gipbear.github.io/2022/01/06/%E5%8D%95%E9%93%BE%E8%A1%A8%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A72%E2%80%94%E2%80%94%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/</id>
    <published>2022-01-06T11:00:57.000Z</published>
    <updated>2022-01-10T09:31:01.563Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是关于单链表的双指针问题中的快慢指针问题，1.链表的倒数第 n 个结点；2.寻找链表中间结点；3. 判断是否有环。</p><p>涉及 leetcode 的 <a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list">19. 删除链表的倒数第 N 个结点</a>、<a href="https://leetcode-cn.com/problems/middle-of-the-linked-list">876. 链表的中间结点</a>、<a href="https://leetcode-cn.com/problems/linked-list-cycle">141. 环形链表</a>和<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii">142. 环形链表 II</a>。</p></blockquote><span id="more"></span><h2 id="倒数第-n-个结点">倒数第 N 个结点</h2><h3 id="题目1">题目1</h3><p>首先来看题目<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list">19. 删除链表的倒数第 N 个结点</a>：给你一个链表，删除链表的<strong>倒数</strong>第 n 个结点，并且返回链表的头结点。</p><p>示例1：</p><blockquote><p>输入：head = [1,2,3,4,5], n = 2</p><p>输出：[1,2,3,5]</p></blockquote><p>示例2：</p><blockquote><p>输入：head = [1], n = 1</p><p>输出：[]</p></blockquote><h3 id="理解一下1">理解一下1</h3><p><strong>不用理解！</strong>(狗头)</p><p>基本的思路是：</p><ol type="1"><li>先遍历一遍链表，得到链表的长度<code>Len</code>；</li><li>然后再从头遍历一遍到第<code>Len-N</code>个结点，该结点的后一个结点就是需要删除的结点。</li></ol><p>以上的思路确实可以解决该问题，但是对链表进行了两次遍历，那么是否可以使用<strong>一次遍历</strong>完成呢？可以的。</p><p>这就需要使用快慢指针了：</p><ol type="1"><li>我们需要找到倒数<code>N</code>个结点，那么就需要寻找到第<code>Len-N</code>个结点；</li><li>首先让快指针先走，走出<code>N</code>步；</li><li>然后让慢指针和快指针保持相距<code>N</code>一起向前遍历，这时快指针还有<code>Len-N</code>步到达链尾，那么慢指针自然就还可以走<code>Len-N</code>步啦！</li></ol><h3 id="解题1">解题1</h3><p>这里我们同样需要对第一个结点进行讨论，所以直接引入头结点来解决。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用头结点</span></span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    dummy-&gt;next = head;</span><br><span class="line">    <span class="comment">// 快慢结点</span></span><br><span class="line">    ListNode *first = dummy, *second = dummy;</span><br><span class="line">    <span class="comment">// first先走n步</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// first和second保持相同的间距前进</span></span><br><span class="line">    <span class="comment">// first指向终点时second指向将要删除结点的前一个</span></span><br><span class="line">    <span class="keyword">while</span>(first-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">        second = second-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除（未释放空间）</span></span><br><span class="line">    second-&gt;next = second-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中间结点">中间结点</h2><p>再来看一下中间结点的问题，其实是相同的套路。</p><h3 id="题目2">题目2</h3><p>先来看一下题目<a href="https://leetcode-cn.com/problems/middle-of-the-linked-list">876. 链表的中间结点</a>：给定一个头结点为 head 的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。</p><p>示例1：</p><blockquote><p>输入：[1,2,3,4,5]</p><p>输出：此列表中的结点 3</p></blockquote><p>示例2：</p><blockquote><p>输入：[1,2,3,4,5,6]</p><p>输出：此列表中的结点 4</p></blockquote><h3 id="理解一下2">理解一下2</h3><p><strong>也不用理解！</strong>(狗头)</p><p>基本思路与上一题类似：</p><ol type="1"><li>先遍历一遍链表，得到链表的长度<code>Len</code>；</li><li>然后再从头遍历一遍到第<code>Len/2</code>个结点即可。</li></ol><p>这同样需要使用两次遍历，有了上面的经验我们自然可以想到使用快慢指针实现一次遍历：</p><ol type="1"><li>快指针和慢指针同时出发（与之前先后出发不同了）；</li><li>快指针一次走两个<code>next</code>，慢指针一次进行一次<code>next</code>，这样快指针走到最后，慢指针刚好走了快指针的一般路程。</li></ol><h3 id="题解2">题解2</h3><p>这里根据题目要求注意一下中间结点的定义即可。</p><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode * first = head, * second = head;</span><br><span class="line">    <span class="keyword">while</span>(first != <span class="literal">nullptr</span> &amp;&amp; first-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="comment">// 慢指针走一步，快指针走两步</span></span><br><span class="line">        second = second-&gt;next;</span><br><span class="line">        first = first-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="同样套路还有一个啦二合一">同样套路，还有一个啦（二合一）</h2><h2 id="环形链表">环形链表</h2><h3 id="题目3">题目3</h3><p><a href="https://leetcode-cn.com/problems/linked-list-cycle">141. 环形链表</a>和<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii">142. 环形链表 II</a>这两题类似。</p><p>141 给你一个链表的头节点 head ，判断链表中是否有环。</p><p>以及</p><p>142 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><h3 id="理解一下3">理解一下3</h3><p>也就是说需要判断链表是否有环，以及从哪个结点开始形成环。</p><p>那么我们首先需要知道如何判断环：</p><ol type="1"><li>容易发现，一旦使用指针在有环链表中进行遍历，那么遍历一定是没有终止；就像操场跑步一样，只要沿着400米的圈一直跑就没有尽头，但是沿着100米的直线跑却是有尽头的；</li><li>同样的，当我与你一起在<code>100 + 400n米</code>的操场上跑步，从我跑得慢，你跑得快，那么你是不是终究就会在某个点上超过我一圈！</li><li>因此我们同样可以使用快慢指针进行你追我赶，当然，补偿为1、2、3这种连续遍历，可能会超过K圈（整数倍），不过无所谓，<strong>你我终会相遇</strong>。</li></ol><p>然后如何判断在哪相遇呢？（你的速度是我的两倍）</p><ol type="1"><li>慢吞吞的我跑了<code>n</code>米，快吨吨的你跑了<code>2n</code>米，相遇时距离环起点也<code>m</code>米；</li><li>那么超过我的距离<code>n</code>一定是环的<strong>整数</strong>倍，所以你<strong>再</strong>跑<code>n-m</code>米就可以到达环起点，而我<strong>回到起点</strong>再跑<code>n-m</code>米也能到达环起点！</li><li>这里就不需要计数n了，保持相同速度跑，自然会在起点相遇，<strong>你我终会再次相遇</strong>。</li></ol><h3 id="题解3">题解3</h3><p>判断方法如下：</p><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    ListNode *first = head, *second = head;</span><br><span class="line">    <span class="comment">// 同样使用快慢指针，若存在环，那么快指针将会在环内与慢指针相遇</span></span><br><span class="line">    <span class="keyword">while</span>(first != <span class="literal">nullptr</span> &amp;&amp; first-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        first = first-&gt;next-&gt;next;</span><br><span class="line">        second = second-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(first == second)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>寻找环起点的方法如下：</p><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    ListNode *first = head, *second = head;</span><br><span class="line">    <span class="comment">// 标记是否相遇</span></span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(first != <span class="literal">nullptr</span> &amp;&amp; first-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        first = first-&gt;next-&gt;next;</span><br><span class="line">        second = second-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(second == first)&#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        <span class="comment">// 任意一个结点回到起点，同样速度跑</span></span><br><span class="line">        first = head;</span><br><span class="line">        <span class="keyword">while</span>(first != second)&#123;</span><br><span class="line">            first = first-&gt;next;</span><br><span class="line">            second = second-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="个人收获">个人收获</h2><p>这次的收获主要是头结点和快慢指针</p><ol type="1"><li>头结点使得每个结点都有直接前驱，可以避免单独处理第一个结点的问题，很好用的；</li><li>快慢指针可以用来解决一些与速度、距离有关的问题会有较好的处理方法，在后续的题目中多熟悉熟悉。</li></ol>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是关于单链表的双指针问题中的快慢指针问题，1.链表的倒数第 n 个结点；2.寻找链表中间结点；3. 判断是否有环。&lt;/p&gt;
&lt;p&gt;涉及 leetcode 的 &lt;a href=&quot;https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list&quot;&gt;19. 删除链表的倒数第 N 个结点&lt;/a&gt;、&lt;a href=&quot;https://leetcode-cn.com/problems/middle-of-the-linked-list&quot;&gt;876. 链表的中间结点&lt;/a&gt;、&lt;a href=&quot;https://leetcode-cn.com/problems/linked-list-cycle&quot;&gt;141. 环形链表&lt;/a&gt;和&lt;a href=&quot;https://leetcode-cn.com/problems/linked-list-cycle-ii&quot;&gt;142. 环形链表 II&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据结构算法" scheme="https://gipbear.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="c++" scheme="https://gipbear.github.io/tags/c/"/>
    
    <category term="单链表" scheme="https://gipbear.github.io/tags/%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    
    <category term="leetcode题解" scheme="https://gipbear.github.io/tags/leetcode%E9%A2%98%E8%A7%A3/"/>
    
    <category term="双指针" scheme="https://gipbear.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="快慢指针" scheme="https://gipbear.github.io/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>单链表解题技巧(1)——合并有序链表</title>
    <link href="https://gipbear.github.io/2022/01/05/%E5%8D%95%E9%93%BE%E8%A1%A8%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A71%E2%80%94%E2%80%94%E5%90%88%E5%B9%B6%E9%93%BE%E8%A1%A8/"/>
    <id>https://gipbear.github.io/2022/01/05/%E5%8D%95%E9%93%BE%E8%A1%A8%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A71%E2%80%94%E2%80%94%E5%90%88%E5%B9%B6%E9%93%BE%E8%A1%A8/</id>
    <published>2022-01-05T12:49:18.000Z</published>
    <updated>2022-01-10T09:31:19.591Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是关于单链表的合并问题，1.合并两个有序链表；2.合并k个有序链表（堆）。</p><p>涉及 leetcode 的 <a href="https://leetcode-cn.com/problems/merge-two-sorted-lists">21. 合并两个有序链表</a>和 <a href="https://leetcode-cn.com/problems/merge-k-sorted-lists">23. 合并K个升序链表</a>。</p></blockquote><span id="more"></span><h2 id="合并两个有序链表">合并两个有序链表</h2><h3 id="题目1">题目1</h3><p>首先来看题目<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists">21. 合并两个有序链表</a>：将两个升序链表合并为一个新的<strong>升序</strong>链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p>示例1：</p><blockquote><p>输入：l1 = [1,2,4], l2 = [1,3,4]</p><p>输出：[1,1,2,3,4,4]</p></blockquote><p>示例2：</p><blockquote><p>输入：l1 = [], l2 = [0]</p><p>输出：[0]</p></blockquote><h3 id="理解一下1">理解一下1</h3><p>题目的大概意思就是：</p><ol type="1"><li>将两个本身就有序（升序）的链表合并起来，得到一个新的链表依旧是有序的；</li><li>并且新的链表依旧使用原本链表中的结点，而不是创建新的结点。（也就是用next指针指来指去）。</li></ol><p>基本的思路是：</p><ol type="1"><li>首先创建一个链表头<code>res</code>来表示最终的链表；</li><li>然后分别使用两个指针指向链表<code>l1</code>和链表<code>l2</code>；</li><li>再比较<code>l1</code>和<code>l2</code>对应结点的值的大小，将小的结点连接到<code>res</code>中；</li><li><code>l1</code>和<code>l2</code>不断向后遍历，重复3，最后剩下没遍历完的就直接放在<code>res</code>后。</li></ol><h3 id="解题1">解题1</h3><p>以上的思路忽略了一些细节（n，n-1，1，0等这些边界问题），这里我们在处理第一个结点（无前结点）的时候还是需要分类讨论的，所以根据数据结构的定义，引入所谓的<code>头结点</code>，这样第一个结点就和其他结点都一样了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 头结点</span></span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    ListNode* p = dummy;</span><br><span class="line">    ListNode* p1 = list1, *p2 = list2;</span><br><span class="line">    <span class="comment">// 谁的结点小就将谁接在链表 dummy 后</span></span><br><span class="line">    <span class="keyword">while</span>(p1 &amp;&amp; p2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1-&gt;val &gt; p2-&gt;val)&#123;</span><br><span class="line">            p-&gt;next = p2;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            p-&gt;next = p1;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 跳出 while 循环的条件必然是至少一条链遍历结束了，那么剩下的一条的后续部分直接接在 dummy 中即可。</span></span><br><span class="line">    <span class="keyword">if</span>(p1)</span><br><span class="line">        p-&gt;next = p1;</span><br><span class="line">    <span class="keyword">if</span>(p2)</span><br><span class="line">        p-&gt;next = p2;</span><br><span class="line">    <span class="comment">// 题目需要返回的是没有头结点的，所以是 next。</span></span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合并k个有序链表">合并K个有序链表</h2><h3 id="题目2">题目2</h3><p>同样先看一下题目<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists">23. 合并K个升序链表</a>：给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p>示例1：</p><blockquote><p>输入：lists = [ [1,4,5],[1,3,4],[2,6] ]</p><p>输出：[1,1,2,3,4,4,5,6]</p></blockquote><p>示例2：</p><blockquote><p>输入：lists = [ ]</p><p>输出：[ ]</p></blockquote><h3 id="理解一下2">理解一下2</h3><p>就相当于之前是两个有序链表两两合并，现在是K个链表进行有序合并成一个有序链表。</p><p>基本的思路有两个：</p><h4 id="两两合并2">两两合并2</h4><p>第一种方法是在上一题的基础上，直接进行两两合并，得到有序链表，当然这里也有两种思路：一个是直接进行<code>k-1</code>次两两合并，另一个是使用<strong>归并</strong>两两合并，无非是时间换空间的问题（嗷，还有一个问题是归并我不熟练）。</p><p>这里提供我用第一个思路写的k-1次归并题解，其中<code>mergeTwoLists</code>函数就是之前的两两合并（好家伙，直接复制！）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 无链表</span></span><br><span class="line">    <span class="keyword">if</span>(lists.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 仅有一个链表</span></span><br><span class="line">    <span class="keyword">if</span>(lists.<span class="built_in">size</span>() == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// k-1 次两两合并</span></span><br><span class="line">    ListNode * res = lists[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lists.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        res = <span class="built_in">mergeTwoLists</span>(res,lists[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小根堆合并">小根堆合并</h4><p>第二种方法需要使用数据结构——<strong>小根堆</strong>（本质上是一棵完全二叉树），通过堆的性质进行合并，在很多外部排序的时候会采用这种方法，同样的也有两个思路：</p><ol type="1"><li>一个是将所有的链表所有的结点都<strong>一次性</strong>扔到堆中（显然需要空间极大），然后依次从堆顶取出结点链接到链表<code>dummy</code>中即可；</li><li>另一个是以<code>k</code>个链表的头结点构建大小为<code>k</code>的小根堆，堆顶的的结点就是最小结点，将其拿出链接到链表<code>dummy</code>中即可，并将该链上的<code>next</code>结点加入小根堆，并进行调整，直至堆中无结点即可。</li></ol><p>很明显<strong>小根堆合并</strong>比<strong>两两合并</strong>好多了，但是实际 coding 的时候其实并不一定能写出来（orz），所以这两种方法作为思路，并提供了一个<code>labuladong</code>的 java 题解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 虚拟头结点</span></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode p = dummy;</span><br><span class="line">    <span class="comment">// 优先级队列，最小堆</span></span><br><span class="line">    PriorityQueue&lt;ListNode&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(</span><br><span class="line">        lists.length, (a, b)-&gt;(a.val - b.val));</span><br><span class="line">    <span class="comment">// 将 k 个链表的头结点加入最小堆</span></span><br><span class="line">    <span class="keyword">for</span> (ListNode head : lists) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="keyword">null</span>)</span><br><span class="line">            pq.add(head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 获取最小节点，接到结果链表中</span></span><br><span class="line">        ListNode node = pq.poll();</span><br><span class="line">        p.next = node;</span><br><span class="line">        <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pq.add(node.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// p 指针不断前进</span></span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="个人收获">个人收获</h2><p>这里主要学到的是对k个链表进行合并的思路：</p><ol type="1"><li>两两合并的方法其实很常见，在ML中，对多分类问题也经常使用多次二分类进行实现，本质上感觉还是很相似的，好吧不是一回事，总之是将问题进行拆分，然后再一个一个解决，虽然暴力（O(NK)），但是起码能够解决问题，不至于完全写不出来。</li><li>对于小根堆其实也是比较熟悉了，在数据结构中小根堆的<strong>画图</strong>我可是熟悉的一塌糊涂（除了考试没啥用），但是代码上就显得比较不熟练了，之后在树的这一个模块中再好好练一练。这个可以很好的降低时间的复杂度，相应的付出一些时间，不过效果要比两两合并好多（O(Nlogk)）。</li></ol>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是关于单链表的合并问题，1.合并两个有序链表；2.合并k个有序链表（堆）。&lt;/p&gt;
&lt;p&gt;涉及 leetcode 的 &lt;a href=&quot;https://leetcode-cn.com/problems/merge-two-sorted-lists&quot;&gt;21. 合并两个有序链表&lt;/a&gt;和 &lt;a href=&quot;https://leetcode-cn.com/problems/merge-k-sorted-lists&quot;&gt;23. 合并K个升序链表&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据结构算法" scheme="https://gipbear.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="c++" scheme="https://gipbear.github.io/tags/c/"/>
    
    <category term="单链表" scheme="https://gipbear.github.io/tags/%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    
    <category term="leetcode题解" scheme="https://gipbear.github.io/tags/leetcode%E9%A2%98%E8%A7%A3/"/>
    
    <category term="k路问题" scheme="https://gipbear.github.io/tags/k%E8%B7%AF%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
</feed>
