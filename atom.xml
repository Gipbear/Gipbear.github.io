<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Grizzly&#39;s daily</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-01-15T16:41:06.038Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Grizzly</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>机器学习西瓜书——第03章线性模型</title>
    <link href="http://example.com/2022/01/14/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E2%80%94%E2%80%94%E7%AC%AC03%E7%AB%A0%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/"/>
    <id>http://example.com/2022/01/14/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E2%80%94%E2%80%94%E7%AC%AC03%E7%AB%A0%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/</id>
    <published>2022-01-14T10:35:28.000Z</published>
    <updated>2022-01-15T16:41:06.038Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是关于周志华老师编写的机器学习书籍『西瓜书』的第三章线性模型.</p><p>主要的内容有: 线性回归的基本形式、最小二乘法、广义线性回归、对数几率回归（逻辑回归）、最大似然估计和分类数据连续化等.</p></blockquote><span id="more"></span><h2 id="基本形式">3.1 基本形式</h2><p>线性模型(linear model)是一个通过属性的线性组合来进行预测的函数, 形如:</p><p><span class="math display">\[f(x) = w_{1}x_{1} + x_{2}w_{2} + \dots + w_{d}x_{d} + b\]</span></p><p>其中<span class="math inline">\(x_i\)</span>表示第<span class="math inline">\(i\)</span>个属性值.</p><p>容易发现, 每个<span class="math inline">\(w_i\)</span>都表示了属性的权重, 这使得建立的模型有很好的<strong>可解释性</strong>(comprehensibility).</p><p>一般可以写成<strong>向量</strong>形式:</p><p><span class="math display">\[f(x) = \boldsymbol{w}^{T}\boldsymbol{x} + b\]</span></p><p>那么我们的目的就是学习得到<span class="math inline">\(\boldsymbol{w}\)</span>和<span class="math inline">\(b\)</span>来确定模型.</p><h2 id="线性回归">3.2 线性回归</h2><p>线性回归是来学习一个线性模型, 来预测<strong>连续值</strong>. 使得预测的连续值<span class="math inline">\(f(x_i)\)</span>尽可能是与真实值<span class="math inline">\(y_i\)</span>接近, 即, 使得<span class="math inline">\(f(x_i) \approxeq y_{i}\)</span>.</p><h3 id="最小二乘法">最小二乘法</h3><p>那么我们如何来衡量<span class="math inline">\(f(x_i)\)</span>与<span class="math inline">\(y_i\)</span>之间的差距呢, 这时候可以上文提过的<a href="https://gipbear.github.io/2022/01/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E2%80%94%E2%80%94%E7%AC%AC02%E7%AB%A0%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E5%92%8C%E9%80%89%E6%8B%A9/#%E6%80%A7%E8%83%BD%E5%BA%A6%E9%87%8F">均方误差(MSE)</a>来衡量<span class="math inline">\(f(x_i)\)</span>与<span class="math inline">\(y_i\)</span>之间的差距. 并使其最小化, 就可以得到我们先想要的<span class="math inline">\(\boldsymbol{w}\)</span>和<span class="math inline">\(b\)</span>:</p><p><span class="math display">\[\begin{aligned}(w^*, b^*)&amp;= \argmin_{(\boldsymbol{w}, b)}{\sum^m_{i=1}{(f(x_i)-y_i)^2}} \\&amp;= \argmin_{(\boldsymbol{w}, b)}{\sum^m_{i=1}{(y_i-wx_i-b)^2}}\end{aligned}\]</span></p><blockquote><p>这就是<strong>最小二乘法</strong>(least square method): 使用均方误差这个具有几何意义的<strong>欧氏距离</strong>来度量差距.</p></blockquote><p>OK, 那么我们下一步就是如何求解<span class="math inline">\(E_{(w,b)}= {\sum^m_{i=1}{(y_i-wx_i-b)^2}}\)</span>最小值了, 这一步叫做最小二乘的<strong>参数估计</strong>(parameter estimate), 对<span class="math inline">\(\boldsymbol{w}\)</span>和<span class="math inline">\(b\)</span>和b分别求偏导, 并令为零可以得到<span class="math inline">\(\boldsymbol{w}\)</span>和<span class="math inline">\(b\)</span>的最优解:</p><p><span class="math display">\[w = \frac{\sum\limits^m_{i=1}{y_i(x_i-\bar{x})}}{\sum\limits^m_{i=1}{x_i^2}-\frac{1}{m}(\sum\limits^m_{i=1}{x_i})^2}\]</span></p><p><span class="math display">\[b = \frac{1}{m}\sum^m_{i=1}{(y_i-wx_i)}\]</span></p><h3 id="矩阵形式">矩阵形式</h3><p>当我们将数据扩展为矩阵形式, 把<span class="math inline">\(\boldsymbol{w}\)</span>和<span class="math inline">\(b\)</span>写入向量形式<span class="math inline">\(\boldsymbol{w} = (\boldsymbol{w}, b)\)</span>, 相应地, 把数据集<span class="math inline">\(D\)</span>表示为一个<span class="math inline">\(m*(d+1)\)</span>大小的矩阵<span class="math inline">\(\boldsymbol{X}\)</span>, 其中每一行代表一个实例，每行前d个元素对应实例中的d个属性, 最后一个元素恒为1. <span class="math display">\[\boldsymbol{X} =\begin{pmatrix}x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1d} &amp; 1 \\x_{21} &amp; x_{22} &amp; \cdots &amp; x_{2d} &amp; 1 \\\vdots &amp; \vdots &amp;  &amp; \vdots &amp; \vdots \\x_{m1} &amp; x_{m2} &amp; \cdots &amp; x_{md} &amp; 1 \\\end{pmatrix} =\begin{pmatrix}\boldsymbol{x_1}^T &amp; 1 \\\boldsymbol{x_2}^T &amp; 1 \\\vdots &amp; \vdots \\\boldsymbol{x_m}^T &amp; 1 \\\end{pmatrix}\]</span></p><p>再将输入也写成向量形式</p><p><span class="math display">\[\boldsymbol{y} = (y_1, y_2, \cdots, y_m)\]</span></p><p>根据均方差误差最小化原则有:</p><p><span class="math display">\[\boldsymbol{w}^\ast = arg \min_w(\boldsymbol{y}-\boldsymbol{X}\boldsymbol{w})^T(\boldsymbol{y}-\boldsymbol{X}\boldsymbol{w})\]</span></p><p>令<span class="math inline">\(\boldsymbol{E_w} = (\boldsymbol{y}-\boldsymbol{X}\boldsymbol{w})^T(\boldsymbol{y}-\boldsymbol{X}\boldsymbol{w})\)</span>, 对<span class="math inline">\(\boldsymbol{w}\)</span>求导得到</p><p><span class="math display">\[\frac{\partial\boldsymbol{E_w}}{\partial\boldsymbol{w}} = 2\boldsymbol{X}^{T}(\boldsymbol{X}\boldsymbol{w}-\boldsymbol{y})\]</span></p><p>令其为零可得到<span class="math inline">\(\boldsymbol{W}\)</span>的最优解的闭式解。</p><p>以上是当矩阵<span class="math inline">\(X^TX\)</span><strong>满秩(可逆)</strong>时进行的计算, 而实际中, 很多的数据矩阵是<strong>非满秩</strong>的, 则有可能会解出多个解, 那么选择解由学习算法的归纳偏好决定, 常见做法是引入<strong>正则化</strong>.</p><h3 id="广义线性回归">广义线性回归</h3><p>以上我们针对的是一个简单线性回归的模型, 显然预测得到的标记一定是一个线性的结果.</p><blockquote><p>此时我们实验中获得了一组数据, 通过观察是符合<strong>指数</strong>函数形式的, 很明显是一个非线性的标记序列, 那这时是否可以使用线性回归呢?</p></blockquote><p>答案是可以的.</p><p>我们对标记<span class="math inline">\(y\)</span>取<code>ln函数</code>, 这时就会发现:</p><p><span class="math display">\[\ln{y} = \boldsymbol{w}^{T}\boldsymbol{x} + b\]</span></p><p>这就是<strong>对数线性回归</strong>, 在形式上我们可以使用线性回归进行表示, 但本质上却实现了非线性回归. 发生这时神奇变化的东西就是<code>ln</code>这个<strong>单调可微函数</strong>.</p><p>由此推到<strong>广义线性模型</strong>(generalized linear model), 使用单调可微函数<span class="math inline">\(g(\cdot)\)</span>来将预测值和实际值联系起来.</p><p><span class="math display">\[y = g^{-1}(\boldsymbol{w}^{T}\boldsymbol{x} + b)\]</span></p><h2 id="对数几率回归">对数几率回归</h2><p><strong>对数几率回归</strong>也就是我们之前经常听说的<strong>逻辑回归</strong>. 但是逻辑(logistic)其实并不合适, 而对数几率(log odds, logit)才是这个模型的本质, 下面详细介绍.</p><p>我们在上面所提到的广义线性回归中, 使用一个特定的函数来代替单调可微函数<span class="math inline">\(g^{-1}(\cdot)\)</span>——<strong>sigmoid函数</strong>.</p><p><span class="math display">\[y = \frac{1}{1+e^{-z}}\]</span></p><figure><img src="./机器学习西瓜书——第03章线性模型/单位阶跃函数与对数几率函数.png" alt="单位阶跃函数与对数几率函数.png" /><figcaption aria-hidden="true">单位阶跃函数与对数几率函数.png</figcaption></figure><p>这是一个形如s型曲线的图像, 通过设置不同的<strong>阈值</strong>, 使得取值被划分为0或1, 所以这也是为什么虽然叫做回归函数, 却经常被用作<strong>分类</strong>.</p><h3 id="模型的表示">模型的表示</h3><p>将线性模型带入sigmoid函数中, 可以得到:</p><p><span class="math display">\[y = \frac{1}{1+e^{-(\boldsymbol{w}^{T}\boldsymbol{x} + b)}}\]</span></p><p>通过变化得到:</p><p><span class="math display">\[\ln{\frac{y}{1-y}} = \boldsymbol{w}^{T}\boldsymbol{x} + b\]</span></p><p>此时很关键的一步:</p><ul><li>将<span class="math inline">\(y\)</span>视作样本<span class="math inline">\(\boldsymbol{x}\)</span>为正例的可能性, 用后验概率表示为<span class="math inline">\(p(y=1|\boldsymbol{x})\)</span>;</li><li>将<span class="math inline">\(1-y\)</span>视作样本<span class="math inline">\(\boldsymbol{x}\)</span>为反例的可能性, 用后验概率表示为<span class="math inline">\(p(y=0|\boldsymbol{x})\)</span>.</li></ul><blockquote><p>我们所谓的"几率"就是<span class="math inline">\(\frac{y}{1-y}\)</span>, <strong>反映了x作为正例的相对可能性</strong>. 再取对数, 所以就称为对数几率!</p></blockquote><h3 id="求解策略">求解策略</h3><p>那么问题回到如何确定模型中的<span class="math inline">\(\boldsymbol{w}\)</span>和<span class="math inline">\(b\)</span>呢? 我们这里使用<strong>最大似然估计</strong>来解释, 同样的还可以使用信息论的角度来解释.</p><p>根据以上的内容, 可以将模型表达写成:</p><p><span class="math display">\[p(y=1|\boldsymbol{x}) = \frac{e^{\boldsymbol{w}^{T}\boldsymbol{x} + b}}{1+e^{\boldsymbol{w}^{T}\boldsymbol{x} + b}}\]</span></p><p><span class="math display">\[p(y=0|\boldsymbol{x}) = \frac{1}{1+e^{\boldsymbol{w}^{T}\boldsymbol{x} + b}}\]</span></p><p>通过极大似然估计法, 并取对数就可以得到:</p><p><span class="math display">\[\begin{aligned}L(\boldsymbol{w}, b) &amp;= \prod^m_{i=1}{p(y_i|\boldsymbol{x}_i;w,b)} \\l(\boldsymbol{w}, b) &amp;= \sum^m_{i=1}{\ln{[y_ip_1(\hat{\boldsymbol{x}}_i;\boldsymbol{w}, b) + (1-y_i)p_0(\hat{\boldsymbol{x}}_i;\boldsymbol{w}, b)]}}\end{aligned}\]</span></p><p>其中<span class="math inline">\(p_1\)</span>是<span class="math inline">\(p(y=1|\boldsymbol{x};\boldsymbol{w}, b)\)</span>, <span class="math inline">\(p_0\)</span>是<span class="math inline">\(p(y=0|\boldsymbol{x};\boldsymbol{w}, b)\)</span>.</p><p>为了便于讨论, 令<span class="math inline">\(\beta=(\boldsymbol{x};b), \hat{\boldsymbol{x}}=(\boldsymbol{x};1)\)</span>, 使得<span class="math inline">\(\boldsymbol{w}^{T}\boldsymbol{x} + b\)</span>可以表示为<span class="math inline">\(\beta^T\boldsymbol{x}\)</span>. 再分别令<span class="math inline">\(y_i\)</span>为0或1:</p><p><span class="math display">\[l(\beta) =\begin{cases}\sum\limits^m_{i=1}{- \ln{(1+e^{\beta^T\boldsymbol{x}_i})}}, \qquad &amp;y_i = 0 \\\sum\limits^m_{i=1}{\beta^T\boldsymbol{x}_i - \ln{(1+e^{\beta^T\boldsymbol{x}_i})}}, \qquad &amp;y_i = 1\end{cases}\]</span></p><p>综合可得如下式子, 并且将其取负数得最小化:</p><p><span class="math display">\[l(\beta) = -\sum^m_{i=1}{[y_i\beta^T\boldsymbol{x}_i - \ln{(1+e^{\beta^T\boldsymbol{x}_i})}]}\]</span></p><p>这就是关于<span class="math inline">\(\beta\)</span>的高阶可导凸函数, 使用梯度下降等优化理论方法进行求解即可.</p><h3 id="模型的优点">模型的优点</h3><ol type="1"><li>该模型直接对分类的可能性进行建模, 也没有要求数据分布, 避免假设数据分布带来的不确定性问题;</li><li>而且得到了近似概率预测, 对许多需要利用概率辅助决策的任务有很大的帮助;</li><li>求解的目标函数是任意阶可导的凸函数, 有很好的数学性质, 许多值优化算法都可以用来求解最优解.</li></ol><h2 id="其他">其他</h2><h3 id="分类变量化为连续值">分类变量化为连续值</h3><p>有时我们的有些数据可能是离散的, 这时候我们会考虑将数据化为<strong>连续值</strong>.</p><ul><li>在<strong>有序</strong>(order)数据中, 比如"低" "中" "高"等, 可以使用<span class="math inline">\(\{0, 0.5, 1\}\)</span>来表示.<ul><li>直接使用<code>map</code>映射, 或使用<code>LabelEncoder</code>.</li></ul></li><li>在<strong>无序</strong>数据中, 比如"西瓜" "南瓜" "冬瓜"等, 就需要使用<span class="math inline">\((1,0,0), (0,1,0), (0,0,1)\)</span>来表示.<ul><li>独热编码<code>OneHotEncoder</code>或 pandas 中的<code>get_dummies</code>.</li></ul></li></ul><blockquote><p>无序属性在连续化的时候, 不能像连续值一样直接使用值代替, 因为值之间存在大小, 从而会引入<strong>不当的有序关系</strong>.</p><p>但其实对分类变量化为连续值, 或多或少会引入一些额外的有序关系.</p></blockquote><h2 id="个人收获">个人收获</h2><ol type="1"><li>从单纯的线性模型, 推广到广义的线性模型, 再引出特殊的对数几率回归模型. 从特殊到一般再到特殊的方式, 很好的理清楚了简单线性回归和逻辑回归之间的关系.</li><li>逻辑回归真正的名字应该是对数几率回归, 这对记忆和理解模型都有更好的可解释性.</li><li>公式的推导依旧有难度, 目前处于抛开书想不到怎么推, 但结合西瓜书和南瓜书还是能够看懂推导过程.</li></ol><p>继续加油!</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是关于周志华老师编写的机器学习书籍『西瓜书』的第三章线性模型.&lt;/p&gt;
&lt;p&gt;主要的内容有: 线性回归的基本形式、最小二乘法、广义线性回归、对数几率回归（逻辑回归）、最大似然估计和分类数据连续化等.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="机器学习" scheme="http://example.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="西瓜书" scheme="http://example.com/tags/%E8%A5%BF%E7%93%9C%E4%B9%A6/"/>
    
    <category term="线性模型" scheme="http://example.com/tags/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>机器学习西瓜书——第02章模型评估和选择</title>
    <link href="http://example.com/2022/01/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E2%80%94%E2%80%94%E7%AC%AC02%E7%AB%A0%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E5%92%8C%E9%80%89%E6%8B%A9/"/>
    <id>http://example.com/2022/01/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E2%80%94%E2%80%94%E7%AC%AC02%E7%AB%A0%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E5%92%8C%E9%80%89%E6%8B%A9/</id>
    <published>2022-01-11T11:36:17.000Z</published>
    <updated>2022-01-14T13:36:08.574Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是关于周志华老师编写的机器学习书籍『西瓜书』的第二章模型评估和选择.</p><p>主要的内容有: 经验误差与过拟合、模型的评估方法(留出法/交叉验证/自助法)、性能度量(查准率/查全率/F1/ROC曲线等), 部分内容待更新.</p></blockquote><span id="more"></span><h2 id="经验误差与过拟合">2.1 经验误差与过拟合</h2><h3 id="误差">误差</h3><p><strong>错误率</strong>: 分类错误的样本数 <span class="math inline">\(a\)</span> 占样本总数 <span class="math inline">\(m\)</span> 的比例称为"错误率"(error rate).</p><p><span class="math display">\[error rate = \frac{a}{m}\]</span></p><p>与之相对的是<strong>精度</strong>(accuracy):</p><p><span class="math display">\[accuracy = 1 - \frac{a}{m}\]</span></p><p>学习器在训练集上的误差称为<strong>训练误差</strong>(training error)或<strong>经验误差</strong>(empirical error); 而在新样本上的误差称为<strong>泛化误差</strong>(generalization error).</p><blockquote><p>我们最『想』得到『泛化误差』尽可能的小, 但是我们在训练的时候并不知道新样本, 所以『实际上』能做的是使得『经验误差』尽可能的小.</p></blockquote><h3 id="过拟合">过拟合</h3><p>当我们训练模型学习训练样本的时候, 将训练样本学的"太好", 除了学习到数据集的普遍规律, 还将训练数据集的一些自身特点学习到了, 导致泛化性能下降, 这种现象称为<strong>过拟合</strong>(overfitting); 反之就是<strong>欠拟合</strong>(underfitting), 训练样本的普遍规律也没有学会.</p><blockquote><p>简单来说就是: 只会硬板照抄的学生 和 不好好学习的后进生.</p></blockquote><p>欠拟合是学习的不够好, 一般来说比较好解决, 例如在决策树中扩展分支, 在神经网络中增加训练轮数等.</p><p>但是过拟合却是<strong>不可避免的</strong>, 只能做到缓解和减小其风险. 因为机器学习面临的问题是NP难, 但是有效算法是在有限时间内完成的, 不能完成 <span class="math inline">\(NP=P\)</span> 的证明.</p><p>那么, 实际上有各种算法以及各种参数来训练模型, 如何选择? 这就是模型选择; 如何评估模型训练的好坏呢? 这就模型评估.</p><h2 id="评估方法">2.2 评估方法</h2><p>通过实验, 设置测试组对学习器的泛化误差来对模型进行选择. 需要一个测试集(testing set), 在学习器上得到的测试误差(testing error)与泛化误差近似.</p><blockquote><p>保证测试集中的数据尽可能未在训练集中出现.</p></blockquote><p>那么对于一个包含m个样本数据集D, 既要训练, 又要测试, 那么需要合适的划分方法得到训练集和测试集.</p><h3 id="留出法hold-out">留出法(hold-out)</h3><p>留出法<strong>直接</strong>将数据集<strong>划分</strong>为两个互斥的集合, 一个作为训练集S, 一个作为测试集T.</p><p>需要注意的是: 训练集和测试集的划分要尽可能的保持<strong>数据分布一致</strong>, 避免因为数据划分过程引入额外的偏差, 从而对最终的结果产生影响.</p><blockquote><p>例如将男性的数据集作为训练集, 然后去评估女性的数据集得到的泛化误差, 很明显是不合理的. 应尽量保持男女同比例.</p></blockquote><p>一般划分数据的时候保留类别比例, 通常称为"分层采样"(stratified sampling). 虽然按照比例进行划分比较合适, 但是依旧可能会出现一些问题.</p><blockquote><p>例如购物消费数据降序排序, 划分前70%作为训练集,后30%作为测试集. 虽然此时男女比例可能是等比例划分的, 但是消费能力却是截然不同, 所以这种方式显然还欠缺考虑.</p></blockquote><p>所以在使用留出法的时候, 通常使用<strong>若干次随机抽样</strong>的方式进行划分, 然后对这几次的评估数据<strong>取均值</strong>.</p><p>以上是为了更好使用留出法的一些方法, 但是留出法本身有一个<strong>固有缺陷</strong>: 训练集S较大时, 模型可以训练的更接近数据集D的模型, 但测试集T较小, 导致评估结果不够稳定; 若测试集T大了, 那么训练集S训练出的模型可能和数据集D差别较大, 从而降低了评估结果的保真性(fidelity).</p><p>但是也没有完美的解决方法, 一般划2/3~4/5进行训练, 剩余作为测试.</p><h3 id="交叉验证cross-validation">交叉验证(cross validation)</h3><p>先将数据集划分为k个大小相同的互斥子集, 每个子集尽可能保持数据分布的一致性(分层抽样). 每次使用k-1个子集进行训练, 剩下的一个子集作为测试集. 从而获得k次测试结果并取均值. 所以通常也称为<strong>k-折交叉验证</strong>(k-fold cross validation).</p><p>同样的, 为减小样本划分带来的影响, 通常使用p次随机划分, 然后取这p次k折交叉验证结果的均值.</p><blockquote><p>其中, 若令k=m,那么则会得到<strong>留一法</strong>(Leave-One-Out, LOO), 显然由于划分唯一, 不受随机划分的影响. 实际效果和训练集几乎相似, 但是同样有一个固有缺陷: 数据集较大时, 训练时间开销太大.</p><p>所以: <strong>没有免费的午餐</strong>定理同样适用.</p></blockquote><h3 id="自助法bootstrapping">自助法(bootstrapping)</h3><p>对给定的包含m个样本的数据集D, 进行m次<strong>抽样放回</strong>的过程, 得到数据集D'. 这个过程会使得某些样本可能会出现多次, 而某些样本却不会出现. 简单估计始终不被抽样的概率是<span class="math inline">\((1-\frac{1}{m})^m\)</span>, 取极限得到:</p><p><span class="math display">\[\lim_{m\rightarrow \infin}{(1-\frac{1}{m})^m} \rightarrowtail \frac{1}{e} \approx 0.368\]</span></p><p>将未出现约36.8%的数据作为测试集即可, 那么训练模型的时候使用m个样本作为训练集,测试集依旧有约1/3的数据作为测试.</p><blockquote><p>在数据集较小, 难以有效划分的时候比较有效.</p><p>并能从初始数据集中产生多个不同的训练集, 对于集成学习等方法有很大好处.</p></blockquote><p>但在划分的时候改变了初始数据集的分布, 引入估计偏差, 所以在数据量足够的时候, 留出法和交叉验证更常用.</p><h3 id="调参与最终模型">调参与最终模型</h3><p>大部分的学习算法都需要一些参数进行设定, 参数的配置不同, 学习的模型往往有显著差距, 对参数(parameter)进行设定的过程称为参数调节或调参(parameter tuning).</p><p>参数是在一定范围内进行取值, 并根据一定的步长进行调节. 那么我们最终的参数也只可能在我们划分的<strong>离散值</strong>中, 往往不一定能够达到"最佳", 但这也平衡了开销和性能.</p><p>我们的调参是根据训练集S进行调参的, 最终的模型应该更根据选定的参数在<strong>完整的数据集</strong>中进行测试, 将最终的结果进行提交.</p><blockquote><p>通常将实际中遇到的数据称为测试数据, 而模型评估和选择中使用的数据集称为<strong>验证集</strong>(validation set).</p></blockquote><h2 id="性能度量">2.3 性能度量</h2><p>那么对机器学习训练泛化性能的评估, 就是接下来的性能度量(performance measure). 不同的性能度量得到的评判标准也不同, 所以模型的"好坏"是相对的, 取决于算法和数据, 还取决于模型的任务需求.</p><p>回归任务常用<strong>均方误差</strong>(mean squared error, MSE):</p><p><span class="math display">\[E(f; D) = \frac{1}{m} \sum^m_{i=1}{(f(x_i)-y_i)^2}\]</span></p><p>其中, <span class="math inline">\(f(x_i)\)</span>是模型对样本<span class="math inline">\(x_i\)</span>的预测, <span class="math inline">\(y_i\)</span>是真实标记.</p><h3 id="查准率查全率与f1">查准率、查全率与F1</h3><p>我们关心的问题有时候不仅仅是错误率或精度.</p><blockquote><p>例如我们不关心有多少比例的瓜判断错误, 而更加关心挑出的西瓜中有多少的比例是好瓜.</p></blockquote><p>此时就引入了查准率(precision)和查全率(recall):</p><ul><li><strong>查准率</strong>: 预测为正例中有多少是真的正例;</li><li><strong>查全率</strong>: 实际为正例的有多少被预测为正例.</li></ul><p>对于二分类问题, 可将结果分为: 真正例(true positive)、假正例(false positive)、真反例(true negative)和假反例(false negative). 由此组成<strong>混淆矩阵</strong>(confusion matrix).</p><img src="/2022/01/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E2%80%94%E2%80%94%E7%AC%AC02%E7%AB%A0%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E5%92%8C%E9%80%89%E6%8B%A9/%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5.png" class="" title="混淆矩阵.png"><p><span class="math display">\[查准率P = \frac{TP}{TP+FP}\]</span></p><p><span class="math display">\[查全率R = \frac{TP}{TP+FN}\]</span></p><p>这两个度量往往相互制约, 总是一高一低.</p><p>我们对学习器的预测样例的结果进行排序, 排在前面的样例认为是"最可能"为正例的样本, 按顺序逐个把样本作为正例进行预测, 则每个可计算出当前的查全率和查准率. 以此作为坐标轴可以绘制"P-R曲线".</p><img src="/2022/01/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E2%80%94%E2%80%94%E7%AC%AC02%E7%AB%A0%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E5%92%8C%E9%80%89%E6%8B%A9/P-R%E5%9B%BE.png" class="" title="P-R图.png"><p>根据曲线, 我们可以发现A和B曲线<strong>包含</strong>C曲线, 那么可以认为训练得到曲线C的模型相对较差; 而A和B曲线发生了<strong>交叉</strong>, 那么性能的优劣则不好判断.</p><p>引入"平衡点"(Break-Event Point, BEP)的概念, 在『查全率=查准率』处取得平衡点, 那么可以认为 A 优于 B.(挺草率的说)</p><p>更常用的是F1常量:</p><p><span class="math display">\[F1 = 2 \times \frac{1}{\frac{1}{P} + \frac{1}{R}} = \frac{2 \times P \times R}{P + R}\]</span></p><p>在特定场景, 模型对于查全率和查准率的要求不同, 所以会赋予不同的权重来进行调整, 使得更符合模型的需求.</p><p><span class="math display">\[F_\beta = \frac{(1+\beta^2) \times P \times R}{(\beta^2 \times P) + R}\]</span></p><h4 id="多分类">多分类</h4><p>以上是针对二分类问题提出了混淆矩阵, 那么对于多分类问题呢?</p><p>一种方法是两两形成混淆矩阵, 先计算得到各自的查全率和查准率, <strong>再将取均值</strong>, 得到"宏查准率"(macro-P)和"宏查全率"(macro-R), 再计算"宏F1"(macro-F1).</p><p>还有一种方法是各个混淆矩阵元素<strong>先取均值</strong>, 得到TP、FP、TN、FN的均值, 然后再基于这些均值计算得到"微查准率"(micro-P)和"微查全率"(micro-R), 再计算"微F1"(micro-F1).</p><h3 id="roc与auc">ROC与AUC</h3><p>很多的学习器是为了产生一个预测实值或概率预测, 然后将该概率预测与一个分类<strong>阈值</strong>(threshold)进行比较, 对测试样本进行排序, 最有可能的正例排在前面, 最不可能的正例排在最后面, 通过阈值将样本分为两部分.</p><p>一般情况下, 我们根据任务需求来采用不同的截断点. 更重视"查准率", 则选择排序靠前的位置进行截断, 更重视"查全率", 则选择排序靠后的位置进行截断. 那么对<strong>排序质量</strong>的好坏直接影响了学习器在不同任务下的<strong>泛化性能</strong>的好坏. ROC曲线就是来研究学习器泛化性能的有力工具.</p><p>『ROC曲线』原理与『P-R曲线』类似, 对学习器的预测样例的结果进行排序, 排在前面的样例认为是"最可能"为正例的样本, 按顺序逐个把样本作为正例进行预测, 则每个可计算出当前的<strong>真正例率</strong>(True Positive Rate, TPR)和<strong>假正例率</strong>(False Positive Rate, FPR):</p><ul><li>真正例率: 实际正例预测为正例的数量占所有实际正例的比例;</li><li>假正例率: 实际反例预测为正例的数量占所有实际反例的比例.</li></ul><p><span class="math display">\[TPR = \frac{TP}{TP + FN}\]</span></p><p><span class="math display">\[FPR = \frac{FP}{TN + FP}\]</span></p><img src="/2022/01/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E2%80%94%E2%80%94%E7%AC%AC02%E7%AB%A0%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E5%92%8C%E9%80%89%E6%8B%A9/ROC%E6%9B%B2%E7%BA%BF%E4%B8%8EAUC.png" class="" title="ROC曲线与AUC.png"><p>如果要比较不同学习器的优劣, 就看ROC曲面下的<strong>面积AUC</strong>(Area Under ROC Curve).</p><h3 id="代价敏感错误率与代价曲线">代价敏感错误率与代价曲线</h3><p>// todo</p><h2 id="比较检验">2.4 比较检验</h2><p>假设检验</p><p>交叉验证 t 检验</p><p>McNemar 检验</p><p>Friedman 检验与 Nemenyi 后续检验</p><h2 id="偏差与方差">2.5 偏差与方差</h2><h2 id="个人收获">个人收获</h2><p>这一章主要是在讲如何对数据集进行划分, 如何评估模型的性能, 包括我还没完全捋清楚的假设检验部分, 都是在对模型性能的好坏进行评价, 对模型的可行性, 真实性进行分析.</p><p>这些东西正是之后支撑我们来判断一个模型是好是坏, 是否可行的依据. 目前只是大概的了解了概念, 到了实际应用的时候还是要回过头来回顾前两章.</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是关于周志华老师编写的机器学习书籍『西瓜书』的第二章模型评估和选择.&lt;/p&gt;
&lt;p&gt;主要的内容有: 经验误差与过拟合、模型的评估方法(留出法/交叉验证/自助法)、性能度量(查准率/查全率/F1/ROC曲线等), 部分内容待更新.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="机器学习" scheme="http://example.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="西瓜书" scheme="http://example.com/tags/%E8%A5%BF%E7%93%9C%E4%B9%A6/"/>
    
    <category term="模型评估" scheme="http://example.com/tags/%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0/"/>
    
  </entry>
  
  <entry>
    <title>单链表解题技巧4——反转链表</title>
    <link href="http://example.com/2022/01/11/%E5%8D%95%E9%93%BE%E8%A1%A8%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A74%E2%80%94%E2%80%94%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2022/01/11/%E5%8D%95%E9%93%BE%E8%A1%A8%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A74%E2%80%94%E2%80%94%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
    <published>2022-01-11T10:44:35.000Z</published>
    <updated>2022-01-11T11:20:17.403Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是关于单链表的反转问题, 存在反转全部链表和部分区间链表的情况.</p><p>涉及 leetcode 的<a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a>和<a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II</a>.</p></blockquote><span id="more"></span><h2 id="反转链表">反转链表</h2><h3 id="题目1">题目1</h3><p>首先来看题目<a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a>: 给你单链表的头节点 head , 请你反转链表, 并返回反转后的链表.</p><p>示例1:</p><blockquote><p>输入: head = [1,2,3,4,5]</p><p>输出: [5,4,3,2,1]</p></blockquote><p>示例2:</p><blockquote><p>输入: head = []</p><p>输出: []</p></blockquote><h3 id="理解一下1">理解一下1</h3><p>反转很好理解, 链表本来是指向其<strong>唯一后继</strong>, 现在只不过是去指向其<strong>唯一前趋</strong>.</p><p>基本的思路是:</p><ol type="1"><li>需要三个指针, 一个指向前趋, 一个指向当前结点, 一个指向后继;</li><li>然后循环迭代, 变换指针的移动即可.</li></ol><p>以上的是最基本的迭代思维, 那么尝试使用递归的思想来解决呢?</p><ol type="1"><li>首先递归反转某个结点后的所有链表;</li><li>直至base case: 空链或唯一结点;</li><li>然后将反转后的链表与该结点连接上即可.</li></ol><h3 id="解题1">解题1</h3><p>首先是迭代的算法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode *h = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode * p = head, *q = head;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">nullptr</span> &amp;&amp; p-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        p-&gt;next = h;</span><br><span class="line">        h = p;</span><br><span class="line">        p = q;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = h;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是递归的解法, 最后三行不好理解的话画个图就知道了:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用last指向翻转head后的链表</span></span><br><span class="line">    ListNode *last = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">    <span class="comment">// 这里需要画个图才能解释</span></span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    <span class="comment">// 最后head去指向空</span></span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反转部分链表">反转部分链表</h2><h3 id="题目2">题目2</h3><p>首先来看题目<a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II</a>: 给你单链表的头指针 head 和两个整数 left 和 right, 其中 left &lt;= right . 请你反转从位置 left 到位置 right 的链表节点, 返回<strong>反转后的链表</strong>.</p><p>示例1:</p><blockquote><p>输入: head = [1,2,3,4,5], left = 2, right = 4</p><p>输出: [1,4,3,2,5]</p></blockquote><p>示例2:</p><blockquote><p>输入: head = [5], left = 1, right = 1</p><p>输出: [5]</p></blockquote><h3 id="理解一下2">理解一下2</h3><p>与上一题不同的是, 这题需要将链表的部分区间进行翻转, 这就需要将链表分为三个部分处理: 前部分-翻转部分-后部分, 这会显得比较麻烦.</p><p>那么我们考虑一个问题: <strong>反转链表前N个结点</strong>, 那么链表就只需要分为: 翻转部分-后部分, 相比而言简单一些了.</p><p>反转前N个结点的基本的思路是:</p><ol type="1"><li>通过N设置对反转<strong>结束</strong>的判断, 同时需要一个指针来表示<strong>后继</strong>;</li><li>与第一题一样翻转;</li></ol><p>那么对于我们的区间就很简单了:</p><ol type="1"><li>不断递归或迭代后移至需要反转的结点;</li><li>然后不就是<strong>反转链表前N个结点</strong>的问题嘛!</li></ol><h3 id="解题2">解题2</h3><p>由于结点和指针相对较多, 要仔细判断清楚.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverseTopN</span>(head, right);</span><br><span class="line">    head-&gt;next = <span class="built_in">reverseBetween</span>(head-&gt;next, left<span class="number">-1</span>, right<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ListNode * rest;</span><br><span class="line"><span class="function">ListNode* <span class="title">reverseTopN</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        rest = head-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode * last = <span class="built_in">reverseTopN</span>(head-&gt;next, n<span class="number">-1</span>);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = rest;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="个人收获">个人收获</h2><p>在这里反转链表的问题上, 迭代和递归的时间复杂度都是O(n), 所以选择使用哪个都差不多, 但是递归的空间复杂度却是O(n), 所以实际应用的时候还是迭代较好.</p><p>不过这里让我对递归有了更好的认知, 写递归函数, 就是要<strong>相信这个递归函数可以做到它该做的</strong>, 然后我们将<code>base case</code>和其他需要准备的做好就可以了, 剩下的就相信它!</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是关于单链表的反转问题, 存在反转全部链表和部分区间链表的情况.&lt;/p&gt;
&lt;p&gt;涉及 leetcode 的&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-linked-list/&quot;&gt;206. 反转链表&lt;/a&gt;和&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-linked-list-ii/&quot;&gt;92. 反转链表 II&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据结构算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="单链表" scheme="http://example.com/tags/%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    
    <category term="leetcode题解" scheme="http://example.com/tags/leetcode%E9%A2%98%E8%A7%A3/"/>
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
    <category term="迭代和递归" scheme="http://example.com/tags/%E8%BF%AD%E4%BB%A3%E5%92%8C%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>机器学习西瓜书——第01章绪论</title>
    <link href="http://example.com/2022/01/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E2%80%94%E2%80%94%E7%AC%AC01%E7%AB%A0%E7%BB%AA%E8%AE%BA/"/>
    <id>http://example.com/2022/01/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E2%80%94%E2%80%94%E7%AC%AC01%E7%AB%A0%E7%BB%AA%E8%AE%BA/</id>
    <published>2022-01-10T13:21:36.000Z</published>
    <updated>2022-01-14T13:36:39.407Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是关于周志华老师编写的机器学习书籍『西瓜书』的第一章绪论的简单体会.</p><p>主要的内容有: 机器学习的过程的一些基本术语和假设空间的解释. (归纳偏好回头再来)</p></blockquote><span id="more"></span><h2 id="引言">1.1 引言</h2><p>通俗来说机器学习: 在学习了很多的『经验』情况下, 学会了某种『方法』, 遇到<strong>新的问题</strong>后, 根据之前的『经验』和『方法』做出有效的决策.</p><blockquote><p>所谓"经验"就是"数据";</p><p>所谓"方法"就是机器学习研究的主要内容, 也就是从数据中学会的"模型"(model) 算法.</p></blockquote><h2 id="基本术语">1.2 基本术语</h2><h3 id="数据部分">数据部分</h3><ul><li><p><strong>数据集</strong>: 记录的集合称为一个"数据集"(data set);</p></li><li><p><strong>样本</strong>: 每条记录是关于一个事件或对象(这里是一个西瓜)的描述, 称为一个"示例"(instance) 或"样本"(sample);</p></li><li><p><strong>特征</strong>: 反映事件或对象在某方面的表现或性质的事项, 例如"色泽" "根蒂" "敲声", 称为"属性"(attribute) 或"特征"(feature);</p></li><li><p><strong>样本空间</strong>: 属性上的取值，例如"青绿" "乌黑", 称为"属性值" (attribute value). 属性张成的空间称为"属性空间" (attribute space) 、 "样本空间" (sample space) 或"输入空间".</p><blockquote><p>把属性值作为坐标轴，张成多维空间，得到坐标位置，每个点对应一个坐标向量，由此也把一个示例称为一个<strong>"特征向量" (feature vector)</strong>.</p></blockquote></li></ul><h3 id="学习过程">学习过程</h3><ul><li><p><strong>训练</strong>: 从数据中学得模型的过程称为"学习"(learning)或"训练"(training) ,这个过程通过执行某个学习算法来完成;</p></li><li><p><strong>训练样本</strong>: 训练过程中使用的数据称为"训练数据"(training data), 其中每个样本称为一个"训练样本"(training sample), 训练样本组成的集合称为"训练集"(training set);</p><blockquote><p>但有时候也会将整个数据集称为<strong>样本</strong>，需要依靠上下文判断。</p></blockquote></li><li><p><strong>学习器</strong>: 有时将模型称为"学习器"(learner), 可看作学习算法在给定数据和参数空间上的实例化;</p></li><li><p><strong>测试样本</strong>: 学得模型后, 使用器进行预测的过程称为"测试"(testing), 被预测的样本称为"测试样本"(test sample).</p></li></ul><h3 id="标记部分">标记部分</h3><ul><li><strong>标记</strong>: 关于示例结果的信息，例如"好瓜"，称为"标记" (label), 拥有了标记信息的示例，则称为"样例" (example);</li><li><strong>标记空间</strong>: 标记集合称为标记空间(label space)或"输出空间".</li></ul><h3 id="学习任务">学习任务</h3><ul><li><strong>分类</strong>: 若预测的是离散值, 则此类学习任务称为"分类"(classification);</li><li><strong>回归</strong>: 若预测的是连续值, 则此类学习任务称为"回归"(regression);</li><li><strong>聚类</strong>: 若对数据样本进行划分为各个"簇"(cluster), 则将此类学习任务称为"聚类"; &gt; 聚类的学习过程中使用的训练样本通常没有标记信息.</li><li>根据学习任务进行划分, 通常有两大类: <strong>有监督学习</strong>(supervised learning)和<strong>无监督学习</strong>(unsupervised learning), 分类和回归是前者的代表, 聚类则是后者的代表.</li></ul><h3 id="模型目标">模型目标</h3><ul><li>机器学习的目标是使得模型能够很好的适用于<strong>新样本</strong>, 而不是仅仅在训练集上表现的很好. 即使是聚类这种无监督的学习任务, 也同样如此;</li><li>学得的模型适用于新样本的能力, 称为"泛化"(generalization);</li><li>所以我们希望获得的样本能够尽可能的表示样本空间的特性, 从而在整个样本空间上都表现的很好;</li><li>通常假设每个样本都是<strong>独立同分布</strong>(independent and identically);</li><li>训练样本越多, 越有可能获得强泛化能力的模型.</li></ul><h2 id="假设空间">1.3 假设空间</h2><p>归纳(induction)与演绎(deduction)是科学推理的两大基本手段:</p><ul><li>前者是从特殊到一般的<strong>泛化</strong>(generalization)过程，即从具体的事实归结出一般性规律;</li><li>后者则是从一般到特殊的<strong>特化</strong>(specialization)过程，即从基础原理推演出具体状况.</li></ul><p>把学习的过程看作一个在所有假设(hypothesis)组成的空间中进行<strong>搜索</strong>的过程, 搜索的目标是找到与训练集"匹配"(fit)的假设.</p><blockquote><p>假设的表示一旦确定, 假设空间及其规模大小就确定了.</p></blockquote><p>搜索的策略有: 自顶向下、从一般到特殊，或是自底向上、从特殊到一般等. 搜索过程也可以不断删除与正例不一致的假设. 最终获得<strong>与训练集一致</strong>的假设, 这就是学习的结果.</p><p>但是现实中假设空间可能很大, 但是学习过程中使用的训练样本有限, 所以实际上存在很多的假设空间，但仅存在一个与训练集一致的<strong>假设集合</strong>, 称之为<strong>版本空间</strong>(version space).</p><h2 id="归纳偏好">1.4 归纳偏好</h2><p>// todo</p><h2 id="个人收获">个人收获</h2><p>整理了机器学习基本的术语和一些名词, 这是<strong>磨刀</strong>.</p><p>新接触了版本空间的概念,这是之前学习一些内容的时候没有注意到的部分.</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是关于周志华老师编写的机器学习书籍『西瓜书』的第一章绪论的简单体会.&lt;/p&gt;
&lt;p&gt;主要的内容有: 机器学习的过程的一些基本术语和假设空间的解释. (归纳偏好回头再来)&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="机器学习" scheme="http://example.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="西瓜书" scheme="http://example.com/tags/%E8%A5%BF%E7%93%9C%E4%B9%A6/"/>
    
    <category term="名词解释" scheme="http://example.com/tags/%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"/>
    
  </entry>
  
  <entry>
    <title>数组解题技巧3——二分查找</title>
    <link href="http://example.com/2022/01/10/%E6%95%B0%E7%BB%84%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A73%E2%80%94%E2%80%94%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>http://example.com/2022/01/10/%E6%95%B0%E7%BB%84%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A73%E2%80%94%E2%80%94%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</id>
    <published>2022-01-10T11:18:35.000Z</published>
    <updated>2022-01-10T12:57:32.852Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是关于问题有序数组的二分查找问题，1.查找一个元素；2.查找区间全元素。</p><p>涉及 leetcode 的<a href="https://leetcode-cn.com/problems/binary-search/">704. 二分查找</a>和<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a>。</p></blockquote><span id="more"></span><h2 id="二分查找">二分查找</h2><h3 id="题目1">题目1</h3><p>首先来看题目<a href="https://leetcode-cn.com/problems/binary-search/">704. 二分查找</a>：给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><p>示例1：</p><blockquote><p>输入：nums = [-1,0,3,5,9,12], target = 9</p><p>输出：4</p></blockquote><p>示例2：</p><blockquote><p>输入：nums = [-1,0,3,5,9,12], target = 2</p><p>输出：-1</p></blockquote><h3 id="理解一下1">理解一下1</h3><p>题目的大概意思就是：在有序数组<code>nums</code>中找出与<code>target</code>相同的元素的索引位置。</p><p>直接遍历的时间复杂度是O(n)，而这里是<strong>有序数组</strong>，那么就可以使用二分查找，由此时间复杂度为O(log n)。</p><p>基本的思路是：</p><ol type="1"><li>约束查找区间左索引指针<code>left</code>和右索引指针<code>right</code>，获得中间索引指针<code>mid</code>；</li><li>判断<code>mid</code>指向的元素与<code>target</code>的大小：<ol type="1"><li>等于<code>target</code>：返回该<code>mid</code>索引；</li><li>大于<code>target</code>：说明在左侧，<code>right</code>向左收缩；</li><li>小于<code>target</code>：说明在右侧，<code>left</code>向右收缩；</li></ol></li></ol><h3 id="解题1">解题1</h3><p>需要注意的是right和left是<strong>闭区间</strong>，并且while循环中使用的是<span class="math inline">\(\leq\)</span>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>()<span class="number">-1</span>; <span class="comment">// 右侧需要减一</span></span><br><span class="line">    <span class="comment">// 计算 mid 时需要防止太大溢出</span></span><br><span class="line">    <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left = mid +<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找元素区间">查找元素区间</h2><h3 id="题目2">题目2</h3><p>首先来看题目<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a>：给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回[-1, -1]。</p><p>示例1：</p><blockquote><p>输入：nums = [5,7,7,8,8,10], target = 8</p><p>输出：[3,4]</p></blockquote><p>示例2：</p><blockquote><p>输入：nums = [5,7,7,8,8,10], target = 6</p><p>输出：[-1,-1]</p></blockquote><h3 id="理解一下2">理解一下2</h3><p>这道题目是想要寻找等于target的所有元素，由于是<strong>有序数组</strong>，所以由一个<strong>区间</strong>表示。主要的问题在于如何寻找到区间的<strong>左右边界</strong>。</p><p>这里有两个思路，都是利用<strong>二分查找</strong>。</p><h3 id="解题2.1">解题2.1</h3><ol type="1"><li>按照普通的二分查找，找到寻找一个等于target的元素位置；</li><li>若未找到则flag置为false；</li><li>若找到了，那么向左右依次寻找临界点即可。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)&#123;  <span class="comment">// 此处判断元素相等则跳出循环</span></span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        left = mid;</span><br><span class="line">        right = mid;</span><br><span class="line">        <span class="keyword">while</span>(--left &gt;= <span class="number">0</span> &amp;&amp; nums[left] == target);</span><br><span class="line">        <span class="keyword">while</span>(++right &lt; nums.<span class="built_in">size</span>() &amp;&amp; nums[right] == target);</span><br><span class="line">        <span class="keyword">return</span> &#123;++left, --right&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题解2.2">题解2.2</h3><p>与方法一不同，直接去寻找左右端点。</p><p>需要修改的地方仅仅是在<strong>二分查找相等</strong>时和<strong>收缩边界</strong>的情况<strong>统一</strong>起来，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="built_in">leftRange</span>(nums, target);</span><br><span class="line">    <span class="keyword">if</span>(left == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="built_in">rightRange</span>(nums, target);</span><br><span class="line">    <span class="keyword">return</span> &#123;left, right&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">leftRange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;  <span class="comment">// 右侧向左侧收缩，找到左端点</span></span><br><span class="line">        &#125;</span><br><span class="line">        mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= nums.<span class="built_in">size</span>() || nums[left] != target)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rightRange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;  <span class="comment">// 左侧向右侧收缩，找到右端点</span></span><br><span class="line">        &#125;</span><br><span class="line">        mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(right &lt; <span class="number">0</span> || nums[right] != target)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="个人收获">个人收获</h2><p>这里使用的二分查找比较简单，类似于一棵树，主要就是收缩区间和循环终止等一些细节问题。</p><p>第二个关于区间问题的方法，在leetcode上虽然第一个方法的效率较高，但是第二个方法的模块化和层次化要更好，更适合进行改编改写。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是关于问题有序数组的二分查找问题，1.查找一个元素；2.查找区间全元素。&lt;/p&gt;
&lt;p&gt;涉及 leetcode 的&lt;a href=&quot;https://leetcode-cn.com/problems/binary-search/&quot;&gt;704. 二分查找&lt;/a&gt;和&lt;a href=&quot;https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/&quot;&gt;34. 在排序数组中查找元素的第一个和最后一个位置&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据结构算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="leetcode题解" scheme="http://example.com/tags/leetcode%E9%A2%98%E8%A7%A3/"/>
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
    <category term="双指针" scheme="http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="二分查找" scheme="http://example.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>字符串解题技巧1——滑动窗口</title>
    <link href="http://example.com/2022/01/09/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A71%E2%80%94%E2%80%94%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <id>http://example.com/2022/01/09/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A71%E2%80%94%E2%80%94%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</id>
    <published>2022-01-09T13:51:01.000Z</published>
    <updated>2022-01-10T09:32:13.774Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是关于字符串的子串问题，就数据结构的形态来说还是属于数组的问题，这里主要是关于使用双指针解决滑动窗口的问题。</p><p>涉及 leetcode 的<a href="https://leetcode-cn.com/problems/minimum-window-substring/">76. 最小覆盖子串</a>、<a href="https://leetcode-cn.com/problems/permutation-in-string/">567. 字符串的排列</a>、<a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a>和<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a>。</p></blockquote><span id="more"></span><h2 id="包含子串元素问题">包含子串元素问题</h2><p><a href="https://leetcode-cn.com/problems/minimum-window-substring/">76. 最小覆盖子串</a>、<a href="https://leetcode-cn.com/problems/permutation-in-string/">567. 字符串的排列</a>和<a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a>这一系列的问题都是关于在字符串中包含子串元素的问题。</p><h3 id="题目1">题目1</h3><p>首先来看这些题目<a href="https://leetcode-cn.com/problems/permutation-in-string/">567. 字符串的排列</a>：给你两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true；否则，返回 false。</p><p>换句话说，s1 的排列之一是 s2 的子串。</p><p>示例1：</p><blockquote><p>输入：s1 = "ab" s2 = "eidbaooo"</p><p>输出：true</p></blockquote><p>示例2：</p><blockquote><p>输入：s1= "ab" s2 = "eidboaoo"</p><p>输出：false</p></blockquote><h3 id="理解一下1">理解一下1</h3><p>题目的大概意思就是：给你一个子串 s1，需要判断在 s2 中是否一个子串包含子串 s1 中的所有元素。</p><p>基本的思路是：</p><ol type="1"><li>获得子串<code>s1</code>的长度<code>Len</code>；</li><li>按照<code>Len</code>的大小，使用左右索引指针组成的<strong>固定窗口</strong>，在字符串<code>s2</code>上滑动；</li><li>不断比较窗口内的子串和<code>s1</code>的元素是否相同；</li><li>比较的方法可以使用<strong>hash表</strong>或数组，比较各个元素出现的次数相同即可。</li></ol><p>以上的方法需要的时间复杂度为两个字符串长度的乘积，即O(NM)。</p><p>想要优化到O(n)，则可以使用<strong>不固定的滑动窗口</strong>来完：</p><ol type="1"><li>首先使用<strong>hash表</strong>记录子串<code>s1</code>中元素出现的次数；</li><li>初始化在<code>s2</code>上的左右索引指针为0；</li><li>右索引指针进行向右<strong>扩张</strong>，不断将字符纳入窗口；</li><li>判断新加入的字符是否子串<code>s1</code>中的，若是则在<strong>窗口hash表</strong>记录字符及其个数；</li><li>此时若窗口内的子串不满足子串<code>s1</code>的元素要求，那么左索引指针右移来缩小窗口范围，并更新相应内容即可。</li></ol><h3 id="解题1">解题1</h3><p>以上的思路可能我没有很清楚的表示，不过没关系，我们弄清楚以下几点：</p><ol type="1"><li>移动right扩大窗口时该做什么？：判断新纳入窗口的字符是否是我们需要的，若需要则<strong>加入</strong>，并增加字符个数<strong>valid</strong>；</li><li>何时停止扩大窗口，并移动left缩小窗口？：窗口大小 ≥ 子串大小时；</li><li>缩小窗口时该干什么？；<ul><li>首先判断此时是否已经满足条件，若满足则直接返回；</li><li>否则移除left处元素，若是需要的元素，则更新有效值，并<strong>删除</strong>窗口内的元素。</li></ul></li></ol><p>还是看代码逻辑吧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// need是子串元素hash表，window是滑动窗口</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="comment">// 初始化need子串</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : s1)</span><br><span class="line">        need[c]++;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;  <span class="comment">// 区间左闭右开</span></span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;  <span class="comment">// 窗口内有效元素个数</span></span><br><span class="line">    <span class="keyword">while</span>(right &lt; s2.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s2[right];  <span class="comment">// 右移字符进入子串hash</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">if</span>(need.<span class="built_in">count</span>(c))&#123;  <span class="comment">// 1. 若是需要元素则修改hash</span></span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span>(window[c] == need[c])</span><br><span class="line">                valid++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 区域可缩小</span></span><br><span class="line">        <span class="keyword">while</span>(right-left &gt;= s1.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="comment">// 3.1 满足条件直接返回</span></span><br><span class="line">            <span class="keyword">if</span>(valid == need.<span class="built_in">size</span>())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> d = s2[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 3.2 移除元素</span></span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(d))&#123;</span><br><span class="line">                <span class="keyword">if</span>(window[d] == need[d])</span><br><span class="line">                    valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok，有了以上的代码再看剩下两题几乎是一模一样，就不详细解说了，代码如下：</p><h4 id="最小覆盖子串"><a href="https://leetcode-cn.com/problems/minimum-window-substring/">76. 最小覆盖子串</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// need是子串元素hash，window是滑动窗口</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="comment">// 初始化need子串</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : t)</span><br><span class="line">        need[c]++;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>; <span class="comment">// 区间左闭右开</span></span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;  <span class="comment">// 窗口内有效元素个数</span></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, len = INT_MAX;  <span class="comment">// 最终起点和长度</span></span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[right];  <span class="comment">//右移字符进入子串hash</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">if</span>(need.<span class="built_in">count</span>(c))&#123;  <span class="comment">//若需要则修改hash</span></span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span>(window[c] == need[c])</span><br><span class="line">                valid++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(valid == need.<span class="built_in">size</span>())&#123;  <span class="comment">//窗口内的元素已经满足需要</span></span><br><span class="line">            <span class="keyword">if</span>(right-left &lt; len)&#123;  <span class="comment">// 可以收缩窗口就更新结果</span></span><br><span class="line">                start = left;</span><br><span class="line">                len = right - left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(d))&#123;</span><br><span class="line">                <span class="keyword">if</span>(window[d] == need[d])</span><br><span class="line">                    valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len == INT_MAX ? <span class="string">&quot;&quot;</span> : s.<span class="built_in">substr</span>(start, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="找到字符串中所有字母异位词"><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a></h4><p>所谓异位词也就是子串重新排列嘛，不用感到新奇。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : p)</span><br><span class="line">        need[c]++;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[right++];</span><br><span class="line">        <span class="keyword">if</span>(need.<span class="built_in">count</span>(c))&#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span>(window[c] == need[c])</span><br><span class="line">                valid++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(right-left &gt;= p.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(valid == need.<span class="built_in">size</span>())&#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> d = s[left++];</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(d))&#123;</span><br><span class="line">                <span class="keyword">if</span>(window[d] == need[d])</span><br><span class="line">                    valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="无重复字符的最长子串">无重复字符的最长子串</h2><p>这题其实与以上三题大差不差，只不过这里<strong>没有给定子串</strong>，而是需要我们<strong>求出子串</strong>而已。</p><h3 id="题目2">题目2</h3><p>首先来看题目<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a>：给定一个字符串 s ，请你找出其中不含有重复字符的<strong>最长子串</strong>的长度。</p><p>示例1：</p><blockquote><p>输入："abcabcbb"</p><p>输出：3</p></blockquote><p>示例2：</p><blockquote><p>输入：s = "bbbbb"</p><p>输出：1</p></blockquote><h3 id="理解一下2">理解一下2</h3><p>题目的大概意思就是：找出字符串中元素不重复的子串的长度，也就是需要子串中的元素<strong>不重复</strong>，个数要尽可能的<strong>多</strong>。</p><p>保持之前的解题思路，但是这里就不需要<code>needhash</code>表和<code>valid</code>值了，因为我们没有需要比较的子串，但是需要一个<code>res</code>来记录长度：</p><ol type="1"><li>右侧子串向前扩张，将新字符纳入窗口；</li><li>判断该窗口内加入的该子串是否重复；</li><li>若重复，则左侧索引指针收缩，直至将重复元素抛出；</li><li>判断此时的长度与<code>res</code>大小，更新最大子串长度。</li></ol><h3 id="解题2">解题2</h3><p>很简单吧，看代码更简单。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; window;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="comment">// 扩张</span></span><br><span class="line">        <span class="keyword">char</span> c = s[right++];</span><br><span class="line">        window[c]++;</span><br><span class="line">        <span class="comment">// 有重复的字符</span></span><br><span class="line">        <span class="keyword">while</span>(window[c] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 收缩</span></span><br><span class="line">            <span class="keyword">char</span> d = s[left++];</span><br><span class="line">            window[d]--;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(res, right - left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="个人收获">个人收获</h2><p>之前使用双指针解决链表的时候，用快慢指针来解决一些链表上的逻辑问题；但是在字符串这种类似数组的数据结构中也是可以使用<strong>索引来表示指针</strong>，解决一些逻辑问题。</p><p>滑动窗口的结合hash表既可以来表示区域内的元素数量了，对于一些<strong>不要求顺序的子串问题</strong>就可以使用该方法解决。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是关于字符串的子串问题，就数据结构的形态来说还是属于数组的问题，这里主要是关于使用双指针解决滑动窗口的问题。&lt;/p&gt;
&lt;p&gt;涉及 leetcode 的&lt;a href=&quot;https://leetcode-cn.com/problems/minimum-window-substring/&quot;&gt;76. 最小覆盖子串&lt;/a&gt;、&lt;a href=&quot;https://leetcode-cn.com/problems/permutation-in-string/&quot;&gt;567. 字符串的排列&lt;/a&gt;、&lt;a href=&quot;https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/&quot;&gt;438. 找到字符串中所有字母异位词&lt;/a&gt;和&lt;a href=&quot;https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/&quot;&gt;3. 无重复字符的最长子串&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据结构算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="leetcode题解" scheme="http://example.com/tags/leetcode%E9%A2%98%E8%A7%A3/"/>
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
    <category term="双指针" scheme="http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="字符串" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="滑动窗口" scheme="http://example.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>数组解题技巧2——差分数组</title>
    <link href="http://example.com/2022/01/07/%E6%95%B0%E7%BB%84%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A72%E2%80%94%E2%80%94%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"/>
    <id>http://example.com/2022/01/07/%E6%95%B0%E7%BB%84%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A72%E2%80%94%E2%80%94%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/</id>
    <published>2022-01-07T15:42:27.000Z</published>
    <updated>2022-01-10T09:31:53.337Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是关于数组的差分数组技巧，在对元素数组区间进行加减计算时使用。</p><p>涉及 leetcode 的<a href="https://leetcode-cn.com/problems/range-addition">370. 区间加法</a>、<a href="https://leetcode-cn.com/problems/corporate-flight-bookings">1109. 航班预订统计</a>和<a href="https://leetcode-cn.com/problems/car-pooling">1094. 拼车</a>。</p></blockquote><span id="more"></span><h2 id="合并两个有序链表">合并两个有序链表</h2><h3 id="题目1">题目1</h3><p>首先来看题目<a href="https://leetcode-cn.com/problems/range-addition">370. 区间加法</a>：假设你有一个长度为 n 的数组，初始情况下所有的数字均为 0，你将会被给出 k 个更新的操作。其中，每个操作会被表示为一个三元组：[startIndex, endIndex, inc]，你需要将子数组 A[startIndex ... endIndex]（包括 startIndex 和 endIndex）增加 inc。</p><p>请你返回 k 次操作后的数组。</p><p>示例1：</p><blockquote><p>输入：length = 5, updates = [ [1,3,2],[2,4,3],[0,2,-2] ]</p><p>输出：[-2,0,3,5,3]</p></blockquote><h3 id="理解一下1">理解一下1</h3><p>题目的大概意思就是：</p><ol type="1"><li>初始数组为元素均为 0；</li><li>三元组表示在区间<code>startIndex</code>到<code>endIndex</code>内的元素都加上<code>inc</code>。</li></ol><p>最直白的思路就是，将每个三元组表示的区间一个一个加上值，很快就能实现，但是复杂度太高会超时，那么怎么办呢？</p><p>这里引入<strong>差分数组</strong>的概念：</p><p>差分数组就是在原长度为<code>n</code>的<code>nums</code>数组上，构建一个长度为<code>n+1</code>的数组<code>diff</code>，<code>diff[i] = nums[i] - nums[i-1]</code>，也就是原数组相邻两项的之差。</p><p>当差分数组计算完成之后再通过<code>nums[i] = nums[i-1] + diff[i]</code>即可还原得到相应的数组。</p><blockquote><p>对差分数组的第<code>i</code>项进行计算，都会同等影响到之后的剩余项，这就是差分数组的<strong>性质</strong>！</p></blockquote><p>因此，我们可以在差分数组上对第<code>first</code>项加上<code>seats</code>，使得后续的每一项都会增加<code>seats</code>，但是我们只想增加到第<code>last</code>项，所以在第<code>last+1</code>项之后再减去<code>seats</code>，就可以抵消该影响啦！</p><p>ok，那我们就来看代码吧！</p><h3 id="解题1">解题1</h3><p>构建差分数组的时候，使得差分数组的长度为<code>n+1</code>可以使得不用判断数组越界的问题，这个和链表增加<strong>头结点</strong>有异曲同工之妙。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">getModifiedArray</span><span class="params">(<span class="keyword">int</span> length, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; updates)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实际上计算的nums是差分数组，只不过这里开始都为0</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(length+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; updates.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        nums[updates[i][<span class="number">0</span>]] += updates[i][<span class="number">2</span>];</span><br><span class="line">        nums[updates[i][<span class="number">1</span>]+<span class="number">1</span>] -= updates[i][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 差分数组还原</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++)&#123;</span><br><span class="line">        nums[i] += nums[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    nums.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于<a href="https://leetcode-cn.com/problems/corporate-flight-bookings">1109. 航班预订统计</a>和<a href="https://leetcode-cn.com/problems/car-pooling">1094. 拼车</a>这两个问题实际上就是将该简单问题应用到实际场景中了，学会了这个差分数组的思想就很容易了，只需要注意端点细节处理即可。</p><h2 id="个人收获">个人收获</h2><ol type="1"><li><p>前缀和数组用于计算区域和问题，差分数组用于区域元素同时加减问题，而且使用频率较高时使用效果较好。</p></li><li><p>注意将数组长度扩大一个，这个在计算相邻项的时候就无需判断在数组最后是否会出现数组越界的问题，与链表中增加头结点的效果类似。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是关于数组的差分数组技巧，在对元素数组区间进行加减计算时使用。&lt;/p&gt;
&lt;p&gt;涉及 leetcode 的&lt;a href=&quot;https://leetcode-cn.com/problems/range-addition&quot;&gt;370. 区间加法&lt;/a&gt;、&lt;a href=&quot;https://leetcode-cn.com/problems/corporate-flight-bookings&quot;&gt;1109. 航班预订统计&lt;/a&gt;和&lt;a href=&quot;https://leetcode-cn.com/problems/car-pooling&quot;&gt;1094. 拼车&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据结构算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="leetcode题解" scheme="http://example.com/tags/leetcode%E9%A2%98%E8%A7%A3/"/>
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="差分数组" scheme="http://example.com/tags/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>数组解题技巧1——前缀和数组</title>
    <link href="http://example.com/2022/01/07/%E6%95%B0%E7%BB%84%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A71%E2%80%94%E2%80%94%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84/"/>
    <id>http://example.com/2022/01/07/%E6%95%B0%E7%BB%84%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A71%E2%80%94%E2%80%94%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84/</id>
    <published>2022-01-07T14:44:22.000Z</published>
    <updated>2022-01-10T09:31:44.684Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是关于数组的前缀和技巧，在快速计算一个数组区间内的元素之和时使用</p><p>涉及 leetcode 的 <a href="https://leetcode-cn.com/problems/range-sum-query-immutable">303. 区域和检索 - 数组不可变</a>、<a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable">304. 二维区域和检索 - 矩阵不可变</a>和<a href="https://leetcode-cn.com/problems/subarray-sum-equals-k">560. 和为 K 的子数组</a>。</p></blockquote><span id="more"></span><h2 id="区域检索">区域检索</h2><h3 id="题目1">题目1</h3><p>首先来看题目<a href="https://leetcode-cn.com/problems/range-sum-query-immutable">303. 区域和检索 - 数组不可变</a>：给定一个整数数组 nums，求出数组从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点。</p><p>示例1：</p><blockquote><p>输入：[ [ [-2, 0, 3, -5, 2, -1] ], [0, 2], [2, 5], [0, 5] ]</p><p>输出：[null, 1, -1, -3]</p></blockquote><h3 id="理解一下1">理解一下1</h3><p>题目的大概意思就是：计算数组内某个区域的和。</p><p>代码要求有两点，一个是写出构造函数，一个是写出计算区域和的函数。</p><p>基本的思路是：</p><ol type="1"><li>构造函数直接将数组传递过去就行；</li><li>在<code>sumRange</code>中使用循环计算<code>left</code>到<code>right</code>的和。</li></ol><p>很简单的嘛，OK确实，但是提交了发现超越的人数不多呀，这怎么行！</p><p>仔细思考发现 OJ 测试的时候构造函数仅仅调用<strong>一次</strong>，而计算区域和函数调用了<strong>多次</strong>，所以我们需要优化<code>sumRange</code>函数。</p><p>于是考虑使用前缀和，使得构造函数麻烦一些，但是使得<code>sumRange</code>函数<strong>简单</strong>一些：</p><ol type="1"><li>使用构造函数时，直接在传递数组时，计算前<code>n</code>项的前缀累加和，时间复杂度为<code>O(n)</code>；</li><li>然后<code>sumRange</code>函数计算<code>left</code>到<code>right</code>的区域和时，只需要使用第<code>right</code>项的前缀和减去第<code>left-1</code>项前缀和即可，<code>sumRange</code>的时间复杂度就是<code>O(1)</code>。</li></ol><h3 id="解题1">解题1</h3><p>先看解法一：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;nums = nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; i++)&#123;</span><br><span class="line">            sum += <span class="keyword">this</span>-&gt;nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再看使用前缀和的解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; presums;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="comment">// 构造时为 n 的复杂度</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;presums.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;presums[i] = <span class="keyword">this</span>-&gt;presums[i<span class="number">-1</span>] + nums[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用时仅需要直接索引相减即可</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;presums[right+<span class="number">1</span>] - <span class="keyword">this</span>-&gt;presums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关于<a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable">304. 二维区域和检索 - 矩阵不可变</a>这题，只不过是从一维变化成了二维，大家举一反三即可。</p><p>需要注意的仅仅是边界的细节问题。</p><h2 id="和为-k-的子数组">和为 K 的子数组</h2><h3 id="题目2">题目2</h3><p>首先来看题目<a href="https://leetcode-cn.com/problems/subarray-sum-equals-k">560. 和为 K 的子数组</a>：给你一个整数数组 nums 和一个整数 k ，请你统计并返回该数组中和为 k 的连续子数组的个数。</p><p>示例1：</p><blockquote><p>输入：nums = [1,1,1], k = 2</p><p>输出：2</p></blockquote><p>示例2：</p><blockquote><p>输入：nums = [1,2,3], k = 3</p><p>输出：2</p></blockquote><h3 id="理解一下2">理解一下2</h3><p>题目的大概意思就是：计算出，给定数组中有多少个连续子数组的和为 K，也就是给定数组中有多少个区间和为K。</p><p>最基本的思路就是穷举嘛，嵌套循环，计算所有区间的数组之和，判断其是否为 K。不过很遗憾，时间复杂度<span class="math inline">\(O(n^2)\)</span>在10000大小的测试案例中超时了。</p><p>再仔细看看区域和为K，关于区域和那我们很自然的想到使用前缀和数组试试看了：</p><ol type="1"><li>计算前缀和数组；</li><li>我们要计算区域和，就得使用前缀和数组的端点值相减，并判断是否为K，如此一来时间复杂度又回到了<span class="math inline">\(O(n^2)\)</span>；</li><li>换个思路，验证<code>i</code>处的前缀和<code>sum_i</code>减去<code>K</code>的差值<code>sum_j</code>，判断<code>sum_j</code>是否已经<strong>存在</strong>已知的前缀和数组中，若存在则统计<strong>出现次数</strong>即可！</li><li><code>sum_j</code>出现的次数就是i为右端点的区间可以出现的次数，随着不断计算前缀和数组和计数，那么时间复杂度仅仅是计算前缀和的时间O(n)。</li></ol><h3 id="题解2">题解2</h3><p>判断存在计数可以使用<strong>hash表</strong>来实现，快速高效。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用hash表来记录前缀和出现的次数</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; presum;</span><br><span class="line">    <span class="comment">// 初始记录为 0，因为存在一个数等于 k 的情况</span></span><br><span class="line">    presum[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// count 记录个数，sum_i 计算前缀和</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>, sum_i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num: nums)&#123;</span><br><span class="line">        sum_i += num;</span><br><span class="line">        <span class="keyword">int</span> sum_j = sum_i - k;</span><br><span class="line">        <span class="comment">// 相差为 k 的前缀和若存在，则区域相加为 k</span></span><br><span class="line">        <span class="keyword">if</span>(presum.<span class="built_in">find</span>(sum_j) != presum.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="comment">// 加上此前出现 sum_j 的次数</span></span><br><span class="line">            count += presum[sum_j];</span><br><span class="line">        &#125;</span><br><span class="line">        presum[sum_i]++; <span class="comment">// 出现次数加 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="个人收获">个人收获</h2><p>前缀和的计算方法主要适用于处理数组<strong>区域之和</strong>的问题，并且计算区域和<strong>频率较高</strong>时使用，能够达到较好的效果。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是关于数组的前缀和技巧，在快速计算一个数组区间内的元素之和时使用&lt;/p&gt;
&lt;p&gt;涉及 leetcode 的 &lt;a href=&quot;https://leetcode-cn.com/problems/range-sum-query-immutable&quot;&gt;303. 区域和检索 - 数组不可变&lt;/a&gt;、&lt;a href=&quot;https://leetcode-cn.com/problems/range-sum-query-2d-immutable&quot;&gt;304. 二维区域和检索 - 矩阵不可变&lt;/a&gt;和&lt;a href=&quot;https://leetcode-cn.com/problems/subarray-sum-equals-k&quot;&gt;560. 和为 K 的子数组&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据结构算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="leetcode题解" scheme="http://example.com/tags/leetcode%E9%A2%98%E8%A7%A3/"/>
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="前缀和" scheme="http://example.com/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>加快国内访问GitHub速度</title>
    <link href="http://example.com/2022/01/07/%E5%8A%A0%E5%BF%AB%E5%9B%BD%E5%86%85%E8%AE%BF%E9%97%AEGitHub%E9%80%9F%E5%BA%A6/"/>
    <id>http://example.com/2022/01/07/%E5%8A%A0%E5%BF%AB%E5%9B%BD%E5%86%85%E8%AE%BF%E9%97%AEGitHub%E9%80%9F%E5%BA%A6/</id>
    <published>2022-01-07T08:16:03.000Z</published>
    <updated>2022-01-08T08:30:33.761Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要是为了提高国内访问GitHub的速度。</p><p>方法是修改host文件。</p></blockquote><span id="more"></span><p>在国内 GitHub 访问速度慢或者无法访问，一般是因为 github 的加速分发 CDN 域名<code>assets-cdn.github.com</code>遭到<a href="https://baike.baidu.com/item/DNS%E6%B1%A1%E6%9F%93/8620359">DNS污染</a>，无法访问导致的。</p><p>所以解决方法就是修改本地的 host 映射，让解析的域名直接指向 Github 的 IP 地址，来绕过 DNS 解析。</p><h2 id="查询最新的-github-的-ip-地址">查询最新的 Github 的 IP 地址</h2><p>使用<a href="https://www.ipaddress.com/">ipaddress.com</a>查询以下域名对应的 IP 地址：</p><blockquote><p>github.com assets-cdn.github.com github.global.ssl.fastly.net</p></blockquote><h2 id="修改本地-host-文件">修改本地 host 文件</h2><p>Windows 用户在<code>C:\Windows\System32\drivers\etc</code>下找到 host 目录，若没有修改权限在<code>属性 -&gt; 安全</code>中增加用户的修改权限。</p><p>在使用记事本打开，在最后加入查询的 IP 和域名，增加如下内容，其中 IP 是自己查的最新的：</p><blockquote><p>#github映射（随便啦，做个标记让自己以后看到知道这里修改了什么）</p><p>140.82.114.3 github.com</p><p>185.199.108.153 assets-cdn.github.com</p><p>199.232.69.194 github.global.ssl.fastly.net</p></blockquote><h2 id="刷新-dns-缓存">刷新 DNS 缓存</h2><p>Windows 下使用<code>Win+R</code>，输入<code>cmd</code>，打开命令行，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /flushdns</span><br></pre></td></tr></table></figure><p>刷新成功后就可以愉快的访问 Github 了。</p><h2 id="最后">最后</h2><p>由于 IP 经常会发生变化，所以如果访问变慢了就需要手动更新。</p><p>这里推荐一个网址<a href="https://raw.hellogithub.com/hosts">hellogithub</a>，有最新的 Github 访问 IP，可以直接复制粘贴。（不过还是建议自己搜一下这三个域名的ip，也很快，这个直接复制的效果好像并不好）</p><h2 id="参考文章">参考文章</h2><ol type="1"><li><a href="https://juejin.cn/post/6955761924722130974">国内加速访问Github的办法，超级简单</a></li><li><a href="https://juejin.cn/post/7019683061977579557">解决GitHub访问慢的问题</a></li></ol><h2 id="个人收获">个人收获</h2><p>其实很早之前就修改过但现在忘记了，所以还是自己写一篇文章，很久以后忘记了直接来找就好了。</p><p>其中的一些原理细节未必会懂，但是这就是一个工具呀，能用好就可以啦！</p><p>以上，继续加油！</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文主要是为了提高国内访问GitHub的速度。&lt;/p&gt;
&lt;p&gt;方法是修改host文件。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="配置" scheme="http://example.com/categories/%E9%85%8D%E7%BD%AE/"/>
    
    
    <category term="GitHub" scheme="http://example.com/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>单链表解题技巧3——相交链表</title>
    <link href="http://example.com/2022/01/06/%E5%8D%95%E9%93%BE%E8%A1%A8%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A73%E2%80%94%E2%80%94%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2022/01/06/%E5%8D%95%E9%93%BE%E8%A1%A8%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A73%E2%80%94%E2%80%94%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</id>
    <published>2022-01-06T12:54:24.000Z</published>
    <updated>2022-01-10T09:31:02.773Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是关于单链表的判断相交问题，使用了两种方法，快慢指针和更好的逻辑连接方法。</p><p>涉及 leetcode 的 <a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a>。</p></blockquote><span id="more"></span><h2 id="相交链表">相交链表</h2><h3 id="题目">题目</h3><p>首先来看题目<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a>：给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。</p><p>示例1：</p><blockquote><p>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3</p><p>输出：Intersected at '8'</p></blockquote><p>示例2：</p><blockquote><p>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3</p><p>输出：Intersected at '8'</p></blockquote><h3 id="理解一下1">理解一下1</h3><p>所谓链表相交，就是一个<code>Y型</code>的链表结构，在交点处汇流，需要注意的是:</p><blockquote><p>链表相交后不会分开！因为链表只有一个<code>next</code>，只有唯一后继。</p></blockquote><p>寻找两条链表相交的结点就是寻找<strong>相同的结点</strong>（而不是值！）</p><p>基本的思路是：</p><p>遍历第一条链表<code>l1</code>，嵌套遍历第二条链表<code>l2</code>，判断相同的结点即可。</p><p>这种方法的时间复杂度达到了<code>O(n)</code>不是很好，于是便思考其他方法。</p><ol type="1"><li>我们需要找到相交点，而最后相交点之后链的长度都是一样的；</li><li>两个指针判断相等时需要同时到达相交点；</li><li>那么自然就需要使得前面遍历的经过的结点数相同；</li></ol><h3 id="解法一双指针">解法一（双指针）</h3><p>使用双指针来解决，我思考的时候还是比较自然的，表述可能不够清晰，自己动手比划比划就很清楚了。</p><ol type="1"><li>当链长相同时，自然是一一比较即可（这种情况不用考虑，包含在下面）；</li><li>链长不同是，短链的指针<code>l1</code>会先到达终点，而长链指针<code>l2</code>则还有<code>k</code>个结点，这个<code>k</code>刚好是两条链的长度之差；</li><li>由此我们长链中再设一个指针<code>llong</code>，跟随<code>l2</code>继续前进;</li><li>当<code>l2</code>到达终点时，<code>llong</code>距离链尾刚好与短链长度<strong>相同</strong>；</li><li>此时在短链头设置一个指针<code>lshort</code>，与<code>llong</code>一同前进，一一比较即可。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">    ListNode *la = headA, *lb = headB;</span><br><span class="line">    ListNode *lc, *llong, *lshort;</span><br><span class="line">    <span class="comment">// 依旧是快慢指针</span></span><br><span class="line">    <span class="comment">// la和lb同时前进</span></span><br><span class="line">    <span class="keyword">while</span>(la != <span class="literal">nullptr</span> &amp;&amp; lb != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        la = la-&gt;next;</span><br><span class="line">        lb = lb-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 选出长链和短链</span></span><br><span class="line">    <span class="keyword">if</span>(lb != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        lc = lb;</span><br><span class="line">        llong = headB;</span><br><span class="line">        lshort = headA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        lc = la;</span><br><span class="line">        llong = headA;</span><br><span class="line">        lshort = headB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 指向长链的快指针带着慢指针走到头</span></span><br><span class="line">    <span class="keyword">while</span>(lc != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        llong = llong-&gt;next;</span><br><span class="line">        lc = lc-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//短链从头开始和后出发的慢指针同时前进即可找到相同点</span></span><br><span class="line">    <span class="keyword">while</span>(lshort != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(lshort == llong)&#123;</span><br><span class="line">            <span class="keyword">return</span> llong;</span><br><span class="line">        &#125;</span><br><span class="line">        lshort = lshort-&gt;next;</span><br><span class="line">        llong = llong-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解法二逻辑连接">解法二（逻辑连接）</h3><p>继基本的分析思路，接下来要使得双指针同时到达交点：</p><ol type="1"><li>只需要使得双指针在到达交点时经过相同个数的结点即可；</li><li>而我们知道<code>A+B = B+A</code>；</li><li>所以在A链前加上B链，在B链前加上A链，那么双指针同时从各自链出发，会在同一时刻到达相交点！</li></ol><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">    ListNode *la = headA, *lb = headB;</span><br><span class="line">    <span class="keyword">while</span>(la != lb)&#123;</span><br><span class="line">        <span class="comment">// A链完了去B链</span></span><br><span class="line">        <span class="keyword">if</span> (la != <span class="literal">nullptr</span>)</span><br><span class="line">            la = la-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            la = headB;</span><br><span class="line">        <span class="comment">// B链完了去A链</span></span><br><span class="line">        <span class="keyword">if</span> (lb != <span class="literal">nullptr</span>)</span><br><span class="line">            lb = lb-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            lb = headA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> la;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="个人收获">个人收获</h2><p>这次感觉自己有一点很好的使用了之前学过的双指针，毕竟学了会用才是真的学会了。</p><p>另外将两个链表逻辑连接，使得两个链表的长度相同，这一点还是很值得学习的，不能作为套路，但是是一个很好的思考方向。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是关于单链表的判断相交问题，使用了两种方法，快慢指针和更好的逻辑连接方法。&lt;/p&gt;
&lt;p&gt;涉及 leetcode 的 &lt;a href=&quot;https://leetcode-cn.com/problems/intersection-of-two-linked-lists/&quot;&gt;160. 相交链表&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据结构算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="单链表" scheme="http://example.com/tags/%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    
    <category term="leetcode题解" scheme="http://example.com/tags/leetcode%E9%A2%98%E8%A7%A3/"/>
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
    <category term="逻辑链接" scheme="http://example.com/tags/%E9%80%BB%E8%BE%91%E9%93%BE%E6%8E%A5/"/>
    
    <category term="双指针" scheme="http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>单链表解题技巧(2)——快慢指针</title>
    <link href="http://example.com/2022/01/06/%E5%8D%95%E9%93%BE%E8%A1%A8%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A72%E2%80%94%E2%80%94%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"/>
    <id>http://example.com/2022/01/06/%E5%8D%95%E9%93%BE%E8%A1%A8%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A72%E2%80%94%E2%80%94%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/</id>
    <published>2022-01-06T11:00:57.000Z</published>
    <updated>2022-01-10T09:31:01.563Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是关于单链表的双指针问题中的快慢指针问题，1.链表的倒数第 n 个结点；2.寻找链表中间结点；3. 判断是否有环。</p><p>涉及 leetcode 的 <a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list">19. 删除链表的倒数第 N 个结点</a>、<a href="https://leetcode-cn.com/problems/middle-of-the-linked-list">876. 链表的中间结点</a>、<a href="https://leetcode-cn.com/problems/linked-list-cycle">141. 环形链表</a>和<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii">142. 环形链表 II</a>。</p></blockquote><span id="more"></span><h2 id="倒数第-n-个结点">倒数第 N 个结点</h2><h3 id="题目1">题目1</h3><p>首先来看题目<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list">19. 删除链表的倒数第 N 个结点</a>：给你一个链表，删除链表的<strong>倒数</strong>第 n 个结点，并且返回链表的头结点。</p><p>示例1：</p><blockquote><p>输入：head = [1,2,3,4,5], n = 2</p><p>输出：[1,2,3,5]</p></blockquote><p>示例2：</p><blockquote><p>输入：head = [1], n = 1</p><p>输出：[]</p></blockquote><h3 id="理解一下1">理解一下1</h3><p><strong>不用理解！</strong>(狗头)</p><p>基本的思路是：</p><ol type="1"><li>先遍历一遍链表，得到链表的长度<code>Len</code>；</li><li>然后再从头遍历一遍到第<code>Len-N</code>个结点，该结点的后一个结点就是需要删除的结点。</li></ol><p>以上的思路确实可以解决该问题，但是对链表进行了两次遍历，那么是否可以使用<strong>一次遍历</strong>完成呢？可以的。</p><p>这就需要使用快慢指针了：</p><ol type="1"><li>我们需要找到倒数<code>N</code>个结点，那么就需要寻找到第<code>Len-N</code>个结点；</li><li>首先让快指针先走，走出<code>N</code>步；</li><li>然后让慢指针和快指针保持相距<code>N</code>一起向前遍历，这时快指针还有<code>Len-N</code>步到达链尾，那么慢指针自然就还可以走<code>Len-N</code>步啦！</li></ol><h3 id="解题1">解题1</h3><p>这里我们同样需要对第一个结点进行讨论，所以直接引入头结点来解决。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用头结点</span></span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    dummy-&gt;next = head;</span><br><span class="line">    <span class="comment">// 快慢结点</span></span><br><span class="line">    ListNode *first = dummy, *second = dummy;</span><br><span class="line">    <span class="comment">// first先走n步</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// first和second保持相同的间距前进</span></span><br><span class="line">    <span class="comment">// first指向终点时second指向将要删除结点的前一个</span></span><br><span class="line">    <span class="keyword">while</span>(first-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">        second = second-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除（未释放空间）</span></span><br><span class="line">    second-&gt;next = second-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中间结点">中间结点</h2><p>再来看一下中间结点的问题，其实是相同的套路。</p><h3 id="题目2">题目2</h3><p>先来看一下题目<a href="https://leetcode-cn.com/problems/middle-of-the-linked-list">876. 链表的中间结点</a>：给定一个头结点为 head 的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。</p><p>示例1：</p><blockquote><p>输入：[1,2,3,4,5]</p><p>输出：此列表中的结点 3</p></blockquote><p>示例2：</p><blockquote><p>输入：[1,2,3,4,5,6]</p><p>输出：此列表中的结点 4</p></blockquote><h3 id="理解一下2">理解一下2</h3><p><strong>也不用理解！</strong>(狗头)</p><p>基本思路与上一题类似：</p><ol type="1"><li>先遍历一遍链表，得到链表的长度<code>Len</code>；</li><li>然后再从头遍历一遍到第<code>Len/2</code>个结点即可。</li></ol><p>这同样需要使用两次遍历，有了上面的经验我们自然可以想到使用快慢指针实现一次遍历：</p><ol type="1"><li>快指针和慢指针同时出发（与之前先后出发不同了）；</li><li>快指针一次走两个<code>next</code>，慢指针一次进行一次<code>next</code>，这样快指针走到最后，慢指针刚好走了快指针的一般路程。</li></ol><h3 id="题解2">题解2</h3><p>这里根据题目要求注意一下中间结点的定义即可。</p><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode * first = head, * second = head;</span><br><span class="line">    <span class="keyword">while</span>(first != <span class="literal">nullptr</span> &amp;&amp; first-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="comment">// 慢指针走一步，快指针走两步</span></span><br><span class="line">        second = second-&gt;next;</span><br><span class="line">        first = first-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="同样套路还有一个啦二合一">同样套路，还有一个啦（二合一）</h2><h2 id="环形链表">环形链表</h2><h3 id="题目3">题目3</h3><p><a href="https://leetcode-cn.com/problems/linked-list-cycle">141. 环形链表</a>和<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii">142. 环形链表 II</a>这两题类似。</p><p>141 给你一个链表的头节点 head ，判断链表中是否有环。</p><p>以及</p><p>142 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><h3 id="理解一下3">理解一下3</h3><p>也就是说需要判断链表是否有环，以及从哪个结点开始形成环。</p><p>那么我们首先需要知道如何判断环：</p><ol type="1"><li>容易发现，一旦使用指针在有环链表中进行遍历，那么遍历一定是没有终止；就像操场跑步一样，只要沿着400米的圈一直跑就没有尽头，但是沿着100米的直线跑却是有尽头的；</li><li>同样的，当我与你一起在<code>100 + 400n米</code>的操场上跑步，从我跑得慢，你跑得快，那么你是不是终究就会在某个点上超过我一圈！</li><li>因此我们同样可以使用快慢指针进行你追我赶，当然，补偿为1、2、3这种连续遍历，可能会超过K圈（整数倍），不过无所谓，<strong>你我终会相遇</strong>。</li></ol><p>然后如何判断在哪相遇呢？（你的速度是我的两倍）</p><ol type="1"><li>慢吞吞的我跑了<code>n</code>米，快吨吨的你跑了<code>2n</code>米，相遇时距离环起点也<code>m</code>米；</li><li>那么超过我的距离<code>n</code>一定是环的<strong>整数</strong>倍，所以你<strong>再</strong>跑<code>n-m</code>米就可以到达环起点，而我<strong>回到起点</strong>再跑<code>n-m</code>米也能到达环起点！</li><li>这里就不需要计数n了，保持相同速度跑，自然会在起点相遇，<strong>你我终会再次相遇</strong>。</li></ol><h3 id="题解3">题解3</h3><p>判断方法如下：</p><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    ListNode *first = head, *second = head;</span><br><span class="line">    <span class="comment">// 同样使用快慢指针，若存在环，那么快指针将会在环内与慢指针相遇</span></span><br><span class="line">    <span class="keyword">while</span>(first != <span class="literal">nullptr</span> &amp;&amp; first-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        first = first-&gt;next-&gt;next;</span><br><span class="line">        second = second-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(first == second)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>寻找环起点的方法如下：</p><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    ListNode *first = head, *second = head;</span><br><span class="line">    <span class="comment">// 标记是否相遇</span></span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(first != <span class="literal">nullptr</span> &amp;&amp; first-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        first = first-&gt;next-&gt;next;</span><br><span class="line">        second = second-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(second == first)&#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        <span class="comment">// 任意一个结点回到起点，同样速度跑</span></span><br><span class="line">        first = head;</span><br><span class="line">        <span class="keyword">while</span>(first != second)&#123;</span><br><span class="line">            first = first-&gt;next;</span><br><span class="line">            second = second-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="个人收获">个人收获</h2><p>这次的收获主要是头结点和快慢指针</p><ol type="1"><li>头结点使得每个结点都有直接前驱，可以避免单独处理第一个结点的问题，很好用的；</li><li>快慢指针可以用来解决一些与速度、距离有关的问题会有较好的处理方法，在后续的题目中多熟悉熟悉。</li></ol>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是关于单链表的双指针问题中的快慢指针问题，1.链表的倒数第 n 个结点；2.寻找链表中间结点；3. 判断是否有环。&lt;/p&gt;
&lt;p&gt;涉及 leetcode 的 &lt;a href=&quot;https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list&quot;&gt;19. 删除链表的倒数第 N 个结点&lt;/a&gt;、&lt;a href=&quot;https://leetcode-cn.com/problems/middle-of-the-linked-list&quot;&gt;876. 链表的中间结点&lt;/a&gt;、&lt;a href=&quot;https://leetcode-cn.com/problems/linked-list-cycle&quot;&gt;141. 环形链表&lt;/a&gt;和&lt;a href=&quot;https://leetcode-cn.com/problems/linked-list-cycle-ii&quot;&gt;142. 环形链表 II&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据结构算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="单链表" scheme="http://example.com/tags/%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    
    <category term="leetcode题解" scheme="http://example.com/tags/leetcode%E9%A2%98%E8%A7%A3/"/>
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
    <category term="双指针" scheme="http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="快慢指针" scheme="http://example.com/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>单链表解题技巧(1)——合并有序链表</title>
    <link href="http://example.com/2022/01/05/%E5%8D%95%E9%93%BE%E8%A1%A8%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A71%E2%80%94%E2%80%94%E5%90%88%E5%B9%B6%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2022/01/05/%E5%8D%95%E9%93%BE%E8%A1%A8%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A71%E2%80%94%E2%80%94%E5%90%88%E5%B9%B6%E9%93%BE%E8%A1%A8/</id>
    <published>2022-01-05T12:49:18.000Z</published>
    <updated>2022-01-10T09:31:19.591Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是关于单链表的合并问题，1.合并两个有序链表；2.合并k个有序链表（堆）。</p><p>涉及 leetcode 的 <a href="https://leetcode-cn.com/problems/merge-two-sorted-lists">21. 合并两个有序链表</a>和 <a href="https://leetcode-cn.com/problems/merge-k-sorted-lists">23. 合并K个升序链表</a>。</p></blockquote><span id="more"></span><h2 id="合并两个有序链表">合并两个有序链表</h2><h3 id="题目1">题目1</h3><p>首先来看题目<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists">21. 合并两个有序链表</a>：将两个升序链表合并为一个新的<strong>升序</strong>链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p>示例1：</p><blockquote><p>输入：l1 = [1,2,4], l2 = [1,3,4]</p><p>输出：[1,1,2,3,4,4]</p></blockquote><p>示例2：</p><blockquote><p>输入：l1 = [], l2 = [0]</p><p>输出：[0]</p></blockquote><h3 id="理解一下1">理解一下1</h3><p>题目的大概意思就是：</p><ol type="1"><li>将两个本身就有序（升序）的链表合并起来，得到一个新的链表依旧是有序的；</li><li>并且新的链表依旧使用原本链表中的结点，而不是创建新的结点。（也就是用next指针指来指去）。</li></ol><p>基本的思路是：</p><ol type="1"><li>首先创建一个链表头<code>res</code>来表示最终的链表；</li><li>然后分别使用两个指针指向链表<code>l1</code>和链表<code>l2</code>；</li><li>再比较<code>l1</code>和<code>l2</code>对应结点的值的大小，将小的结点连接到<code>res</code>中；</li><li><code>l1</code>和<code>l2</code>不断向后遍历，重复3，最后剩下没遍历完的就直接放在<code>res</code>后。</li></ol><h3 id="解题1">解题1</h3><p>以上的思路忽略了一些细节（n，n-1，1，0等这些边界问题），这里我们在处理第一个结点（无前结点）的时候还是需要分类讨论的，所以根据数据结构的定义，引入所谓的<code>头结点</code>，这样第一个结点就和其他结点都一样了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 头结点</span></span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    ListNode* p = dummy;</span><br><span class="line">    ListNode* p1 = list1, *p2 = list2;</span><br><span class="line">    <span class="comment">// 谁的结点小就将谁接在链表 dummy 后</span></span><br><span class="line">    <span class="keyword">while</span>(p1 &amp;&amp; p2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1-&gt;val &gt; p2-&gt;val)&#123;</span><br><span class="line">            p-&gt;next = p2;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            p-&gt;next = p1;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 跳出 while 循环的条件必然是至少一条链遍历结束了，那么剩下的一条的后续部分直接接在 dummy 中即可。</span></span><br><span class="line">    <span class="keyword">if</span>(p1)</span><br><span class="line">        p-&gt;next = p1;</span><br><span class="line">    <span class="keyword">if</span>(p2)</span><br><span class="line">        p-&gt;next = p2;</span><br><span class="line">    <span class="comment">// 题目需要返回的是没有头结点的，所以是 next。</span></span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合并k个有序链表">合并K个有序链表</h2><h3 id="题目2">题目2</h3><p>同样先看一下题目<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists">23. 合并K个升序链表</a>：给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p>示例1：</p><blockquote><p>输入：lists = [ [1,4,5],[1,3,4],[2,6] ]</p><p>输出：[1,1,2,3,4,4,5,6]</p></blockquote><p>示例2：</p><blockquote><p>输入：lists = [ ]</p><p>输出：[ ]</p></blockquote><h3 id="理解一下2">理解一下2</h3><p>就相当于之前是两个有序链表两两合并，现在是K个链表进行有序合并成一个有序链表。</p><p>基本的思路有两个：</p><h4 id="两两合并2">两两合并2</h4><p>第一种方法是在上一题的基础上，直接进行两两合并，得到有序链表，当然这里也有两种思路：一个是直接进行<code>k-1</code>次两两合并，另一个是使用<strong>归并</strong>两两合并，无非是时间换空间的问题（嗷，还有一个问题是归并我不熟练）。</p><p>这里提供我用第一个思路写的k-1次归并题解，其中<code>mergeTwoLists</code>函数就是之前的两两合并（好家伙，直接复制！）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 无链表</span></span><br><span class="line">    <span class="keyword">if</span>(lists.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 仅有一个链表</span></span><br><span class="line">    <span class="keyword">if</span>(lists.<span class="built_in">size</span>() == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// k-1 次两两合并</span></span><br><span class="line">    ListNode * res = lists[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lists.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        res = <span class="built_in">mergeTwoLists</span>(res,lists[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小根堆合并">小根堆合并</h4><p>第二种方法需要使用数据结构——<strong>小根堆</strong>（本质上是一棵完全二叉树），通过堆的性质进行合并，在很多外部排序的时候会采用这种方法，同样的也有两个思路：</p><ol type="1"><li>一个是将所有的链表所有的结点都<strong>一次性</strong>扔到堆中（显然需要空间极大），然后依次从堆顶取出结点链接到链表<code>dummy</code>中即可；</li><li>另一个是以<code>k</code>个链表的头结点构建大小为<code>k</code>的小根堆，堆顶的的结点就是最小结点，将其拿出链接到链表<code>dummy</code>中即可，并将该链上的<code>next</code>结点加入小根堆，并进行调整，直至堆中无结点即可。</li></ol><p>很明显<strong>小根堆合并</strong>比<strong>两两合并</strong>好多了，但是实际 coding 的时候其实并不一定能写出来（orz），所以这两种方法作为思路，并提供了一个<code>labuladong</code>的 java 题解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 虚拟头结点</span></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode p = dummy;</span><br><span class="line">    <span class="comment">// 优先级队列，最小堆</span></span><br><span class="line">    PriorityQueue&lt;ListNode&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(</span><br><span class="line">        lists.length, (a, b)-&gt;(a.val - b.val));</span><br><span class="line">    <span class="comment">// 将 k 个链表的头结点加入最小堆</span></span><br><span class="line">    <span class="keyword">for</span> (ListNode head : lists) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="keyword">null</span>)</span><br><span class="line">            pq.add(head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 获取最小节点，接到结果链表中</span></span><br><span class="line">        ListNode node = pq.poll();</span><br><span class="line">        p.next = node;</span><br><span class="line">        <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pq.add(node.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// p 指针不断前进</span></span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="个人收获">个人收获</h2><p>这里主要学到的是对k个链表进行合并的思路：</p><ol type="1"><li>两两合并的方法其实很常见，在ML中，对多分类问题也经常使用多次二分类进行实现，本质上感觉还是很相似的，好吧不是一回事，总之是将问题进行拆分，然后再一个一个解决，虽然暴力（O(NK)），但是起码能够解决问题，不至于完全写不出来。</li><li>对于小根堆其实也是比较熟悉了，在数据结构中小根堆的<strong>画图</strong>我可是熟悉的一塌糊涂（除了考试没啥用），但是代码上就显得比较不熟练了，之后在树的这一个模块中再好好练一练。这个可以很好的降低时间的复杂度，相应的付出一些时间，不过效果要比两两合并好多（O(Nlogk)）。</li></ol>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是关于单链表的合并问题，1.合并两个有序链表；2.合并k个有序链表（堆）。&lt;/p&gt;
&lt;p&gt;涉及 leetcode 的 &lt;a href=&quot;https://leetcode-cn.com/problems/merge-two-sorted-lists&quot;&gt;21. 合并两个有序链表&lt;/a&gt;和 &lt;a href=&quot;https://leetcode-cn.com/problems/merge-k-sorted-lists&quot;&gt;23. 合并K个升序链表&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据结构算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="单链表" scheme="http://example.com/tags/%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    
    <category term="leetcode题解" scheme="http://example.com/tags/leetcode%E9%A2%98%E8%A7%A3/"/>
    
    <category term="k路问题" scheme="http://example.com/tags/k%E8%B7%AF%E9%97%AE%E9%A2%98/"/>
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>微信聊天记录制作词云图</title>
    <link href="http://example.com/2022/01/01/%E5%88%B6%E4%BD%9C%E8%AF%8D%E4%BA%91%E5%9B%BE/"/>
    <id>http://example.com/2022/01/01/%E5%88%B6%E4%BD%9C%E8%AF%8D%E4%BA%91%E5%9B%BE/</id>
    <published>2022-01-01T02:45:12.000Z</published>
    <updated>2022-01-01T04:33:47.324Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文记录了从微信聊天记录导出到制作完成词云图的过程</p><p>利用了python，GitHub开源项目完成，默认了解python和mysql基础知识。</p><p>设备：Windows、ipad</p></blockquote><span id="more"></span><h2 id="导出微信聊天记录有iosipados设备">导出微信聊天记录（有IOS/IpadOS设备）</h2><p>首先我们需要将手机端的聊天记录（手机端的聊天记录比较完整）传送到微信端，这一步需要大家首先有一台苹果设备，利用iTunes备份聊天信息。</p><ol type="1"><li><p>（安卓用户）打开微信，找到<code>设置-&gt;聊天-&gt;聊天记录备份与迁移-&gt;迁移聊天记录到另一台设备</code>，然后选择想要的聊天记录，最后用苹果设备扫描出现的二维码，等待传输完成即可。</p></li><li><p>当苹果设备备份完成后，下载<a href="https://support.apple.com/zh-cn/HT210384">iTunes</a>，用电脑连接苹果设备，这时候在iTunes上会出现一个设备图标，点击并打开</p><img src="/2022/01/01/%E5%88%B6%E4%BD%9C%E8%AF%8D%E4%BA%91%E5%9B%BE/image-20220101105954123.png" class="" title="image-20220101105954123"></li><li><p>点击<code>摘要-&gt;备份-&gt;本电脑-&gt;立即备份</code>，等待片刻使其备份完成。</p><img src="/2022/01/01/%E5%88%B6%E4%BD%9C%E8%AF%8D%E4%BA%91%E5%9B%BE/image-20220101110318002.png" class="" title="image-20220101110318002"></li><li><p>在Windows中，聊天记录一般在<code>C:\Users\用户名\AppData\Roaming\Apple Computer\MobileSync\Backup</code>内，使用<a href="https://github.com/BlueMatthew/WechatExporter/releases/download/v1.8.0.10/v1.8.0.10_x64_win.zip">WechatExporter-Windows</a>或<a href="https://github.com/BlueMatthew/WechatExporter/releases/download/v1.8.0.10/v1.8.0.10_x64_macos.zip">WechatExporter-MacOS</a>来解析文件，之后图片及聊天记录就会存在选定的文件夹中。若仅需要聊天记录文件的txt文件，则在<code>格式</code>中选择<code>文本</code>即可。</p><img src="/2022/01/01/%E5%88%B6%E4%BD%9C%E8%AF%8D%E4%BA%91%E5%9B%BE/image-20220101111144265.png" class="" title="image-20220101111144265"></li></ol><h2 id="聊天记录入库">聊天记录入库</h2><p>至此文件解析成功，接下来就是使用python对聊天记录导出的内容进行清洗过滤，得到<code>发送时间</code>、<code>用户名</code>和<code>聊天内容</code>，并保存到数据库中（当然也可以不用，自己对代码进行修改即可）如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">from</span> pymysql.converters <span class="keyword">import</span> escape_string</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_time</span>(<span class="params">time_str</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;将12小时日期时间转化为24小时制时间</span></span><br><span class="line"><span class="string">    Args: time_str (str): 12小时日期时间字符串，例如:2021-03-30 10:00:33 PM</span></span><br><span class="line"><span class="string">    Returns: str: 24小时制日期时间，例如:2021-03-30 22:00:33</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    str1 = time_str[-<span class="number">2</span>:]  <span class="comment"># 格式</span></span><br><span class="line">    data = time_str[:-<span class="number">3</span>]  <span class="comment"># 时间</span></span><br><span class="line">    <span class="keyword">if</span> str1.lower() == <span class="string">&quot;am&quot;</span> <span class="keyword">and</span> <span class="built_in">int</span>(time_str[-<span class="number">11</span>:-<span class="number">9</span>]) == <span class="number">12</span>:</span><br><span class="line">        hour = <span class="string">&quot;00&quot;</span></span><br><span class="line">        data = time_str[<span class="number">0</span>:<span class="number">11</span>] + hour + time_str[-<span class="number">9</span>:-<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">if</span> str1.lower() == <span class="string">&quot;pm&quot;</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">int</span>(time_str[-<span class="number">11</span>:-<span class="number">9</span>]) &lt; <span class="number">12</span>:</span><br><span class="line">            hour = <span class="built_in">str</span>(<span class="built_in">int</span>(time_str[-<span class="number">11</span>:-<span class="number">9</span>])+<span class="number">12</span>)</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># int(time_str[-11:-9]) == 12</span></span><br><span class="line">            hour = <span class="string">&quot;12&quot;</span></span><br><span class="line">        data = time_str[<span class="number">0</span>:<span class="number">11</span>] + hour + time_str[-<span class="number">9</span>:-<span class="number">3</span>]</span><br><span class="line">    str2 = time.mktime(time.strptime(data, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>))  <span class="comment"># 转换为时间戳</span></span><br><span class="line">    finally_result = <span class="built_in">str</span>(time.strftime(</span><br><span class="line">        <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, time.localtime(str2)))  <span class="comment"># 转换为指定格式</span></span><br><span class="line">    <span class="keyword">return</span> finally_result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">filter_lines = []  <span class="comment"># 最终的聊天信息</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;你的聊天记录路径.txt&quot;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    lines = f.readlines()</span><br><span class="line">    reg = <span class="string">&quot;^.+[\u4E00-\u9FFF]\s\(.+\):&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="comment"># 仅保留互相发送的信息记录</span></span><br><span class="line">        <span class="keyword">if</span> (line.startswith(<span class="string">&#x27;对方的用户名&#x27;</span>) <span class="keyword">or</span> line.startswith(<span class="string">&#x27;你的用户名&#x27;</span>)) <span class="keyword">and</span> re.match(reg, line):</span><br><span class="line">            filter_lines.append(line.strip())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接数据库</span></span><br><span class="line">conn = pymysql.connect(</span><br><span class="line">    host=<span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">    user=<span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    password=<span class="string">&#x27;123456&#x27;</span>,</span><br><span class="line">    db=<span class="string">&#x27;wechat_report&#x27;</span>,  <span class="comment"># 需要先建好</span></span><br><span class="line">    charset=<span class="string">&#x27;utf8mb4&#x27;</span>,</span><br><span class="line">    port=<span class="number">3306</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建游标</span></span><br><span class="line">cur = conn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据表</span></span><br><span class="line">create_sql = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">CREATE TABLE `log` (</span></span><br><span class="line"><span class="string">  `id` bigint(20) NOT NULL AUTO_INCREMENT,</span></span><br><span class="line"><span class="string">  `user` varchar(100) DEFAULT NULL,</span></span><br><span class="line"><span class="string">  `datetime` datetime DEFAULT NULL,</span></span><br><span class="line"><span class="string">  `content` text,</span></span><br><span class="line"><span class="string">  PRIMARY KEY (`id`)</span></span><br><span class="line"><span class="string">) ENGINE=InnoDB AUTO_INCREMENT=222187 DEFAULT CHARSET=utf8mb4;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">cur.execute(create_sql)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入数据表</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> filter_lines:</span><br><span class="line">    s1 = line.find(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    s2 = line.find(<span class="string">&quot;):&quot;</span>)</span><br><span class="line">    name = line[:s1]  <span class="comment"># 发送者</span></span><br><span class="line">    chattime = line[s1 + <span class="number">2</span>:s2]  <span class="comment"># 带有am/pm的12小时制时间</span></span><br><span class="line">    chattime = convert_time(chattime)  <span class="comment"># 转化为24小时制时间</span></span><br><span class="line">    content = line[s2 + <span class="number">2</span>:]  <span class="comment"># 聊天内容</span></span><br><span class="line">    insert_sql = <span class="string">f&quot;insert into log(user,datetime,content) values (&#x27;<span class="subst">&#123;name&#125;</span>&#x27;,&#x27;<span class="subst">&#123;chattime&#125;</span>&#x27; ,&#x27;<span class="subst">&#123;escape_string(content)&#125;</span>&#x27;)&quot;</span></span><br><span class="line">    cur.execute(insert_sql)</span><br><span class="line">conn.commit()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;一共有<span class="subst">&#123;<span class="built_in">len</span>(lines)&#125;</span>条聊天记录&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="聊天记录分词计算词频">聊天记录分词，计算词频</h2><p>从数据库中将数据读出，并使用<code>jieba</code>进行分词，统计每个词出现的次数，整理成<code>&#123;'word': str, 'count':number&#125;</code>的格式，并按照词频大小进行排序。</p><p>导出为使用<code>;</code>隔开的csv格式</p><blockquote><p>jieba分词的效果还是不错的，但是其实分析聊天记录的时候更想要的是关于句意吧，所以其实并没有达到我的预期。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接数据库</span></span><br><span class="line">conn = pymysql.connect(</span><br><span class="line">    host=<span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">    user=<span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    password=<span class="string">&#x27;123456&#x27;</span>,</span><br><span class="line">    db=<span class="string">&#x27;wechat_report&#x27;</span>,</span><br><span class="line">    charset=<span class="string">&#x27;utf8mb4&#x27;</span>,</span><br><span class="line">    port=<span class="number">3306</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立游标</span></span><br><span class="line">cur = conn.cursor()</span><br><span class="line"></span><br><span class="line">cur.execute(<span class="string">&quot;select * from log&quot;</span>)</span><br><span class="line">r = cur.fetchall()  <span class="comment"># 获得全部聊天记录</span></span><br><span class="line"></span><br><span class="line">result = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得最长的一句话</span></span><br><span class="line">max_item = <span class="literal">None</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> r:</span><br><span class="line">    content = item[<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">if</span> (max_item <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(content) &gt; <span class="built_in">len</span>(max_item[<span class="number">3</span>])) <span class="keyword">and</span> content.find(<span class="string">&#x27;http&#x27;</span>) == -<span class="number">1</span>:</span><br><span class="line">        max_item = item</span><br><span class="line"><span class="built_in">print</span>(max_item)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行分词</span></span><br><span class="line">word_arr = []</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> r:</span><br><span class="line">    content = item[<span class="number">3</span>]</span><br><span class="line">    seg_list = jieba.cut(content)</span><br><span class="line">    word_arr = word_arr + <span class="built_in">list</span>(seg_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算词频</span></span><br><span class="line">word_count_map = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> word_arr:</span><br><span class="line">    <span class="keyword">if</span> word <span class="keyword">in</span> word_count_map:</span><br><span class="line">        word_count_map[word] = word_count_map[word] + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        word_count_map[word] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 组合成字典</span></span><br><span class="line">word_count_arr = []</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> word_count_map:</span><br><span class="line">    o = &#123;</span><br><span class="line">        <span class="string">&#x27;word&#x27;</span>: word,</span><br><span class="line">        <span class="string">&#x27;count&#x27;</span>: word_count_map[word]</span><br><span class="line">    &#125;</span><br><span class="line">    word_count_arr.append(o)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按词频排序</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">custom_sort</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x[<span class="string">&#x27;count&#x27;</span>] &gt; y[<span class="string">&#x27;count&#x27;</span>]:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> x[<span class="string">&#x27;count&#x27;</span>] &lt; y[<span class="string">&#x27;count&#x27;</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result[<span class="string">&#x27;word&#x27;</span>] = <span class="built_in">sorted</span>(word_count_arr, key=functools.cmp_to_key(custom_sort))</span><br><span class="line"></span><br><span class="line"><span class="comment"># with open(&quot;wechat-report\bin\result.json&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:</span></span><br><span class="line"><span class="comment">#     f.write(</span></span><br><span class="line"><span class="comment">#         json.dumps(result, ensure_ascii=False)</span></span><br><span class="line"><span class="comment">#     )</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用分号隔开写入csv文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;wechat-report\bin\result.csv&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> result[<span class="string">&#x27;word&#x27;</span>]:</span><br><span class="line">        f.write(i[<span class="string">&#x27;word&#x27;</span>]+<span class="string">&#x27;;&#x27;</span>+<span class="built_in">str</span>(i[<span class="string">&#x27;count&#x27;</span>])+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="制作词云">制作词云</h2><p>词云的制作利用了一个还不错的网站<a href="https://wordart.com/create">Word Art</a>。</p><ol type="1"><li>words中使用<code>import</code>导入使用分号隔开的csv文件（复制粘贴进来）；</li><li>shapes可以选择形状；</li><li>fonts中记得导入中文字体，该网站默认仅支持英文字体；</li><li>其他的自己探索吧，我也没仔细设置，点击上方中间红色按钮<code>Visualize</code>生成词云，下载项中可以免费下载普通画质的，也还可以了。</li></ol><h2 id="参考内容">参考内容</h2><p><a href="https://github.com/myth984/wechat-report">myth984/wechat-report: 微信聊天记录年度报告 (github.com)</a></p><p><a href="https://github.com/BlueMatthew/WechatExporter">BlueMatthew/WechatExporter: Wechat Chat History Exporter 微信聊天记录导出程序 (github.com)</a></p><p><a href="https://wordart.com/create">Word Art - Edit - WordArt.com</a></p><p><a href="https://izihun.com/zitixiazai-450.html?from_code=10033">沐瑶软笔手写体(Muyao-Softbrush)_TTF字体下载-字魂网 (izihun.com)</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文记录了从微信聊天记录导出到制作完成词云图的过程&lt;/p&gt;
&lt;p&gt;利用了python，GitHub开源项目完成，默认了解python和mysql基础知识。&lt;/p&gt;
&lt;p&gt;设备：Windows、ipad&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="工具" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="词云" scheme="http://example.com/tags/%E8%AF%8D%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>hexo的迁移</title>
    <link href="http://example.com/2021/12/29/hexo%E7%9A%84%E8%BF%81%E7%A7%BB/"/>
    <id>http://example.com/2021/12/29/hexo%E7%9A%84%E8%BF%81%E7%A7%BB/</id>
    <published>2021-12-29T09:05:01.000Z</published>
    <updated>2021-12-29T12:02:08.983Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>为了重新开始写点东西，而且换了电脑，所以将博客进行了一次迁移，在此记录一些坑，其实真的很简单！，本质上就是拷贝！</p></blockquote><span id="more"></span><h2 id="安装必备环境">安装必备环境</h2><p>有关一些环境的准备在<a href="https://gipbear.github.io/2021/01/05/hexo%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/">hexo 的安装和配置</a>说明过了，当然，这不完全相同，我这次在新电脑中并没有采用yarn来安装，不过这个无所谓。</p><p>简单说明一下需要安装<code>git客户端</code>和<code>nodejs</code>，至今的npm一般在安装nodejs中都已经包含了。</p><p>安装<code>hexo</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><h2 id="git关联github">git关联github</h2><p>首先，生成本地密钥（如果已经有了则不需要），这会在本地用户的<code>.ssh</code>文件夹中出现一个私钥<code>id_rsa</code>（妥善保管！），以及一个公钥<code>id_rsa.pub</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;example@example.com&quot;</span></span><br></pre></td></tr></table></figure><p>然后在个人Github的Settings中找到侧边<a href="https://github.com/settings/keys">SSH and GPG keys</a>，点击<code>New SSH key</code>，将公钥<code>id_rsa.pub</code>中的内容复制到其中即可。</p><p>会发个邮件给你的邮箱，点击确认一下。</p><p>在git中输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssh git@github.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 出现如下内容即可：</span></span><br><span class="line"><span class="comment"># PTY allocation request failed on channel 0</span></span><br><span class="line"><span class="comment"># Hi XXX! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span><br><span class="line"><span class="comment"># Connection to github.com closed.</span></span><br></pre></td></tr></table></figure><h2 id="新建空文件夹用来做为博客使用">新建空文件夹用来做为博客使用</h2><p>初始化hexo至空文件夹<code>hexo_blog</code>中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init hexo_blog</span><br></pre></td></tr></table></figure><p>切换至<code>hexo_blog</code>文件夹中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> hexo_blog</span><br></pre></td></tr></table></figure><p>尝试启动hexo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>很不幸，我出现了一些问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ERROR Cannot find module <span class="string">&#x27;hexo&#x27;</span> from <span class="string">&#x27;E:\hexo_blog&#x27;</span></span><br><span class="line">ERROR Local hexo loading failed <span class="keyword">in</span> E:\hexo_blog</span><br><span class="line">ERROR Try running: <span class="string">&#x27;rm -rf node_modules &amp;&amp; npm install --force&#x27;</span></span><br></pre></td></tr></table></figure><p>于是我按照他的建议，执行了如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf node_modules &amp;&amp; npm install --force</span><br></pre></td></tr></table></figure><p>很不幸，又出了问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm WARN using --force I sure hope you know what you are doing.</span><br><span class="line">npm WARN deprecated urix@0.1.0: Please see https://github.com/lydell/urix<span class="comment">#deprecated</span></span><br><span class="line">npm WARN deprecated resolve-url@0.2.1: https://github.com/lydell/resolve-url<span class="comment">#deprecated</span></span><br><span class="line">npm ERR! Unexpected end of JSON input <span class="keyword">while</span> parsing near <span class="string">&#x27;...a69f8709d4bd17ffe153b&#x27;</span></span><br><span class="line"></span><br><span class="line">npm ERR! A complete <span class="built_in">log</span> of this run can be found <span class="keyword">in</span>:</span><br><span class="line">npm ERR!     C:\Users\username\AppData\Roaming\npm-cache\_logs\2021-12-29T08_54_26_243Z-debug.log</span><br></pre></td></tr></table></figure><p>经查找，发现只需要清除一下npm的cache即可，<a href="https://segmentfault.com/a/1190000015646531">原文在此</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm cache clean --force</span><br></pre></td></tr></table></figure><p>接下来再本地<code>hexo s</code>启动一下服务试试看，发现大功告成！</p><blockquote><p>以上步骤大致如此，不行就删了博客文件夹重来，反正也是空空的！</p><p>放心大胆的试吧</p></blockquote><h2 id="迁移博客">迁移博客</h2><p>实际上只需要将原电脑上的文章和一些配置拷贝过来即可，主要是三个文件夹和一个配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scaffolds</span><br><span class="line"><span class="built_in">source</span></span><br><span class="line">themes</span><br><span class="line">_config.yml</span><br></pre></td></tr></table></figure><p>首先清除public中的内容，然后重新再生成内容，并发布</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo d</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure><h2 id="完成">完成</h2><p>OK，至此就完成了，本质上也就是重新搭建博客，然后将配置文件和已经有的内容给拷贝过来就可以了，也没有很麻烦嘛!</p><h2 id="关于一些小问题">关于一些小问题</h2><p>迁移之后有很多东西可能跟之前不一样了，包括版本，安装的包之类的，所以还需要根据具体情况来自己踩坑，目前我发现了两个。</p><blockquote><p>插件都是需要自己在新设备上重新安装的，这个没有在上面的步骤中拷贝过来！！</p></blockquote><h3 id="本地图片上传失败">本地图片上传失败</h3><p>原本安装的<code>hexo-asset-image</code>插件不能使用了，重新安装后出现了严重警告和错误，经过查找资料发现是该插件不能用了，所以采用其他方法。参考<a href="https://blog.pakro.top/2021/solve_the_problem_that_after_upgrade_to_hexo5_local_image_cannot_be_displayed_while_deployed/">解决 hexo5 本地图像上传后无法显示的问题</a></p><p>首先，卸载安装的<code>hexo-asset-image</code>；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>然后，同样修改修改博客配置文件<code>_config.yml</code>中的 <code>post_asset_folder</code>为<code>true</code>；</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>最后，安装<code>post_asset_folder</code>。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>在之后在博客中就正常使用原方法传文件即可。</p><h3 id="主题中添加搜索功能">主题中添加搜索功能</h3><p>安装<code>hexo-generator-searchdb</code>插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure><p>首先修改<strong>博客</strong>配置文件<code>_config.yml</code>，如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure><p>然后，修改<strong>主题</strong>配置文件<code>_config.yml</code>如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span>  <span class="comment"># trigger若为auto, 通过改变输入触发搜索；trigger若为manual, 通过按下enter键或者点击搜索按钮触发搜索</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span>  <span class="comment"># 展示每篇文章的前n个结果，如果想要展示所有结果，设置为-1</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span>  <span class="comment"># 将html字符串转义为可读的字符串。</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span>  <span class="comment"># 当加载页面时预加载搜索结果</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;为了重新开始写点东西，而且换了电脑，所以将博客进行了一次迁移，在此记录一些坑，其实真的很简单！，本质上就是拷贝！&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="配置" scheme="http://example.com/categories/%E9%85%8D%E7%BD%AE/"/>
    
    
    <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>STP分析</title>
    <link href="http://example.com/2021/02/25/STP%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2021/02/25/STP%E5%88%86%E6%9E%90/</id>
    <published>2021-02-25T07:18:22.000Z</published>
    <updated>2021-02-25T14:17:24.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是根据《活用数据|驱动业务的数据分析实战》中的案例进行的学习总结，主要是针对彩电用户的特征和行为，从研究调查问卷组成，以及分析问卷统计用户偏好。</p><p>适用于需要结合案例学习数据分析方法的初学者。</p></blockquote><span id="more"></span><h2 id="总体思路">总体思路</h2><p>甲保险公司的主要经营业务是车险，为了在激烈的竞争中获胜，决定以精准营销为发展策略，针对车险目标用户开展定制服务。</p><p><code>研究目的</code>是其了根据用户的偏好，对用户进行精准营销。由于个体的差异，所有的用户不可能同时喜欢一个产品，即使将全部的用户作为目标市场，也只会获得部分客户购买产品，这样反而付出了巨大的代价，却获得很小的收益。所以需要开展市场细分（Market Segmenting），寻找目标市场（Market Target），进行市场定位（Market Positioning），从而达到精准营销的目的。</p><p><code>研究内容</code>主要是对客户按照不同维度进行分类，衡量用户在各个维度上的差异。主要有5种分类维度：</p><ul><li>自然属性因素：性别、年龄、地域等；</li><li>社会特征因素：收入、职业、教育等；</li><li>行为特征因素：用户购物行为的五个阶段各个因素（<a href="https://gipbear.github.io/2021/02/21/用户偏好分析案例/">用户偏好分析案例</a>中几个方面）；</li><li>态度偏好因素：心理需求、购买动机、使用习惯、使用体验与态度倾向等；</li><li>生活状态与个性因素：客户生活方式、价值观和个性特点等。</li></ul><p>其中前三种属于<code>事前分类维度</code>，这些维度表露在外，接触用户时，企业可以从中凭借经验进行分类，对企业起到<strong>验证性作用</strong>。后两种属于<code>事后分类维度</code>，需要对用户进行深入调研，才能进行了解，体现了用户的<strong>内在本质</strong>，需要根据事后的客户分类项目，从中对用户进行分类，对企业起到<strong>探索性作用</strong>。</p><h2 id="调查问卷">调查问卷</h2><p>调查问卷从以下几个方面展开：</p><ol type="1"><li>甄别问题：是否购买车险</li><li>自然属性因素：性别、年龄、城市</li><li>社会属性因素：学历、家庭月收入、职业、汽车价格</li><li>行为特征因素：<ol type="1"><li>产生需求阶段：决策时间</li><li>信息收集阶段：是否收集信息、从什么渠道收集信息</li><li>方案比选阶段：投保渠道</li><li>购买决策阶段保险公司的选择、<u>保费金额</u></li><li>购后行为阶段：索赔经历</li></ol></li><li>态度偏好因素：<u>一站式服务考虑程度</u>、<u>网上投保考虑程度</u>、<u>产品个性化考虑程度</u>、选择保险公司的考虑因素、满意度</li><li>生活状态与个性因素：<u>对自己的生活很满意</u>、<u>为享受而产生的浪费是必要的</u>、<u>买房子前要先有车</u>、<u>不惜金钱和时间装修房子</u>、<u>买衣服都买便宜的</u>、<u>休息时经常进行户外活动</u>、<u>尝试生活充满变化</u>、<u>喜欢独自享受安静的生活</u>、<u>下班后尽快回家</u>。</li></ol><h2 id="调研计划">调研计划</h2><p>与上一篇<a href="https://gipbear.github.io/2021/02/21/用户偏好分析案例/#调研计划">调研计划</a>类似，不再赘述。</p><h2 id="数据分析架构">数据分析架构</h2><p>分析的架构按照STP分析理论展开，从市场细分、目标市场和市场定位三个方面进行。</p><p>数据分析的架构如图所示。</p><img src="/2021/02/25/STP%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%9E%B6%E6%9E%84.png" class="" title="image-20210225164041236"><h3 id="客户细分">客户细分</h3><ul><li><p>首先需要确定<strong>分类维度</strong>，若选择多个维度，则需要尽量保证维度之间不存在相关性，可以使用因子分析进行处理，并进行标准化处理。</p><p>由于事先分类优于事后分类。所以选择客户<u>生活状态的9个问题</u>作为第一个细分维度。由于9个问题之间存在一定的相关性，会使得具有相关性的因素影响扩大，所以使用对数据进行降维。一般会采用<strong>因子分析</strong>，并得到<u>因子类别</u>作为最终的细分维度。</p><p>同时，客户的购买行为十分显著的区分客户购买行为，所以选择<u>保费金额</u>作为第二个细分维度。</p><p>由于因子类别是分类数据、保费金额是数值数据，两个因素的量纲并不相同，所以使用<strong>标准化统一量纲</strong>，使其具有可比性。</p></li><li><p>其次选择合适的<strong>细分方法</strong>。</p><p>单一维度的细分直接使用交叉分析就可以完成，直接找到客户在某个因素上的区别。</p><p>多个维度则需要使用一些机器学习的方法进行，根据是有监督问题还是无监督问题进行选择。</p></li><li><p>最后使用选择的细分方法对客户进行<strong>聚类</strong>。此处无监督的可以使用聚类分析方法进行，获得细分类别。对于聚类效果可以使用方差分析进行<strong>检验</strong>，依旧按照<span class="math inline">\(显著性&lt;0.05\)</span>来判断。之后给通过交叉分析和比较均值，来<strong>刻画</strong>客户在细分类别和保费金额上的区别，并给客户群体<strong>命名</strong>。</p></li></ul><h4 id="因子分析">因子分析</h4><p>对数据进行因子分析之前，要先检验原始因素中是否存在相关性。通过SPSS的<code>分析-降维-因子</code>直接进行因子分析，根据选项会得到各个计算结果。</p><ul><li>在<code>对话框的“描述”中选择KMO和Bartlett的球形度检验</code>，当<span class="math inline">\(显著性&lt;0.05\)</span>时说明适合做因子分析。</li><li>公因子方差表明提取的因子对原始因素的解释能力。总方差解释是将<span class="math inline">\(特征值&gt;1\)</span>的因子作为最后的因子。</li><li>成分矩阵存储的是因子载荷，说明提取后的各个因子对原始维度的解释程度。但是可能存在多个因子对同一个原始因素都具有解释性，这与因子分析要剔除相关性冲突，所以需要进行因子旋转，使得最终因子之间的差异最大，可以在<code>对话框的“旋转”中选择最大方差法</code>，使得每个维度上仅有一个最大的因子载荷。</li><li>在<code>对话框的“得分”中选择保存为变量和显示因子得分系数矩阵</code>，利用得到的因子得分系数矩阵能够计算各个因子的得分并保存。通过<code>转换-计算变量</code>将4个因子转化为一个变量，即因子类别。</li></ul><h4 id="聚类分析">聚类分析</h4><p>聚类分析一般有两者方法，一种是层次分析，一种迭代聚类。</p><ul><li>层次聚类：主要思想是逐层合并，按照样本距离，将最近的样本归为一类，接着将形成的类别与较近的样本合并为一类，依次聚成一类，其形状类似于一棵树状图。</li><li>迭代聚类：最常见的是K-Means聚类，根据指定的聚类数k，随机选择k个初始点，将用户归为最近的初始点，重新计算聚类后的中心点，并再次聚类，通过不断的迭代计算中心点直至收敛，获得最后的聚类结果。</li></ul><p>关于其特征和性能上的一些区别：</p><table><thead><tr class="header"><th></th><th>层次聚类</th><th>迭代聚类</th></tr></thead><tbody><tr class="odd"><td>思路</td><td>逐层合并</td><td>不断迭代</td></tr><tr class="even"><td>类别数</td><td>未知，得到树状图进行判断</td><td>需要指定</td></tr><tr class="odd"><td>计算速度</td><td>反复计算距离，大样本或多变量时候较慢</td><td>计算量小，常用于处理大样本</td></tr><tr class="even"><td>聚类对象</td><td>记录或变量</td><td>仅记录</td></tr><tr class="odd"><td>数据类型</td><td>连续变量或分类变量</td><td>连续变量</td></tr></tbody></table><h3 id="目标客户选择">目标客户选择</h3><p>这部分和上一节内容类似，主要分为市场吸引力和自身竞争力两部分来考虑。</p><ul><li><p>首先选择衡量客户吸引力和企业竞争力的<strong>指标</strong>，作为选择客户的标准。通过内部讨论，决定使用客户规模和保费金额来衡量客户吸引力，使用市场份额指标衡量企业竞争力。</p></li><li><p>其次根据各类细分客户在这些指标上的表现，计算各类客户<strong>得分</strong>。使用频数统计细分类别获得客户规模，以及均值分析获得保费金额在细分类别上的均值，得分由客户吸引力和企业竞争力加权计算得到。</p></li><li><p>最后使用矩阵分析的方法<strong>选择</strong>企业目标客户。根据获得的得分绘制散点图，形成波士顿矩阵。</p></li></ul><h3 id="目标客户定位">目标客户定位</h3><p>确定目标客户之后，需要找出目标客户的<strong>特征</strong>，以及该目标客户对哪种产品具有<strong>需求</strong>。需要进行目标客户特征描述和目标客户需求定位。</p><ul><li>目标客户的特征描述：首先利用方差分析判断目标客户与其他客户在哪些方面具有显著差异，再将具有差异的因素利用SPSS中的<code>分析-降维-最优标度</code>获得特征上的具体差异。</li><li>目标客户需求定位：同样先进行方差分析判断哪些方面具有显著差异，这些分类数据可以使用<code>交叉表</code>来描述具体差异。当得到用户不满意的结论时，需要进一步挖掘用户哪里不满意，进行深入分析。</li></ul><h2 id="个人收获">个人收获</h2><p>通过</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是根据《活用数据|驱动业务的数据分析实战》中的案例进行的学习总结，主要是针对彩电用户的特征和行为，从研究调查问卷组成，以及分析问卷统计用户偏好。&lt;/p&gt;
&lt;p&gt;适用于需要结合案例学习数据分析方法的初学者。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据分析实战" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="STP" scheme="http://example.com/tags/STP/"/>
    
  </entry>
  
  <entry>
    <title>用户偏好分析案例</title>
    <link href="http://example.com/2021/02/21/%E7%94%A8%E6%88%B7%E5%81%8F%E5%A5%BD%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/"/>
    <id>http://example.com/2021/02/21/%E7%94%A8%E6%88%B7%E5%81%8F%E5%A5%BD%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/</id>
    <published>2021-02-21T08:11:43.000Z</published>
    <updated>2021-02-25T08:01:02.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是根据《活用数据|驱动业务的数据分析实战》中的案例进行的学习总结，主要是针对彩电用户的特征和行为，从研究调查问卷组成，以及分析问卷，来统计用户偏好。</p><p>适用于需要结合案例学习数据分析方法的初学者。</p></blockquote><span id="more"></span><h2 id="总体思路">总体思路</h2><p>国内某彩电企业为了摆脱价格战，提高核心竞争力，从用户入手，针对不同用户偏好，展开差异化营销。同样地，我们需要明确研究目的和研究内容。</p><p><code>研究目的</code>很简单，就是<strong>开展差异化营销</strong>。差异化营销是使得企业最大限度地满足用户需求，从而提高企业的营业业绩；那么差异化营销在该企业是否可行，就需要考虑多个维度的因素，基于时间思维和结构思维进行分析，将用户偏好分为五个阶段和七个要素。</p><p><code>研究内容</code>就围绕五个阶段和七个要素进行展开：</p><ul><li>产生需求阶段：购买的原因（why）、决策时间（when）、了解程度（how much）</li><li>信息收集阶段：获取信息的渠道（where）、关注哪些信息（what）</li><li>方案比选阶段：比较时考虑的因素（what）、各因素考虑的程度（how）</li><li>购买决策阶段：最终买的是什么（what）</li><li>购后行为阶段：如何使用彩电（how）</li></ul><h2 id="调查问卷">调查问卷</h2><p>根据以上的研究内容，设计一份调查问卷，来获得相应的调查数据，来进行定量分析。</p><p>问卷结果由以下几个问题组成： 1. 问卷编号 2. 是否购买彩电：S1甄别问题 3. 产生需求阶段：Q1购买原因，Q2决策时间，Q3了解程度 4. 信息收集阶段：Q4信息渠道，Q5关注信息 5. 方案比选阶段：Q6刻录功能考虑程度，Q7耗电量考虑程度，Q8上网功能考虑程度，Q9他人推荐考虑程度，Q10促销活动考虑程度，Q11感兴趣的促销活动 6. 购买决策阶段：Q12品牌，Q13价格，Q14外观，Q15规格，Q16颜色 7. 购后行为阶段：Q17安装方式，Q18摆放位置 8. 用户背景信息：A1性别，A2年龄，A3学历，A4家庭收入，A5住房面积，A6家庭成员</p><h2 id="调研计划">调研计划</h2><p>完成调查问卷的创建之后，紧接着进行问卷调查，这里需要明确6个问题： * 调查方法：例如中心定点拦截访问（CIL） * 调查对象：某天之后购买过彩电的用户 * 调查地点与样本量： * 项目周期： * 项目成员及职责： * 项目经理：负责整个项目的统筹控制，业务沟通、制定方案、控制进度及质量、团队协调沟通 * 督导员：向项目经理汇报工作进展，招聘和监督访问员，对访问质量直接负责 * 访问员：负责实际访问，向督导员汇报工作进度 * 数据处理人员：调查问卷审核，数据录入，数据检查和对数据质量进行评价 * 数据分析人员：对调查和处理好的数据进行研究分析 * 报告撰写与宣讲人员：撰写分析报告并向相关领导汇报 * 项目质量与进度控制：安排跟访，保证数据真实有效性，并及时汇报和录入数据</p><h2 id="数据处理">数据处理</h2><p>调查得到的数据是最原始的数据，其中可能会出现很多的问题，所以需要对数据先进行处理，主要分为四个步骤： * 数据集成：将多个数据源的数据进行合并 * 数据转换：对数据进行标准化处理 * 数据消减：对数据进行聚合和降维，减小数据规模 * <strong>数据清洗</strong>：数据筛选、数据去重、填补缺失值和数据纠错。（本案例仅关注数据清洗）</p><h3 id="数据编码">数据编码</h3><p>其中方案比选阶段的Q6-Q10数据为数值数据，可以直接进行数据分析，而其他数据均为类别数据，需要使用编码格式进行数值转换</p><p>针对<strong>不存在大小</strong>的分类数据，可以直接使用set容器去重，再使用map进行<strong>硬编码</strong>，若存在大小的，最好还是手动创建map参数。例如下面非比较类型分类数据的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;A&#x27;</span>:[<span class="string">&#x27;一&#x27;</span>,<span class="string">&#x27;二&#x27;</span>,<span class="string">&#x27;一&#x27;</span>,<span class="string">&#x27;三&#x27;</span>,<span class="string">&#x27;一&#x27;</span>,<span class="string">&#x27;一&#x27;</span>,<span class="string">&#x27;三&#x27;</span>],</span><br><span class="line">                   <span class="string">&#x27;B&#x27;</span>:[<span class="string">&#x27;aa&#x27;</span>,<span class="string">&#x27;bb&#x27;</span>,<span class="string">&#x27;cc&#x27;</span>,<span class="string">&#x27;cc&#x27;</span>,<span class="string">&#x27;bb&#x27;</span>,<span class="string">&#x27;aa&#x27;</span>,<span class="string">&#x27;dd&#x27;</span>],</span><br><span class="line">                   <span class="string">&#x27;C&#x27;</span>:[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]&#125;)</span><br><span class="line"></span><br><span class="line">df_obj= df.select_dtypes(<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line">datamap = []</span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> df_obj.columns:</span><br><span class="line">    datamap.append(&#123;elem: index+<span class="number">1</span> <span class="keyword">for</span> index, elem <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">set</span>(df[col]))&#125;)</span><br></pre></td></tr></table></figure><h3 id="数据清洗">数据清洗</h3><p>首先通过数据筛选，将<code>S1甄别问题</code>为<code>1</code>的问卷筛选出来，因为购买了彩电的用户才是我们需要分析的用户。</p><p>然后对数据进行去重，针对的是问卷编号，保证每个问卷仅出现一次。</p><p>再对处理数据中存在的缺失值，可以找到缺失值的位置，找到相应问卷进行查看并填补；若问卷上也不存在，则对数值型数据使用统计值填补，对分类型数据使用众数填补；或者少量数据可以直接删除。</p><p>最后进行数据纠错，数据的错误类型主要有两种，一种是非逻辑错误，就是在问卷调查或录入数据的时候出现差错，这需要加强调研的各个环节的质量监控；另一种是逻辑错误，例如，性别男为“1”，女为“2”，但是录入了3，这种属于逻辑错误，需要在数据编码的时候进行控制。</p><h2 id="分析架构">分析架构</h2><p>用户偏好分析主要分为三个部分：</p><ol type="1"><li>用户基本特征描述：用户的特征不同，结论分析往往不同，可以协助业务方在下结论的时候注意应用对象。</li><li>用户整体偏好分析：对于问卷中的数值数据可以使用<strong>均值分析</strong>用户整体偏好，对于非数值数值使用<strong>频数统计</strong>反映用户整体情况。</li><li>各类用户偏好分析：将用户偏好和用户基本特征做<strong>比较均值</strong>或<strong>交叉分析</strong>。</li></ol><blockquote><p>在此之前需要利用<strong>方差分析</strong>，检验不同用户之间是否存在<strong>显著差异</strong>，若存在，做差异对比才有意义。</p></blockquote><h2 id="实例演示">实例演示</h2><p>详见我在Github上的<a href="https://github.com/Gipbear/data-analysis/blob/master/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/%E7%94%A8%E6%88%B7%E5%81%8F%E5%A5%BD%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E6%9F%90%E5%BD%A9%E7%94%B5%E4%BC%81%E4%B8%9A%E7%94%A8%E6%88%B7%E5%81%8F%E5%A5%BD%E5%88%86%E6%9E%90/%E6%9F%90%E5%BD%A9%E7%94%B5%E4%BC%81%E4%B8%9A%E7%94%A8%E6%88%B7%E5%81%8F%E5%A5%BD%E5%88%86%E6%9E%90.ipynb">代码</a></p><h2 id="分析结果解读">分析结果解读</h2><p>最后根据以上得到的各个分析结果，进行可视化图像进行分析比较，得到最终结论。</p><p>// todo: 详细的会在之后学习了数据分析经验之后再来分析一下。</p><h2 id="个人收获">个人收获</h2><p>总体上学到了有几点，首先是学会了如何设计一个比较全面的问卷调查方法，需要考虑需要的各个方面，从需求开始，从分支扩展，按照需要的、可能的、与结论相关的因素进行讨论，由此编写有效的问卷；其次第一次进行编码操作，之前学会的硬编码和热编码并没有使用，所以未知其用途，在这里发现在方差分析的时候，必须使用编码参数进行调用；最后，发现python或许是万能的，但并不是最方便的，这些统计分析之类的，需要自己慢慢编写程序，而在spss中却是及其方便，由此我以后或许可以尝试，使用python进行清洗整理数据以及机器学习相关，使用spss完成统计分析，以及使用tableau实现图表可视化。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是根据《活用数据|驱动业务的数据分析实战》中的案例进行的学习总结，主要是针对彩电用户的特征和行为，从研究调查问卷组成，以及分析问卷，来统计用户偏好。&lt;/p&gt;
&lt;p&gt;适用于需要结合案例学习数据分析方法的初学者。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据分析实战" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="调查问卷" scheme="http://example.com/tags/%E8%B0%83%E6%9F%A5%E9%97%AE%E5%8D%B7/"/>
    
    <category term="数据编码" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81/"/>
    
    <category term="方差分析" scheme="http://example.com/tags/%E6%96%B9%E5%B7%AE%E5%88%86%E6%9E%90/"/>
    
    <category term="频数统计" scheme="http://example.com/tags/%E9%A2%91%E6%95%B0%E7%BB%9F%E8%AE%A1/"/>
    
    <category term="交叉分析" scheme="http://example.com/tags/%E4%BA%A4%E5%8F%89%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>快乐Linux学习（六）</title>
    <link href="http://example.com/2021/02/19/%E5%BF%AB%E4%B9%90Linux%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89/"/>
    <id>http://example.com/2021/02/19/%E5%BF%AB%E4%B9%90Linux%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89/</id>
    <published>2021-02-19T13:25:05.000Z</published>
    <updated>2021-03-12T03:25:02.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要是介绍Linux中的正则表达式</p><p>适用于需要学习正则表达式的同学。</p></blockquote><span id="more"></span><p>正则表达式是一种符号表示法，用来识别文本模式，与之前使用过的路径通配符有些相似，但是功能更强大。</p><p>需要注意的是，很多系统和编程语言的都是具有正则表达式这个规则的，但是并不完全相同，此处仅学习Linux系统下POSIX标准中藐视的正则表达式，之后其他系统触类旁通学习即可。</p><h2 id="grep">grep</h2><p>主要使用的是grep程序，名字来自于“global regular expression print”，能够在文本文件中查找一个指定的正则表达式，并将匹配到的结果进行输出。</p><p>例如先使用ls标准输出/usr/bin的目录名，再通过管道，grep从管道中接受输入，并将匹配结果进行输出。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /usr/bin | grep zip</span><br></pre></td></tr></table></figure><p>不通过管道的表达式如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [options] regex [file...]</span><br></pre></td></tr></table></figure><p>选项options有下列情况：</p><table><thead><tr class="header"><th>选项</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>-i</td><td>忽略大小写</td></tr><tr class="even"><td>-v</td><td>获得不匹配项</td></tr><tr class="odd"><td>-c</td><td>获得匹配的数量</td></tr><tr class="even"><td>-l/-L</td><td>打印存在匹配/不匹配项的文件夹名</td></tr><tr class="odd"><td>-n</td><td>打印匹配项的行号和结果</td></tr></tbody></table><h2 id="元字符和原义字符">元字符和原义字符</h2><p>上面grep后的<code>zip</code>，其中的“z”，“i”，“p”都是按照原本的意思和顺序进行匹配的，这些称为原义字符，需要使用其他规则进行匹配的时候，还包含如下<strong>元字符</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^ $ . [ ] &#123; &#125; - ? * + ( ) | \</span><br></pre></td></tr></table></figure><p>其中POSIX 规范的字符集又将元字符又存在两种情况，基本正则表达式（BRE）和扩展的正则表达式（ERE），BRE中支持的是<code>^ $ . [ ] *</code>，ERE在此基础上扩展了<code>( ) &#123; &#125; ? + |</code>，使用的时候需要增加<code>-E</code>选项表示执行ERE标准。</p><table><thead><tr class="header"><th>元字符</th><th>解释</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>.</td><td>任何字符</td><td>可以用来匹配在某个位置的任意<strong>一个</strong>字符。</td></tr><tr class="even"><td>^ / $</td><td>锚点</td><td>该表达式在文本开头/末尾存在才会被匹配。“^$”组合可以匹配空行。</td></tr><tr class="odd"><td>[ ]</td><td>指定字符集</td><td>从中括号内的指定字符集匹配<strong>一个</strong>字符。元字符在被放置到中括号中后将会失去本身的特殊含义，除了“^”和“-”。</td></tr><tr class="even"><td>^</td><td>否定</td><td>在<strong>中括号内第一个字符</strong>时表示否定，匹配中括号内字符集以外的字符。</td></tr><tr class="odd"><td>-</td><td>字符范围</td><td>例如[a-z]，[B-Y]，[4-9a-h]等。</td></tr><tr class="even"><td>|</td><td>交替</td><td>允许从一系列表达式之间选择匹配项。</td></tr><tr class="odd"><td>？</td><td></td><td>匹配零个或一个元素。</td></tr><tr class="even"><td>*</td><td></td><td>匹配零个或多个元素。</td></tr><tr class="odd"><td>+</td><td></td><td>匹配一个或多个元素。</td></tr><tr class="even"><td>{ }</td><td></td><td>匹配特定个数的元素，n：元素只出现n次，n,m：元素出现[n,m]次，n,：元素出现不少于n次，,m：元素出现不多于m次。</td></tr></tbody></table><p>补充一些字符集：[:word:]=[:alnum:]+[_]；[:alnum:]=[:alpha:]+[:digit:]；[:blank:]=空格+tab；[:cntrl:]=0-31和127字符；[:lower:]；[:upper:]；[:punct:]=标点符号；[:print:]=[:graph:]+[:space:]；[:xdigit:]=[0-9A-Fa-f]</p><p>其他的基本都可以被视为<strong>原义字符</strong>。元字符也可以被<strong>反斜杠</strong>转义为原义字符。</p><blockquote><p>所以之前在shell执行的时候，存在的一些元字符等特殊符号会被展开，这时候就可以使用引号阻止其展开。</p></blockquote><h2 id="应用正则表达式">应用正则表达式</h2><h3 id="使用grep匹配">使用grep匹配</h3><p>首先使用下列语句生成一个测试的搜索匹配列表，多尝试几次，生成不符合“(nnn) nnn-nnnn”格式的电话号码，以便用来匹配。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i in &#123;1..10&#125;; do echo &quot;($&#123;RANDOM:0:3&#125;) $&#123;RANDOM:0:3&#125;-$&#123;RANDOM:0:4&#125;&quot; &gt;&gt;phonelist.txt; done</span><br></pre></td></tr></table></figure><p>再使用cat和管道连接grep，因为使用了扩展的正则表达式，所以需要使用-E选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat phonelist.txt | grep -Ev &#x27;^\([0-9]&#123;3&#125;\) [0-9]&#123;3&#125;-[0-9]&#123;4&#125;&#x27;</span><br></pre></td></tr></table></figure><h3 id="使用find查找">使用find查找</h3><p>查找某个路径下的文件名是否符合满足正则表达式要求，例如查找当前路径下包含空格等不符合规范的路径名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -regex &#x27;.*[^-\_./0-9a-zA-Z].*&#x27;</span><br></pre></td></tr></table></figure><h3 id="利用locate查找文件">利用locate查找文件</h3><p>locate支持基本的（--regexp）和扩展的（regex）正则表达式。例如搜索包含指定字符串的路径名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate --regex &#x27;bin/(bz|gz|zip)&#x27;</span><br></pre></td></tr></table></figure><h3 id="在lessvim中使用正则表达式">在less/vim中使用正则表达式</h3><p>less是使用“<code>/</code>”命令输入正则表达式进行匹配</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">less phonelist.txt</span><br><span class="line">/^\([0-9]&#123;3&#125;\) [0-9]&#123;3&#125;-[0-9]&#123;4&#125;$</span><br></pre></td></tr></table></figure><p>vim也类似，不过vim中使用扩展表达式会被认作为文本字符，需要使用反斜杠进行转义为元字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/([0-9]\&#123;3\&#125;) [0-9]\&#123;3\&#125;-[0-9]\&#123;4\&#125;</span><br></pre></td></tr></table></figure><p>默认是没有高亮显示的，想要高亮显示的话可以在命令模式下输入<code>:set hlsearch</code>转化为高亮模式。</p><h2 id="个人收获">个人收获</h2><p>本章主要学习的是正则表达式，了解到不同系统和语言会具有不完全相同的正则表达式，主要是用于之后的查找和筛选，以及在处理数据的时候能够利用规则直接提取相关信息，比较重要。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文主要是介绍Linux中的正则表达式&lt;/p&gt;
&lt;p&gt;适用于需要学习正则表达式的同学。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="正则表达式" scheme="http://example.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>战略分析案例——网上商城</title>
    <link href="http://example.com/2021/02/16/%E6%88%98%E7%95%A5%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/"/>
    <id>http://example.com/2021/02/16/%E6%88%98%E7%95%A5%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/</id>
    <published>2021-02-16T11:42:23.000Z</published>
    <updated>2021-02-25T07:42:18.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是根据《活用数据|驱动业务的数据分析实战》中的案例进行的学习总结，主要是从内外部因素对企业网上商城进行定性和定量分析，并结合波士顿矩阵进行分析。</p><p>适用于需要结合案例学习数据分析方法的初学者。</p></blockquote><span id="more"></span><h2 id="总体思路">总体思路</h2><p>进行战略分析的分析思路是进行研究目的和研究内容的分解，下面对此分别进行考虑。</p><p>首先考虑<code>研究目的</code>，这里是帮助商城进行<strong>战略选择</strong>，选择最适合商城的目标市场。对此我们需要分析两个因素：</p><ul><li>外部因素——市场吸引力：市场情况如何，是否有希望获得足够的利益；</li><li>内部因素——企业竞争力：企业是否有能力进入市场，进入市场后能够获得多少利益。</li></ul><p>其次分析<code>研究内容</code>，主要是进行环境分析，包括宏观环境、市场环境、竞争环境分析。</p><h2 id="环境分析">环境分析</h2><h3 id="宏观环境分析">宏观环境分析</h3><p>宏观环境是指影响市场的各种宏观原因，可以利益PEST进行概况：</p><ul><li>政治环境 Political</li><li>经济环境 Economic</li><li>社会文化环境 Social</li><li>技术环境 Technological</li></ul><p>通过宏观环境分析，企业可以判断出，对某企业而言，哪些因素是机会，哪些因素是威胁，若<strong>机会大于威胁</strong>，则说明该市场具有吸引力。</p><h3 id="市场环境分析">市场环境分析</h3><p>市场环境是指市场的<strong>具体情况</strong>，需要考虑的因素比较多，比较倾向于市场规模大、利润水平高、增长速度快、成长潜力强、所处生命周期成长期等，这种市场对于企业更具有吸引力。但是大部分市场并不会同时满足以上条件，所以，需要企业按照自身资源和定位情况进行取舍。</p><p>通过以上宏观环境和市场环境可以分析得出市场对企业是否具有吸引力，但是并不是具有吸引力的市场，就一定会使得企业获利，因为我们还需要对比企业自身优势进行分析。优势并不是绝对的，而是相对的，其相对于竞争环境，所以需要进行竞争环境分析。</p><h3 id="竞争环境分析">竞争环境分析</h3><p>企业的竞争环境可以归纳为影响企业生存状况的波特五力，包括供应商、购买者、直接竞争对手、替代品和潜在进入者五个方面的力。</p><p>通过对比分析这企业在五力中的情况，如果总体处于上风，则表明企业具有竞争力。</p><h2 id="实例演示">实例演示</h2><p>本案例是在jupyter上进行的，可以参考我在Github上相应的<a href="https://github.com/Gipbear/data-analysis/blob/master/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/%E8%B4%AD%E7%89%A9%E4%B8%AD%E5%BF%83%E7%BD%91%E4%B8%8A%E5%95%86%E5%9F%8E%E6%88%98%E7%95%A5%E5%88%86%E6%9E%90/%E6%9F%90%E8%B4%AD%E7%89%A9%E4%B8%AD%E5%BF%83%E7%BD%91%E4%B8%8A%E5%95%86%E5%9F%8E%E6%88%98%E7%95%A5%E5%88%86%E6%9E%90.ipynb">代码</a></p><ol type="1"><li><p>首先导入需要使用的依赖包（个人偏好都添加在第一行）;</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> mpl</span><br><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> set_matplotlib_formats</span><br><span class="line"></span><br><span class="line">%matplotlib inline</span><br></pre></td></tr></table></figure></p></li><li><p>读取excel表格，依次读取各个sheet中的内外因素评价矩阵;</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">df1 = pd.read_excel(<span class="string">&#x27;data/内外因素评价矩阵数据.xlsx&#x27;</span>,sheet_name=<span class="number">0</span>)</span><br><span class="line">col_name = [<span class="string">&#x27;分数&#x27;</span>,<span class="string">&#x27;电商在销售渠道地位凸显&#x27;</span>,<span class="string">&#x27;国内消费者信心指数攀升&#x27;</span>,<span class="string">&#x27;电子商务交易额迅速增长&#x27;</span>,<span class="string">&#x27;通过电商可以掌握用户界面&#x27;</span>,<span class="string">&#x27;国家政策的扶持&#x27;</span>]</span><br><span class="line">df1.columns = col_name</span><br><span class="line"></span><br><span class="line">df2 = pd.read_excel(<span class="string">&#x27;data/内外因素评价矩阵数据.xlsx&#x27;</span>,sheet_name=<span class="number">1</span>)</span><br><span class="line">col_name = [<span class="string">&#x27;分数&#x27;</span>,<span class="string">&#x27;激烈的市场竞争&#x27;</span>,<span class="string">&#x27;电子商务诚信制度未完善&#x27;</span>,<span class="string">&#x27;网络安全缺乏坚实保障&#x27;</span>]</span><br><span class="line">df2.columns = col_name</span><br><span class="line"></span><br><span class="line">df3 = pd.read_excel(<span class="string">&#x27;data/内外因素评价矩阵数据.xlsx&#x27;</span>,sheet_name=<span class="number">2</span>)</span><br><span class="line">col_name = [<span class="string">&#x27;分数&#x27;</span>,<span class="string">&#x27;实力强大&#x27;</span>,<span class="string">&#x27;消费者信誉良好&#x27;</span>,<span class="string">&#x27;良好的企业形象&#x27;</span>,<span class="string">&#x27;透明化贴心服务&#x27;</span>]</span><br><span class="line">df3.columns = col_name</span><br><span class="line"></span><br><span class="line">df4 = pd.read_excel(<span class="string">&#x27;data/内外因素评价矩阵数据.xlsx&#x27;</span>,sheet_name=<span class="number">3</span>)</span><br><span class="line">col_name = [<span class="string">&#x27;分数&#x27;</span>,<span class="string">&#x27;缺乏电商运营经验&#x27;</span>,<span class="string">&#x27;缺乏网购消费者群体&#x27;</span>,<span class="string">&#x27;网站建设不完整&#x27;</span>,<span class="string">&#x27;物流体系未真正建成&#x27;</span>]</span><br><span class="line">df4.columns = col_name</span><br></pre></td></tr></table></figure></p></li><li><p>计算权重分为两个步骤：</p><ol type="1"><li><p>计算评分均值：将专家人数作为权重<span class="math inline">\(f\)</span>，对分数<span class="math inline">\(x_i\)</span>求其加权平均值： <span class="math display">\[ \bar{x} = \frac{\sum{x_i \times f_i}}{\sum{f_i}} \]</span></p></li><li><p>计算权重：权重的确定方法有很多，大体分为主观赋权法（层次分析法等）和客观赋权法（主成分分析法等），此处采用变异系数方法来计算： <span class="math display">\[ \text{V} = \frac{\sigma}{\bar{x}}  \]</span> 其中<span class="math inline">\(\sigma\)</span>是标准差，<span class="math inline">\(\sigma=\sqrt{\sum{(x_i-x)^2 \times Pi}}\)</span>，而其中<span class="math inline">\(\sum{(x_i-x)^2}\)</span>是该因素的离差平方和，<span class="math inline">\(P_i\)</span>是该因素的频率。</p></li></ol><blockquote><p>在评价体系中，若某个因素的取值差异较大，则说明该因素难以实现，是反映评价对象差距的关键因素，就要赋予更大的权重。</p><p>变异系数在数值上等于标准差除以均值，可以表示因素取值的波动情况，因此这里可以使用变异系数来赋权。</p></blockquote><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算变异系数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coefficient_variation</span>(<span class="params">df,dfn,num</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    df: 统计矩阵</span></span><br><span class="line"><span class="string">    dfn: 矩阵编号</span></span><br><span class="line"><span class="string">    num: 样本数</span></span><br><span class="line"><span class="string">    res: 样本评分</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    me = df[<span class="string">&#x27;分数&#x27;</span>].dot(df.iloc[:,<span class="number">1</span>:])/num <span class="comment"># 计算评分均值</span></span><br><span class="line">    dfa = df.iloc[:,<span class="number">1</span>:]/num <span class="comment"># 计算分数频率</span></span><br><span class="line">    s = df[<span class="string">&#x27;分数&#x27;</span>]-me[dfn]</span><br><span class="line">    dfb = s*s <span class="comment"># 计算分数离差平方和</span></span><br><span class="line">    dfc = dfb.dot(dfa).apply(np.sqrt) <span class="comment"># 计算标准差</span></span><br><span class="line">    dfd = dfc/me[dfn] <span class="comment"># 计算变异系数</span></span><br><span class="line">    <span class="keyword">return</span> dfd,me</span><br></pre></td></tr></table></figure></p></li><li><p>求得变异系数<span class="math inline">\(\text{V}\)</span>之后，使用<span class="math inline">\(W_i=\frac{V_i}{\sum{V_i}}\)</span>求得最终的权重，并计算各个评分均值加权平均数来获得最终的得分。</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算最后得分</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_score</span>(<span class="params">coeVar,me</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    coeVar: 变异系数</span></span><br><span class="line"><span class="string">    me: 评分均值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    weights = coeVar / <span class="built_in">sum</span>(coeVar) <span class="comment"># 计算权重</span></span><br><span class="line">    score = weights.dot(me) <span class="comment"># 计算评分的加权平均数</span></span><br><span class="line">    <span class="keyword">return</span> score</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">coeVar, me= coefficient_variation(df1,<span class="number">0</span>,<span class="number">200</span>)</span><br><span class="line">score1 = get_score(coeVar,me)</span><br><span class="line">coeVar, me= coefficient_variation(df2,<span class="number">1</span>,<span class="number">200</span>)</span><br><span class="line">score2 = get_score(coeVar,me)</span><br><span class="line">coeVar, me= coefficient_variation(df3,<span class="number">2</span>,<span class="number">2000</span>)</span><br><span class="line">score3 = get_score(coeVar,me)</span><br><span class="line">coeVar, me= coefficient_variation(df4,<span class="number">3</span>,<span class="number">2000</span>)</span><br><span class="line">score4 = get_score(coeVar,me)</span><br></pre></td></tr></table></figure></p></li><li><p>得到各个优势、劣势、机会和威胁的最终得分之后，计算<span class="math inline">\(\frac{优势}{劣势}\)</span>的比值是否大于1，若大于1则说明优势大于劣势，企业具有竞争力，否则不具有竞争力；计算<span class="math inline">\(\frac{机会}{威胁}\)</span>的比值是否大于1，若大于1则说明机会大于威胁，市场具有吸引力，否则不具有吸引力。</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = score1/score2</span><br><span class="line">y = score3/score4</span><br></pre></td></tr></table></figure></p></li><li><p>根据求得的两个比值制作战略选择波士顿矩阵图，进行战略选择分析：</p><ol type="1"><li>SO战略：市场机会多，企业优势明显，属于增长型，利用外部机会和自身优势，创造最大收益；</li><li>WO战略：市场机会多，企业劣势明显，属于扭转型，利用外部机会，克服自身劣势，抓住机遇；</li><li>ST战略：市场威胁多，企业优势明显，属于多种经营型，依靠自身优势，回避外部威胁，勇敢面对挑战；</li><li>WT战略：市场威胁多，企业劣势明显，属于防御型，减少外部威胁和自身劣势，休养生息。</li></ol><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">set_matplotlib_formats(<span class="string">&#x27;svg&#x27;</span>)</span><br><span class="line">mpl.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>] <span class="comment"># 中文字体</span></span><br><span class="line"></span><br><span class="line">lim = <span class="built_in">max</span>(<span class="built_in">round</span>(x,<span class="number">1</span>),<span class="built_in">round</span>(y,<span class="number">1</span>)) + <span class="number">0.2</span> <span class="comment"># 坐标区间</span></span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">plt.scatter(x,y,marker=<span class="string">&#x27;o&#x27;</span>,s=<span class="number">100</span>) <span class="comment"># 绘制散点图</span></span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">&#x27;机会最终得分/威胁最终得分&#x27;</span>,fontsize=<span class="number">16</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;优势最终得分/劣势最终得分&#x27;</span>,fontsize=<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">plt.xlim(<span class="number">0</span>,lim)</span><br><span class="line">plt.ylim(<span class="number">0</span>,lim)</span><br><span class="line"></span><br><span class="line">plt.vlines(<span class="number">1</span>,<span class="number">0</span>,lim,colors=<span class="string">&quot;r&quot;</span>,linestyles=<span class="string">&quot;dashed&quot;</span>)</span><br><span class="line">plt.hlines(<span class="number">1</span>,<span class="number">0</span>,lim,colors=<span class="string">&quot;r&quot;</span>,linestyles=<span class="string">&quot;dashed&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.text(x+<span class="number">0.001</span>,y,<span class="string">&#x27;&#123;:.2f&#125; &#123;:.2f&#125;&#x27;</span>.<span class="built_in">format</span>(x,y),ha=<span class="string">&#x27;left&#x27;</span>,va=<span class="string">&#x27;bottom&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.text(<span class="number">0.02</span>,lim-<span class="number">0.12</span>,<span class="string">&#x27;&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;ST战略&#x27;</span>),ha=<span class="string">&#x27;left&#x27;</span>,va=<span class="string">&#x27;bottom&#x27;</span>,color=<span class="string">&quot;w&quot;</span>,fontsize=<span class="number">20</span>).set_bbox(<span class="built_in">dict</span>(facecolor=<span class="string">&#x27;black&#x27;</span>, alpha=<span class="number">0.5</span>))</span><br><span class="line">plt.text(<span class="number">0.02</span>,<span class="number">1</span>-<span class="number">0.12</span>,<span class="string">&#x27;&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;WT战略&#x27;</span>),ha=<span class="string">&#x27;left&#x27;</span>,va=<span class="string">&#x27;bottom&#x27;</span>,color=<span class="string">&quot;w&quot;</span>,fontsize=<span class="number">20</span>).set_bbox(<span class="built_in">dict</span>(facecolor=<span class="string">&#x27;black&#x27;</span>, alpha=<span class="number">0.5</span>))</span><br><span class="line">plt.text(<span class="number">1.02</span>,lim-<span class="number">0.12</span>,<span class="string">&#x27;&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;SO战略&#x27;</span>),ha=<span class="string">&#x27;left&#x27;</span>,va=<span class="string">&#x27;bottom&#x27;</span>,color=<span class="string">&quot;w&quot;</span>,fontsize=<span class="number">20</span>).set_bbox(<span class="built_in">dict</span>(facecolor=<span class="string">&#x27;black&#x27;</span>, alpha=<span class="number">0.5</span>))</span><br><span class="line">plt.text(<span class="number">1.02</span>,<span class="number">1</span>-<span class="number">0.12</span>,<span class="string">&#x27;&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;SWO战略&#x27;</span>),ha=<span class="string">&#x27;left&#x27;</span>,va=<span class="string">&#x27;bottom&#x27;</span>,color=<span class="string">&quot;w&quot;</span>,fontsize=<span class="number">20</span>).set_bbox(<span class="built_in">dict</span>(facecolor=<span class="string">&#x27;black&#x27;</span>, alpha=<span class="number">0.5</span>))</span><br></pre></td></tr></table></figure></p></li></ol><p>最终得到波士顿矩阵，如图：</p><img src="/2021/02/16/%E6%88%98%E7%95%A5%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/%E7%BD%91%E4%B8%8A%E5%95%86%E5%9F%8E%E6%88%98%E7%95%A5%E5%88%86%E6%9E%90%E6%B3%A2%E5%A3%AB%E9%A1%BF%E7%9F%A9%E9%98%B5%E5%9B%BE.svg" class="" title="网上商城战略分析波士顿矩阵图"><h2 id="结论">结论</h2><p>该购物中心网上商城的业务处于SO战略区，市场机会多，自身优势明显，可以充分利用市场机会和自身优势快速发展，创建最佳业务。</p><h2 id="个人收获">个人收获</h2><p>通过本案例的学习，首先掌握了PEST和波特五力两种分析思路，从宏观和细节上对分析对象进行细化；SWOT定性分析方法将细化后的对象进行内外因素分析，并通过量化方法进行定量分析。该案例有层次的、内外结合的、定性定量的分析，学习了如何进行一次全面的战略分析。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是根据《活用数据|驱动业务的数据分析实战》中的案例进行的学习总结，主要是从内外部因素对企业网上商城进行定性和定量分析，并结合波士顿矩阵进行分析。&lt;/p&gt;
&lt;p&gt;适用于需要结合案例学习数据分析方法的初学者。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据分析实战" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="战略分析" scheme="http://example.com/tags/%E6%88%98%E7%95%A5%E5%88%86%E6%9E%90/"/>
    
    <category term="PEST" scheme="http://example.com/tags/PEST/"/>
    
    <category term="SWOT" scheme="http://example.com/tags/SWOT/"/>
    
    <category term="波特五力" scheme="http://example.com/tags/%E6%B3%A2%E7%89%B9%E4%BA%94%E5%8A%9B/"/>
    
    <category term="波士顿矩阵" scheme="http://example.com/tags/%E6%B3%A2%E5%A3%AB%E9%A1%BF%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
  <entry>
    <title>林骥的思维分析模型（一）</title>
    <link href="http://example.com/2021/02/12/%E6%9E%97%E9%AA%A5%E7%9A%84%E6%80%9D%E7%BB%B4%E5%88%86%E6%9E%90%E6%A8%A1%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://example.com/2021/02/12/%E6%9E%97%E9%AA%A5%E7%9A%84%E6%80%9D%E7%BB%B4%E5%88%86%E6%9E%90%E6%A8%A1%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2021-02-12T04:14:05.000Z</published>
    <updated>2021-12-29T12:02:44.391Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是在对林骥公众号中的100种思维分析模型（更新中）上进行自我理解。</p><p>适用于想要了解多种分析模型的同学，主要是关于模型的一些应用和注意点，并没有具体的模型详解。</p></blockquote><span id="more"></span><h2 id="福格行为模型">福格行为模型</h2><p>该模型主要是用来分析<code>用户行为</code>的<u>产生原因</u>和<u>基础心理</u>。</p><p><span class="math display">\[行为 = 动机 \times 能力 \times 触发\]</span> 用户的行为由三要素决定（例如购物）：</p><ol type="1"><li>用户去做这件事情的动机（why用户购买产品）；</li><li>用户完成这件事情的能力（how让用户方便购买）；</li><li>触发用户去采取行动的信号（what触发用户想要购买）。</li></ol><p>在其中也暗含了4p营销理论：产品（Product）、价格（Price）、促销（Promotion）、渠道（Place）</p><h2 id="杜邦分析模型">杜邦分析模型</h2><p>该模型主要是对关键指标进行分解，在<code>财务分析</code>、<code>销售管理</code>方面有助于深入分析企业的经营业绩。</p><p>杜邦分析模型将指标之间的<u>内在联系</u>结合起来，形成一套类似金字塔结构，层次清晰的指标体系，从而暴露出影响业务的关键因素。</p><ol type="1"><li>从核心指标开始，逐层分解各个指标；</li><li>制作杜邦分析图，填入相关指标数据；</li><li>对比前后期数据，或者横向进行对比。</li></ol><h2 id="矩阵分析模型">矩阵分析模型</h2><p>该模型也称作波士顿矩阵或四象限分析法。通过两个关键指标组成象限即可进行分析。主要是用来分析<code>产品和结构</code>，其中特别关注<strong>销售增长率</strong>和<strong>市场占有率</strong>这两个指标。</p><ol type="1"><li>找出两种最关注的指标（销售增长率A和市场占有率B）；</li><li>绘制四象限分析图表（假设增长方向为从左至右和从下至上）；</li><li>分析总结并提出建议（AB均低的产品可以逐渐放弃，A高B低是有问题的产品，需要调整策略，A低B高则可以保持现状，AB均高的可以考虑加大投资）；</li></ol><p>针对不同的象限将产品进行分类，由此来采取不同的发展策略，从而实现产品结构的良性循环。</p><h2 id="夏普利值模型">夏普利值模型</h2><p>该模型综合考虑各方利益，使得所作和所得相等，保证利益分配的公平合理。主要在分配权力等问题上非常有用。</p><ol type="1"><li>列举角色可能出现的各种分配情况；</li><li>判断角色在分配过程是否起作用；</li><li>计算分析角色起作用的占比情况。</li></ol><p>价值并不在于拥有的资源或历史贡献，而是在所有可能的合作中，不可或缺的程度。</p><blockquote><p>我们的成长也需要提高核心竞争力。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是在对林骥公众号中的100种思维分析模型（更新中）上进行自我理解。&lt;/p&gt;
&lt;p&gt;适用于想要了解多种分析模型的同学，主要是关于模型的一些应用和注意点，并没有具体的模型详解。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="他山之石" scheme="http://example.com/categories/%E4%BB%96%E5%B1%B1%E4%B9%8B%E7%9F%B3/"/>
    
    
    <category term="思维方式" scheme="http://example.com/tags/%E6%80%9D%E7%BB%B4%E6%96%B9%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>mysql中位数</title>
    <link href="http://example.com/2021/02/06/mysql%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://example.com/2021/02/06/mysql%E4%B8%AD%E4%BD%8D%E6%95%B0/</id>
    <published>2021-02-06T15:15:59.000Z</published>
    <updated>2021-02-06T15:33:40.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是在mysql中查询一列<strong>奇数</strong>个数据的中位数。</p></blockquote><span id="more"></span><p>在<a href="https://www.hackerrank.com/dashboard">HackerRank</a>刷题的时候遇到了一道需要查询中位数的题目。</p><h2 id="题目">题目</h2><p>将中位数定义为：将数据集的上半部分与下半部分分开的数字，也就是仅存在一个中位数。</p><p>需要找出某列的中位数。</p><h2 id="思路">思路</h2><p>Station表中存在奇数个数据，那么我们要查找的LAT_N就是将数据分开后使得：上半部分个数=下半部分个数。</p><p>于是我们需要在查询该表Station S的同时，再创建两个相同的Station表来计算上下部分的LAT_N个数，在检查记录的同时比较上下两部分的数量，当数量相同的时候，该S.LAT_N就是需要得到的中位数。</p><h2 id="方案">方案</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select round(s.LAT_N,4)</span><br><span class="line">from station s</span><br><span class="line">where (select count(LAT_N)</span><br><span class="line">       from station</span><br><span class="line">       where LAT_N &lt; s.LAT_N) = (</span><br><span class="line">           select count(LAT_N)</span><br><span class="line">           from station</span><br><span class="line">           where (LAT_N &gt; s.LAT_N))</span><br></pre></td></tr></table></figure><h2 id="个人收获">个人收获</h2><p>当遇到比较抽象的问题的时候，需要学会转换思路，将抽象的中位数定义，转化为现实的，上下部分数量相同问题；也要熟悉mysql中创建新表和原表比较的方法。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是在mysql中查询一列&lt;strong&gt;奇数&lt;/strong&gt;个数据的中位数。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="增删改查" scheme="http://example.com/categories/%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/"/>
    
    
    <category term="mysql" scheme="http://example.com/tags/mysql/"/>
    
    <category term="select" scheme="http://example.com/tags/select/"/>
    
    <category term="中位数" scheme="http://example.com/tags/%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    
  </entry>
  
</feed>
