<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数组解题技巧2——差分数组</title>
    <url>/2022/01/07/%E6%95%B0%E7%BB%84%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A72%E2%80%94%E2%80%94%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<blockquote>
<p>本文是关于数组的差分数组技巧，在对元素数组区间进行加减计算时使用。</p>
<p>涉及 leetcode 的<a href="https://leetcode-cn.com/problems/range-addition">370. 区间加法</a>、<a href="https://leetcode-cn.com/problems/corporate-flight-bookings">1109. 航班预订统计</a>和<a href="https://leetcode-cn.com/problems/car-pooling">1094. 拼车</a>。</p>
</blockquote>
<span id="more"></span>
<h2 id="合并两个有序链表">合并两个有序链表</h2>
<h3 id="题目1">题目1</h3>
<p>首先来看题目<a href="https://leetcode-cn.com/problems/range-addition">370. 区间加法</a>：假设你有一个长度为 n 的数组，初始情况下所有的数字均为 0，你将会被给出 k 个更新的操作。其中，每个操作会被表示为一个三元组：[startIndex, endIndex, inc]，你需要将子数组 A[startIndex ... endIndex]（包括 startIndex 和 endIndex）增加 inc。</p>
<p>请你返回 k 次操作后的数组。</p>
<p>示例1： &gt; 输入：length = 5, updates = [ [1,3,2],[2,4,3],[0,2,-2] ] &gt; &gt; 输出：[-2,0,3,5,3]</p>
<h3 id="理解一下1">理解一下1</h3>
<p>题目的大概意思就是：</p>
<ol type="1">
<li>初始数组为元素均为 0；</li>
<li>三元组表示在区间<code>startIndex</code>到<code>endIndex</code>内的元素都加上<code>inc</code>。</li>
</ol>
<p>最直白的思路就是，将每个三元组表示的区间一个一个加上值，很快就能实现，但是复杂度太高会超时，那么怎么办呢？</p>
<p>这里引入<strong>差分数组</strong>的概念：</p>
<p>差分数组就是在原长度为<code>n</code>的<code>nums</code>数组上，构建一个长度为<code>n+1</code>的数组<code>diff</code>，<code>diff[i] = nums[i] - nums[i-1]</code>，也就是原数组相邻两项的之差。</p>
<p>当差分数组计算完成之后再通过<code>nums[i] = nums[i-1] + diff[i]</code>即可还原得到相应的数组。</p>
<blockquote>
<p>对差分数组的第<code>i</code>项进行计算，都会同等影响到之后的剩余项，这就是差分数组的<strong>性质</strong>！</p>
</blockquote>
<p>因此，我们可以在差分数组上对第<code>first</code>项加上<code>seats</code>，使得后续的每一项都会增加<code>seats</code>，但是我们只想增加到第<code>last</code>项，所以在第<code>last+1</code>项之后再减去<code>seats</code>，就可以抵消该影响啦！</p>
<p>ok，那我们就来看代码吧！</p>
<h3 id="解题1">解题1</h3>
<p>构建差分数组的时候，使得差分数组的长度为<code>n+1</code>可以使得不用判断数组越界的问题，这个和链表增加<strong>头结点</strong>有异曲同工之妙。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">getModifiedArray</span><span class="params">(<span class="keyword">int</span> length, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; updates)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实际上计算的nums是差分数组，只不过这里开始都为0</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(length+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; updates.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        nums[updates[i][<span class="number">0</span>]] += updates[i][<span class="number">2</span>];</span><br><span class="line">        nums[updates[i][<span class="number">1</span>]+<span class="number">1</span>] -= updates[i][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 差分数组还原</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++)&#123;</span><br><span class="line">        nums[i] += nums[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    nums.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于<a href="https://leetcode-cn.com/problems/corporate-flight-bookings">1109. 航班预订统计</a>和<a href="https://leetcode-cn.com/problems/car-pooling">1094. 拼车</a>这两个问题实际上就是将该简单问题应用到实际场景中了，学会了这个差分数组的思想就很容易了，只需要注意端点细节处理即可。</p>
<h2 id="个人收获">个人收获</h2>
<ol type="1">
<li><p>前缀和数组用于计算区域和问题，差分数组用于区域元素同时加减问题，而且使用频率较高时使用效果较好。</p></li>
<li><p>注意将数组长度扩大一个，这个在计算相邻项的时候就无需判断在数组最后是否会出现数组越界的问题，与链表中增加头结点的效果类似。</p></li>
</ol>
]]></content>
      <categories>
        <category>数据结构算法</category>
      </categories>
      <tags>
        <tag>leetcode题解</tag>
        <tag>c++</tag>
        <tag>数组</tag>
        <tag>差分数组</tag>
      </tags>
  </entry>
  <entry>
    <title>数组解题技巧1——前缀和数组</title>
    <url>/2022/01/07/%E6%95%B0%E7%BB%84%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A71%E2%80%94%E2%80%94%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<blockquote>
<p>本文是关于数组的前缀和技巧，在快速计算一个数组区间内的元素之和时使用</p>
<p>涉及 leetcode 的 <a href="https://leetcode-cn.com/problems/range-sum-query-immutable">303. 区域和检索 - 数组不可变</a>、<a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable">304. 二维区域和检索 - 矩阵不可变</a>和<a href="https://leetcode-cn.com/problems/subarray-sum-equals-k">560. 和为 K 的子数组</a>。</p>
</blockquote>
<span id="more"></span>
<h2 id="区域检索">区域检索</h2>
<h3 id="题目1">题目1</h3>
<p>首先来看题目<a href="https://leetcode-cn.com/problems/range-sum-query-immutable">303. 区域和检索 - 数组不可变</a>：给定一个整数数组 nums，求出数组从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点。</p>
<p>示例1： &gt; 输入：[ [ [-2, 0, 3, -5, 2, -1] ], [0, 2], [2, 5], [0, 5] ] &gt; &gt; 输出：[null, 1, -1, -3]</p>
<h3 id="理解一下1">理解一下1</h3>
<p>题目的大概意思就是：计算数组内某个区域的和。</p>
<p>代码要求有两点，一个是写出构造函数，一个是写出计算区域和的函数。</p>
<p>基本的思路是：</p>
<ol type="1">
<li>构造函数直接将数组传递过去就行；</li>
<li>在<code>sumRange</code>中使用循环计算<code>left</code>到<code>right</code>的和。</li>
</ol>
<p>很简单的嘛，OK确实，但是提交了发现超越的人数不多呀，这怎么行！</p>
<p>仔细思考发现 OJ 测试的时候构造函数仅仅调用<strong>一次</strong>，而计算区域和函数调用了<strong>多次</strong>，所以我们需要优化<code>sumRange</code>函数。</p>
<p>于是考虑使用前缀和，使得构造函数麻烦一些，但是使得<code>sumRange</code>函数<strong>简单</strong>一些：</p>
<ol type="1">
<li>使用构造函数时，直接在传递数组时，计算前<code>n</code>项的前缀累加和，时间复杂度为<code>O(n)</code>；</li>
<li>然后<code>sumRange</code>函数计算<code>left</code>到<code>right</code>的区域和时，只需要使用第<code>right</code>项的前缀和减去第<code>left-1</code>项前缀和即可，<code>sumRange</code>的时间复杂度就是<code>O(1)</code>。</li>
</ol>
<h3 id="解题1">解题1</h3>
<p>先看解法一：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;nums = nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; i++)&#123;</span><br><span class="line">            sum += <span class="keyword">this</span>-&gt;nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>再看使用前缀和的解法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; presums;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="comment">// 构造时为 n 的复杂度</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;presums.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;presums[i] = <span class="keyword">this</span>-&gt;presums[i<span class="number">-1</span>] + nums[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用时仅需要直接索引相减即可</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;presums[right+<span class="number">1</span>] - <span class="keyword">this</span>-&gt;presums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>关于<a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable">304. 二维区域和检索 - 矩阵不可变</a>这题，只不过是从一维变化成了二维，大家举一反三即可。</p>
<p>需要注意的仅仅是边界的细节问题。</p>
<h2 id="和为-k-的子数组">和为 K 的子数组</h2>
<h3 id="题目2">题目2</h3>
<p>首先来看题目<a href="https://leetcode-cn.com/problems/subarray-sum-equals-k">560. 和为 K 的子数组</a>：给你一个整数数组 nums 和一个整数 k ，请你统计并返回该数组中和为 k 的连续子数组的个数。</p>
<p>示例1： &gt; 输入：nums = [1,1,1], k = 2 &gt; &gt; 输出：2</p>
<p>示例2： &gt; 输入：nums = [1,2,3], k = 3 &gt; &gt; 输出：2</p>
<h3 id="理解一下2">理解一下2</h3>
<p>题目的大概意思就是：计算出，给定数组中有多少个连续子数组的和为 K，也就是给定数组中有多少个区间和为K。</p>
<p>最基本的思路就是穷举嘛，嵌套循环，计算所有区间的数组之和，判断其是否为 K。不过很遗憾，时间复杂度<span class="math inline">\(O(n^2)\)</span>在10000大小的测试案例中超时了。</p>
<p>再仔细看看区域和为K，关于区域和那我们很自然的想到使用前缀和数组试试看了：</p>
<ol type="1">
<li>计算前缀和数组；</li>
<li>我们要计算区域和，就得使用前缀和数组的端点值相减，并判断是否为K，如此一来时间复杂度又回到了<span class="math inline">\(O(n^2)\)</span>；</li>
<li>换个思路，验证<code>i</code>处的前缀和<code>sum_i</code>减去<code>K</code>的差值<code>sum_j</code>，判断<code>sum_j</code>是否已经<strong>存在</strong>已知的前缀和数组中，若存在则统计<strong>出现次数</strong>即可！</li>
<li><code>sum_j</code>出现的次数就是i为右端点的区间可以出现的次数，随着不断计算前缀和数组和计数，那么时间复杂度仅仅是计算前缀和的时间O(n)。</li>
</ol>
<h3 id="题解2">题解2</h3>
<p>判断存在计数可以使用<strong>hash表</strong>来实现，快速高效。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用hash表来记录前缀和出现的次数</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; presum;</span><br><span class="line">    <span class="comment">// 初始记录为 0，因为存在一个数等于 k 的情况</span></span><br><span class="line">    presum[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// count 记录个数，sum_i 计算前缀和</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>, sum_i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num: nums)&#123;</span><br><span class="line">        sum_i += num;</span><br><span class="line">        <span class="keyword">int</span> sum_j = sum_i - k;</span><br><span class="line">        <span class="comment">// 相差为 k 的前缀和若存在，则区域相加为 k</span></span><br><span class="line">        <span class="keyword">if</span>(presum.<span class="built_in">find</span>(sum_j) != presum.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="comment">// 加上此前出现 sum_j 的次数</span></span><br><span class="line">            count += presum[sum_j];</span><br><span class="line">        &#125;</span><br><span class="line">        presum[sum_i]++; <span class="comment">// 出现次数加 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="个人收获">个人收获</h2>
<p>前缀和的计算方法主要适用于处理数组<strong>区域之和</strong>的问题，并且计算区域和<strong>频率较高</strong>时使用，能够达到较好的效果。</p>
]]></content>
      <categories>
        <category>数据结构算法</category>
      </categories>
      <tags>
        <tag>leetcode题解</tag>
        <tag>c++</tag>
        <tag>数组</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>加快国内访问GitHub速度</title>
    <url>/2022/01/07/%E5%8A%A0%E5%BF%AB%E5%9B%BD%E5%86%85%E8%AE%BF%E9%97%AEGitHub%E9%80%9F%E5%BA%A6/</url>
    <content><![CDATA[<blockquote>
<p>本文主要是为了提高国内访问GitHub的速度。</p>
<p>方法是修改host文件。</p>
</blockquote>
<span id="more"></span>
<p>在国内 GitHub 访问速度慢或者无法访问，一般是因为 github 的加速分发 CDN 域名<code>assets-cdn.github.com</code>遭到<a href="https://baike.baidu.com/item/DNS%E6%B1%A1%E6%9F%93/8620359">DNS污染</a>，无法访问导致的。</p>
<p>所以解决方法就是修改本地的 host 映射，让解析的域名直接指向 Github 的 IP 地址，来绕过 DNS 解析。</p>
<h2 id="查询最新的-github-的-ip-地址">查询最新的 Github 的 IP 地址</h2>
<p>使用<a href="https://www.ipaddress.com/">ipaddress.com</a>查询以下域名对应的 IP 地址：</p>
<blockquote>
<p>github.com assets-cdn.github.com github.global.ssl.fastly.net</p>
</blockquote>
<h2 id="修改本地-host-文件">修改本地 host 文件</h2>
<p>Windows 用户在<code>C:\Windows\System32\drivers\etc</code>下找到 host 目录，若没有修改权限在<code>属性 -&gt; 安全</code>中增加用户的修改权限。</p>
<p>在使用记事本打开，在最后加入查询的 IP 和域名，增加如下内容，其中 IP 是自己查的最新的：</p>
<blockquote>
<p>#github映射（随便啦，做个标记让自己以后看到知道这里修改了什么）</p>
<p>140.82.114.3 github.com</p>
<p>185.199.108.153 assets-cdn.github.com</p>
<p>199.232.69.194 github.global.ssl.fastly.net</p>
</blockquote>
<h2 id="刷新-dns-缓存">刷新 DNS 缓存</h2>
<p>Windows 下使用<code>Win+R</code>，输入<code>cmd</code>，打开命令行，输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipconfig /flushdns</span><br></pre></td></tr></table></figure>
<p>刷新成功后就可以愉快的访问 Github 了。</p>
<h2 id="最后">最后</h2>
<p>由于 IP 经常会发生变化，所以如果访问变慢了就需要手动更新。</p>
<p>这里推荐一个网址<a href="https://raw.hellogithub.com/hosts">hellogithub</a>，有最新的 Github 访问 IP，可以直接复制粘贴。</p>
<h2 id="参考文章">参考文章</h2>
<ol type="1">
<li><a href="https://juejin.cn/post/6955761924722130974">国内加速访问Github的办法，超级简单</a></li>
<li><a href="https://juejin.cn/post/7019683061977579557">解决GitHub访问慢的问题</a></li>
</ol>
<h2 id="个人收获">个人收获</h2>
<p>其实很早之前就修改过但现在忘记了，所以还是自己写一篇文章，很久以后忘记了直接来找就好了。</p>
<p>其中的一些原理细节未必会懂，但是这就是一个工具呀，能用好就可以啦！</p>
<p>以上，继续加油！</p>
]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>单链表解题技巧3——相交链表</title>
    <url>/2022/01/06/%E5%8D%95%E9%93%BE%E8%A1%A8%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A73%E2%80%94%E2%80%94%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<blockquote>
<p>本文是关于单链表的判断相交问题，使用了两种方法，快慢指针和更好的逻辑连接方法。</p>
<p>涉及 leetcode 的 <a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a>。</p>
</blockquote>
<span id="more"></span>
<h2 id="相交链表">相交链表</h2>
<h3 id="题目">题目</h3>
<p>首先来看题目<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a>：给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。</p>
<p>示例1： &gt; 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3 &gt; &gt; 输出：Intersected at '8'</p>
<p>示例2： &gt; 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3 &gt; &gt; 输出：Intersected at '8'</p>
<h3 id="理解一下1">理解一下1</h3>
<p>所谓链表相交，就是一个<code>Y型</code>的链表结构，在交点处汇流，需要注意的是:</p>
<blockquote>
<p>链表相交后不会分开！因为链表只有一个<code>next</code>，只有唯一后继。</p>
</blockquote>
<p>寻找两条链表相交的结点就是寻找<strong>相同的结点</strong>（而不是值！）</p>
<p>基本的思路是：</p>
<p>遍历第一条链表<code>l1</code>，嵌套遍历第二条链表<code>l2</code>，判断相同的结点即可。</p>
<p>这种方法的时间复杂度达到了<code>O(n)</code>不是很好，于是便思考其他方法。</p>
<ol type="1">
<li>我们需要找到相交点，而最后相交点之后链的长度都是一样的；</li>
<li>两个指针判断相等时需要同时到达相交点；</li>
<li>那么自然就需要使得前面遍历的经过的结点数相同；</li>
</ol>
<h3 id="解法一双指针">解法一（双指针）</h3>
<p>使用双指针来解决，我思考的时候还是比较自然的，表述可能不够清晰，自己动手比划比划就很清楚了。</p>
<ol type="1">
<li>当链长相同时，自然是一一比较即可（这种情况不用考虑，包含在下面）；</li>
<li>链长不同是，短链的指针<code>l1</code>会先到达终点，而长链指针<code>l2</code>则还有<code>k</code>个结点，这个<code>k</code>刚好是两条链的长度之差；</li>
<li>由此我们长链中再设一个指针<code>llong</code>，跟随<code>l2</code>继续前进;</li>
<li>当<code>l2</code>到达终点时，<code>llong</code>距离链尾刚好与短链长度<strong>相同</strong>；</li>
<li>此时在短链头设置一个指针<code>lshort</code>，与<code>llong</code>一同前进，一一比较即可。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">    ListNode *la = headA, *lb = headB;</span><br><span class="line">    ListNode *lc, *llong, *lshort;</span><br><span class="line">    <span class="comment">// 依旧是快慢指针</span></span><br><span class="line">    <span class="comment">// la和lb同时前进</span></span><br><span class="line">    <span class="keyword">while</span>(la != <span class="literal">nullptr</span> &amp;&amp; lb != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        la = la-&gt;next;</span><br><span class="line">        lb = lb-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 选出长链和短链</span></span><br><span class="line">    <span class="keyword">if</span>(lb != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        lc = lb;</span><br><span class="line">        llong = headB;</span><br><span class="line">        lshort = headA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        lc = la;</span><br><span class="line">        llong = headA;</span><br><span class="line">        lshort = headB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 指向长链的快指针带着慢指针走到头</span></span><br><span class="line">    <span class="keyword">while</span>(lc != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        llong = llong-&gt;next;</span><br><span class="line">        lc = lc-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//短链从头开始和后出发的慢指针同时前进即可找到相同点</span></span><br><span class="line">    <span class="keyword">while</span>(lshort != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(lshort == llong)&#123;</span><br><span class="line">            <span class="keyword">return</span> llong;</span><br><span class="line">        &#125;</span><br><span class="line">        lshort = lshort-&gt;next;</span><br><span class="line">        llong = llong-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解法二逻辑连接">解法二（逻辑连接）</h3>
<p>继基本的分析思路，接下来要使得双指针同时到达交点：</p>
<ol type="1">
<li>只需要使得双指针在到达交点时经过相同个数的结点即可；</li>
<li>而我们知道<code>A+B = B+A</code>；</li>
<li>所以在A链前加上B链，在B链前加上A链，那么双指针同时从各自链出发，会在同一时刻到达相交点！</li>
</ol>
<figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">    ListNode *la = headA, *lb = headB;</span><br><span class="line">    <span class="keyword">while</span>(la != lb)&#123;</span><br><span class="line">        <span class="comment">// A链完了去B链</span></span><br><span class="line">        <span class="keyword">if</span> (la != <span class="literal">nullptr</span>)</span><br><span class="line">            la = la-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            la = headB;</span><br><span class="line">        <span class="comment">// B链完了去A链</span></span><br><span class="line">        <span class="keyword">if</span> (lb != <span class="literal">nullptr</span>)</span><br><span class="line">            lb = lb-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            lb = headA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> la;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="个人收获">个人收获</h2>
<p>这次感觉自己有一点很好的使用了之前学过的双指针，毕竟学了会用才是真的学会了。</p>
<p>另外将两个链表逻辑连接，使得两个链表的长度相同，这一点还是很值得学习的，不能作为套路，但是是一个很好的思考方向。</p>
]]></content>
      <categories>
        <category>数据结构算法</category>
      </categories>
      <tags>
        <tag>单链表</tag>
        <tag>leetcode题解</tag>
        <tag>逻辑链接</tag>
        <tag>双指针</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>单链表解题技巧(2)——快慢指针</title>
    <url>/2022/01/06/%E5%8D%95%E9%93%BE%E8%A1%A8%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A72%E2%80%94%E2%80%94%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<blockquote>
<p>本文是关于单链表的双指针问题中的快慢指针问题，1.链表的倒数第 n 个结点；2.寻找链表中间结点；3. 判断是否有环。</p>
<p>涉及 leetcode 的 <a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list">19. 删除链表的倒数第 N 个结点</a>、<a href="https://leetcode-cn.com/problems/middle-of-the-linked-list">876. 链表的中间结点</a>、<a href="https://leetcode-cn.com/problems/linked-list-cycle">141. 环形链表</a>和<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii">142. 环形链表 II</a>。</p>
</blockquote>
<span id="more"></span>
<h2 id="倒数第-n-个结点">倒数第 N 个结点</h2>
<h3 id="题目1">题目1</h3>
<p>首先来看题目<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list">19. 删除链表的倒数第 N 个结点</a>：给你一个链表，删除链表的<strong>倒数</strong>第 n 个结点，并且返回链表的头结点。</p>
<p>示例1： &gt; 输入：head = [1,2,3,4,5], n = 2 &gt; &gt; 输出：[1,2,3,5]</p>
<p>示例2： &gt; 输入：head = [1], n = 1 &gt; &gt; 输出：[]</p>
<h3 id="理解一下1">理解一下1</h3>
<p><strong>不用理解！</strong>(狗头)</p>
<p>基本的思路是：</p>
<ol type="1">
<li>先遍历一遍链表，得到链表的长度<code>Len</code>；</li>
<li>然后再从头遍历一遍到第<code>Len-N</code>个结点，该结点的后一个结点就是需要删除的结点。</li>
</ol>
<p>以上的思路确实可以解决该问题，但是对链表进行了两次遍历，那么是否可以使用<strong>一次遍历</strong>完成呢？可以的。</p>
<p>这就需要使用快慢指针了：</p>
<ol type="1">
<li>我们需要找到倒数<code>N</code>个结点，那么就需要寻找到第<code>Len-N</code>个结点；</li>
<li>首先让快指针先走，走出<code>N</code>步；</li>
<li>然后让慢指针和快指针保持相距<code>N</code>一起向前遍历，这时快指针还有<code>Len-N</code>步到达链尾，那么慢指针自然就还可以走<code>Len-N</code>步啦！</li>
</ol>
<h3 id="解题1">解题1</h3>
<p>这里我们同样需要对第一个结点进行讨论，所以直接引入头结点来解决。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用头结点</span></span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    dummy-&gt;next = head;</span><br><span class="line">    <span class="comment">// 快慢结点</span></span><br><span class="line">    ListNode *first = dummy, *second = dummy;</span><br><span class="line">    <span class="comment">// first先走n步</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// first和second保持相同的间距前进</span></span><br><span class="line">    <span class="comment">// first指向终点时second指向将要删除结点的前一个</span></span><br><span class="line">    <span class="keyword">while</span>(first-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">        second = second-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除（未释放空间）</span></span><br><span class="line">    second-&gt;next = second-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="中间结点">中间结点</h2>
<p>再来看一下中间结点的问题，其实是相同的套路。</p>
<h3 id="题目2">题目2</h3>
<p>先来看一下题目<a href="https://leetcode-cn.com/problems/middle-of-the-linked-list">876. 链表的中间结点</a>：给定一个头结点为 head 的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。</p>
<p>示例1： &gt; 输入：[1,2,3,4,5] &gt; &gt; 输出：此列表中的结点 3</p>
<p>示例2： &gt; 输入：[1,2,3,4,5,6] &gt; &gt; 输出：此列表中的结点 4</p>
<h3 id="理解一下2">理解一下2</h3>
<p><strong>也不用理解！</strong>(狗头)</p>
<p>基本思路与上一题类似：</p>
<ol type="1">
<li>先遍历一遍链表，得到链表的长度<code>Len</code>；</li>
<li>然后再从头遍历一遍到第<code>Len/2</code>个结点即可。</li>
</ol>
<p>这同样需要使用两次遍历，有了上面的经验我们自然可以想到使用快慢指针实现一次遍历：</p>
<ol type="1">
<li>快指针和慢指针同时出发（与之前先后出发不同了）；</li>
<li>快指针一次走两个<code>next</code>，慢指针一次进行一次<code>next</code>，这样快指针走到最后，慢指针刚好走了快指针的一般路程。</li>
</ol>
<h3 id="题解2">题解2</h3>
<p>这里根据题目要求注意一下中间结点的定义即可。</p>
<figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode * first = head, * second = head;</span><br><span class="line">    <span class="keyword">while</span>(first != <span class="literal">nullptr</span> &amp;&amp; first-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="comment">// 慢指针走一步，快指针走两步</span></span><br><span class="line">        second = second-&gt;next;</span><br><span class="line">        first = first-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="同样套路还有一个啦二合一">同样套路，还有一个啦（二合一）</h2>
<h2 id="环形链表">环形链表</h2>
<h3 id="题目3">题目3</h3>
<p><a href="https://leetcode-cn.com/problems/linked-list-cycle">141. 环形链表</a>和<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii">142. 环形链表 II</a>这两题类似。</p>
<p>141 给你一个链表的头节点 head ，判断链表中是否有环。</p>
<p>以及</p>
<p>142 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<h3 id="理解一下3">理解一下3</h3>
<p>也就是说需要判断链表是否有环，以及从哪个结点开始形成环。</p>
<p>那么我们首先需要知道如何判断环：</p>
<ol type="1">
<li>容易发现，一旦使用指针在有环链表中进行遍历，那么遍历一定是没有终止；就像操场跑步一样，只要沿着400米的圈一直跑就没有尽头，但是沿着100米的直线跑却是有尽头的；</li>
<li>同样的，当我与你一起在<code>100 + 400n米</code>的操场上跑步，从我跑得慢，你跑得快，那么你是不是终究就会在某个点上超过我一圈！</li>
<li>因此我们同样可以使用快慢指针进行你追我赶，当然，补偿为1、2、3这种连续遍历，可能会超过K圈（整数倍），不过无所谓，<strong>你我终会相遇</strong>。</li>
</ol>
<p>然后如何判断在哪相遇呢？（你的速度是我的两倍）</p>
<ol type="1">
<li>慢吞吞的我跑了<code>n</code>米，快吨吨的你跑了<code>2n</code>米，相遇时距离环起点也<code>m</code>米；</li>
<li>那么超过我的距离<code>n</code>一定是环的<strong>整数</strong>倍，所以你<strong>再</strong>跑<code>n-m</code>米就可以到达环起点，而我<strong>回到起点</strong>再跑<code>n-m</code>米也能到达环起点！</li>
<li>这里就不需要计数n了，保持相同速度跑，自然会在起点相遇，<strong>你我终会再次相遇</strong>。</li>
</ol>
<h3 id="题解3">题解3</h3>
<p>判断方法如下：</p>
<figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    ListNode *first = head, *second = head;</span><br><span class="line">    <span class="comment">// 同样使用快慢指针，若存在环，那么快指针将会在环内与慢指针相遇</span></span><br><span class="line">    <span class="keyword">while</span>(first != <span class="literal">nullptr</span> &amp;&amp; first-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        first = first-&gt;next-&gt;next;</span><br><span class="line">        second = second-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(first == second)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>寻找环起点的方法如下：</p>
<figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    ListNode *first = head, *second = head;</span><br><span class="line">    <span class="comment">// 标记是否相遇</span></span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(first != <span class="literal">nullptr</span> &amp;&amp; first-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        first = first-&gt;next-&gt;next;</span><br><span class="line">        second = second-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(second == first)&#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        <span class="comment">// 任意一个结点回到起点，同样速度跑</span></span><br><span class="line">        first = head;</span><br><span class="line">        <span class="keyword">while</span>(first != second)&#123;</span><br><span class="line">            first = first-&gt;next;</span><br><span class="line">            second = second-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="个人收获">个人收获</h2>
<p>这次的收获主要是头结点和快慢指针</p>
<ol type="1">
<li>头结点使得每个结点都有直接前驱，可以避免单独处理第一个结点的问题，很好用的；</li>
<li>快慢指针可以用来解决一些与速度、距离有关的问题会有较好的处理方法，在后续的题目中多熟悉熟悉。</li>
</ol>
]]></content>
      <categories>
        <category>数据结构算法</category>
      </categories>
      <tags>
        <tag>单链表</tag>
        <tag>leetcode题解</tag>
        <tag>双指针</tag>
        <tag>c++</tag>
        <tag>快慢指针</tag>
      </tags>
  </entry>
  <entry>
    <title>单链表解题技巧(1)——合并有序链表</title>
    <url>/2022/01/05/%E5%8D%95%E9%93%BE%E8%A1%A8%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A71%E2%80%94%E2%80%94%E5%90%88%E5%B9%B6%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<blockquote>
<p>本文是关于单链表的合并问题，1.合并两个有序链表；2.合并k个有序链表（堆）。</p>
<p>涉及 leetcode 的 <a href="https://leetcode-cn.com/problems/merge-two-sorted-lists">21. 合并两个有序链表</a>和 <a href="https://leetcode-cn.com/problems/merge-k-sorted-lists">23. 合并K个升序链表</a>。</p>
</blockquote>
<span id="more"></span>
<h2 id="合并两个有序链表">合并两个有序链表</h2>
<h3 id="题目1">题目1</h3>
<p>首先来看题目<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists">21. 合并两个有序链表</a>：将两个升序链表合并为一个新的<strong>升序</strong>链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<p>示例1： &gt; 输入：l1 = [1,2,4], l2 = [1,3,4] &gt; &gt; 输出：[1,1,2,3,4,4]</p>
<p>示例2： &gt; 输入：l1 = [], l2 = [0] &gt; &gt; 输出：[0]</p>
<h3 id="理解一下1">理解一下1</h3>
<p>题目的大概意思就是：</p>
<ol type="1">
<li>将两个本身就有序（升序）的链表合并起来，得到一个新的链表依旧是有序的；</li>
<li>并且新的链表依旧使用原本链表中的结点，而不是创建新的结点。（也就是用next指针指来指去）。</li>
</ol>
<p>基本的思路是：</p>
<ol type="1">
<li>首先创建一个链表头<code>res</code>来表示最终的链表；</li>
<li>然后分别使用两个指针指向链表<code>l1</code>和链表<code>l2</code>；</li>
<li>再比较<code>l1</code>和<code>l2</code>对应结点的值的大小，将小的结点连接到<code>res</code>中；</li>
<li><code>l1</code>和<code>l2</code>不断向后遍历，重复3，最后剩下没遍历完的就直接放在<code>res</code>后。</li>
</ol>
<h3 id="解题1">解题1</h3>
<p>以上的思路忽略了一些细节（n，n-1，1，0等这些边界问题），这里我们在处理第一个结点（无前结点）的时候还是需要分类讨论的，所以根据数据结构的定义，引入所谓的<code>头结点</code>，这样第一个结点就和其他结点都一样了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 头结点</span></span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    ListNode* p = dummy;</span><br><span class="line">    ListNode* p1 = list1, *p2 = list2;</span><br><span class="line">    <span class="comment">// 谁的结点小就将谁接在链表 dummy 后</span></span><br><span class="line">    <span class="keyword">while</span>(p1 &amp;&amp; p2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1-&gt;val &gt; p2-&gt;val)&#123;</span><br><span class="line">            p-&gt;next = p2;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            p-&gt;next = p1;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 跳出 while 循环的条件必然是至少一条链遍历结束了，那么剩下的一条的后续部分直接接在 dummy 中即可。</span></span><br><span class="line">    <span class="keyword">if</span>(p1)</span><br><span class="line">        p-&gt;next = p1;</span><br><span class="line">    <span class="keyword">if</span>(p2)</span><br><span class="line">        p-&gt;next = p2;</span><br><span class="line">    <span class="comment">// 题目需要返回的是没有头结点的，所以是 next。</span></span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="合并k个有序链表">合并K个有序链表</h2>
<h3 id="题目2">题目2</h3>
<p>同样先看一下题目<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists">23. 合并K个升序链表</a>：给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<p>示例1： &gt; 输入：lists = [ [1,4,5],[1,3,4],[2,6] ] &gt; &gt; 输出：[1,1,2,3,4,4,5,6]</p>
<p>示例2： &gt; 输入：lists = [ ] &gt; &gt; 输出：[ ]</p>
<h3 id="理解一下2">理解一下2</h3>
<p>就相当于之前是两个有序链表两两合并，现在是K个链表进行有序合并成一个有序链表。</p>
<p>基本的思路有两个：</p>
<h4 id="两两合并2">两两合并2</h4>
<p>第一种方法是在上一题的基础上，直接进行两两合并，得到有序链表，当然这里也有两种思路：一个是直接进行<code>k-1</code>次两两合并，另一个是使用<strong>归并</strong>两两合并，无非是时间换空间的问题（嗷，还有一个问题是归并我不熟练）。</p>
<p>这里提供我用第一个思路写的k-1次归并题解，其中<code>mergeTwoLists</code>函数就是之前的两两合并（好家伙，直接复制！）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 无链表</span></span><br><span class="line">    <span class="keyword">if</span>(lists.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 仅有一个链表</span></span><br><span class="line">    <span class="keyword">if</span>(lists.<span class="built_in">size</span>() == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// k-1 次两两合并</span></span><br><span class="line">    ListNode * res = lists[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lists.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        res = <span class="built_in">mergeTwoLists</span>(res,lists[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="小根堆合并">小根堆合并</h4>
<p>第二种方法需要使用数据结构——<strong>小根堆</strong>（本质上是一棵完全二叉树），通过堆的性质进行合并，在很多外部排序的时候会采用这种方法，同样的也有两个思路：</p>
<ol type="1">
<li>一个是将所有的链表所有的结点都<strong>一次性</strong>扔到堆中（显然需要空间极大），然后依次从堆顶取出结点链接到链表<code>dummy</code>中即可；</li>
<li>另一个是以<code>k</code>个链表的头结点构建大小为<code>k</code>的小根堆，堆顶的的结点就是最小结点，将其拿出链接到链表<code>dummy</code>中即可，并将该链上的<code>next</code>结点加入小根堆，并进行调整，直至堆中无结点即可。</li>
</ol>
<p>很明显<strong>小根堆合并</strong>比<strong>两两合并</strong>好多了，但是实际 coding 的时候其实并不一定能写出来（orz），所以这两种方法作为思路，并提供了一个<code>labuladong</code>的 java 题解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 虚拟头结点</span></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode p = dummy;</span><br><span class="line">    <span class="comment">// 优先级队列，最小堆</span></span><br><span class="line">    PriorityQueue&lt;ListNode&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(</span><br><span class="line">        lists.length, (a, b)-&gt;(a.val - b.val));</span><br><span class="line">    <span class="comment">// 将 k 个链表的头结点加入最小堆</span></span><br><span class="line">    <span class="keyword">for</span> (ListNode head : lists) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="keyword">null</span>)</span><br><span class="line">            pq.add(head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 获取最小节点，接到结果链表中</span></span><br><span class="line">        ListNode node = pq.poll();</span><br><span class="line">        p.next = node;</span><br><span class="line">        <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pq.add(node.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// p 指针不断前进</span></span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="个人收获">个人收获</h2>
<p>这里主要学到的是对k个链表进行合并的思路：</p>
<ol type="1">
<li>两两合并的方法其实很常见，在ML中，对多分类问题也经常使用多次二分类进行实现，本质上感觉还是很相似的，好吧不是一回事，总之是将问题进行拆分，然后再一个一个解决，虽然暴力（O(NK)），但是起码能够解决问题，不至于完全写不出来。</li>
<li>对于小根堆其实也是比较熟悉了，在数据结构中小根堆的<strong>画图</strong>我可是熟悉的一塌糊涂（除了考试没啥用），但是代码上就显得比较不熟练了，之后在树的这一个模块中再好好练一练。这个可以很好的降低时间的复杂度，相应的付出一些时间，不过效果要比两两合并好多（O(Nlogk)）。</li>
</ol>
]]></content>
      <categories>
        <category>数据结构算法</category>
      </categories>
      <tags>
        <tag>单链表</tag>
        <tag>leetcode题解</tag>
        <tag>c++</tag>
        <tag>k路问题</tag>
      </tags>
  </entry>
  <entry>
    <title>微信聊天记录制作词云图</title>
    <url>/2022/01/01/%E5%88%B6%E4%BD%9C%E8%AF%8D%E4%BA%91%E5%9B%BE/</url>
    <content><![CDATA[<blockquote>
<p>本文记录了从微信聊天记录导出到制作完成词云图的过程</p>
<p>利用了python，GitHub开源项目完成，默认了解python和mysql基础知识。</p>
<p>设备：Windows、ipad</p>
</blockquote>
<span id="more"></span>
<h2 id="导出微信聊天记录有iosipados设备">导出微信聊天记录（有IOS/IpadOS设备）</h2>
<p>首先我们需要将手机端的聊天记录（手机端的聊天记录比较完整）传送到微信端，这一步需要大家首先有一台苹果设备，利用iTunes备份聊天信息。</p>
<ol type="1">
<li><p>（安卓用户）打开微信，找到<code>设置-&gt;聊天-&gt;聊天记录备份与迁移-&gt;迁移聊天记录到另一台设备</code>，然后选择想要的聊天记录，最后用苹果设备扫描出现的二维码，等待传输完成即可。</p></li>
<li><p>当苹果设备备份完成后，下载<a href="https://support.apple.com/zh-cn/HT210384">iTunes</a>，用电脑连接苹果设备，这时候在iTunes上会出现一个设备图标，点击并打开</p>
<img src="/2022/01/01/%E5%88%B6%E4%BD%9C%E8%AF%8D%E4%BA%91%E5%9B%BE/image-20220101105954123.png" class="" title="image-20220101105954123"></li>
<li><p>点击<code>摘要-&gt;备份-&gt;本电脑-&gt;立即备份</code>，等待片刻使其备份完成。</p>
<img src="/2022/01/01/%E5%88%B6%E4%BD%9C%E8%AF%8D%E4%BA%91%E5%9B%BE/image-20220101110318002.png" class="" title="image-20220101110318002"></li>
<li><p>在Windows中，聊天记录一般在<code>C:\Users\用户名\AppData\Roaming\Apple Computer\MobileSync\Backup</code>内，使用<a href="https://github.com/BlueMatthew/WechatExporter/releases/download/v1.8.0.10/v1.8.0.10_x64_win.zip">WechatExporter-Windows</a>或<a href="https://github.com/BlueMatthew/WechatExporter/releases/download/v1.8.0.10/v1.8.0.10_x64_macos.zip">WechatExporter-MacOS</a>来解析文件，之后图片及聊天记录就会存在选定的文件夹中。若仅需要聊天记录文件的txt文件，则在<code>格式</code>中选择<code>文本</code>即可。</p>
<img src="/2022/01/01/%E5%88%B6%E4%BD%9C%E8%AF%8D%E4%BA%91%E5%9B%BE/image-20220101111144265.png" class="" title="image-20220101111144265"></li>
</ol>
<h2 id="聊天记录入库">聊天记录入库</h2>
<p>至此文件解析成功，接下来就是使用python对聊天记录导出的内容进行清洗过滤，得到<code>发送时间</code>、<code>用户名</code>和<code>聊天内容</code>，并保存到数据库中（当然也可以不用，自己对代码进行修改即可）如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">from</span> pymysql.converters <span class="keyword">import</span> escape_string</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_time</span>(<span class="params">time_str</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;将12小时日期时间转化为24小时制时间</span></span><br><span class="line"><span class="string">    Args: time_str (str): 12小时日期时间字符串，例如:2021-03-30 10:00:33 PM</span></span><br><span class="line"><span class="string">    Returns: str: 24小时制日期时间，例如:2021-03-30 22:00:33</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    str1 = time_str[-<span class="number">2</span>:]  <span class="comment"># 格式</span></span><br><span class="line">    data = time_str[:-<span class="number">3</span>]  <span class="comment"># 时间</span></span><br><span class="line">    <span class="keyword">if</span> str1.lower() == <span class="string">&quot;am&quot;</span> <span class="keyword">and</span> <span class="built_in">int</span>(time_str[-<span class="number">11</span>:-<span class="number">9</span>]) == <span class="number">12</span>:</span><br><span class="line">        hour = <span class="string">&quot;00&quot;</span></span><br><span class="line">        data = time_str[<span class="number">0</span>:<span class="number">11</span>] + hour + time_str[-<span class="number">9</span>:-<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">if</span> str1.lower() == <span class="string">&quot;pm&quot;</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">int</span>(time_str[-<span class="number">11</span>:-<span class="number">9</span>]) &lt; <span class="number">12</span>:</span><br><span class="line">            hour = <span class="built_in">str</span>(<span class="built_in">int</span>(time_str[-<span class="number">11</span>:-<span class="number">9</span>])+<span class="number">12</span>)</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># int(time_str[-11:-9]) == 12</span></span><br><span class="line">            hour = <span class="string">&quot;12&quot;</span></span><br><span class="line">        data = time_str[<span class="number">0</span>:<span class="number">11</span>] + hour + time_str[-<span class="number">9</span>:-<span class="number">3</span>]</span><br><span class="line">    str2 = time.mktime(time.strptime(data, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>))  <span class="comment"># 转换为时间戳</span></span><br><span class="line">    finally_result = <span class="built_in">str</span>(time.strftime(</span><br><span class="line">        <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, time.localtime(str2)))  <span class="comment"># 转换为指定格式</span></span><br><span class="line">    <span class="keyword">return</span> finally_result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">filter_lines = []  <span class="comment"># 最终的聊天信息</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;你的聊天记录路径.txt&quot;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    lines = f.readlines()</span><br><span class="line">    reg = <span class="string">&quot;^.+[\u4E00-\u9FFF]\s\(.+\):&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="comment"># 仅保留互相发送的信息记录</span></span><br><span class="line">        <span class="keyword">if</span> (line.startswith(<span class="string">&#x27;对方的用户名&#x27;</span>) <span class="keyword">or</span> line.startswith(<span class="string">&#x27;你的用户名&#x27;</span>)) <span class="keyword">and</span> re.match(reg, line):</span><br><span class="line">            filter_lines.append(line.strip())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接数据库</span></span><br><span class="line">conn = pymysql.connect(</span><br><span class="line">    host=<span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">    user=<span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    password=<span class="string">&#x27;123456&#x27;</span>,</span><br><span class="line">    db=<span class="string">&#x27;wechat_report&#x27;</span>,  <span class="comment"># 需要先建好</span></span><br><span class="line">    charset=<span class="string">&#x27;utf8mb4&#x27;</span>,</span><br><span class="line">    port=<span class="number">3306</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建游标</span></span><br><span class="line">cur = conn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据表</span></span><br><span class="line">create_sql = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">CREATE TABLE `log` (</span></span><br><span class="line"><span class="string">  `id` bigint(20) NOT NULL AUTO_INCREMENT,</span></span><br><span class="line"><span class="string">  `user` varchar(100) DEFAULT NULL,</span></span><br><span class="line"><span class="string">  `datetime` datetime DEFAULT NULL,</span></span><br><span class="line"><span class="string">  `content` text,</span></span><br><span class="line"><span class="string">  PRIMARY KEY (`id`)</span></span><br><span class="line"><span class="string">) ENGINE=InnoDB AUTO_INCREMENT=222187 DEFAULT CHARSET=utf8mb4;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">cur.execute(create_sql)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入数据表</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> filter_lines:</span><br><span class="line">    s1 = line.find(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    s2 = line.find(<span class="string">&quot;):&quot;</span>)</span><br><span class="line">    name = line[:s1]  <span class="comment"># 发送者</span></span><br><span class="line">    chattime = line[s1 + <span class="number">2</span>:s2]  <span class="comment"># 带有am/pm的12小时制时间</span></span><br><span class="line">    chattime = convert_time(chattime)  <span class="comment"># 转化为24小时制时间</span></span><br><span class="line">    content = line[s2 + <span class="number">2</span>:]  <span class="comment"># 聊天内容</span></span><br><span class="line">    insert_sql = <span class="string">f&quot;insert into log(user,datetime,content) values (&#x27;<span class="subst">&#123;name&#125;</span>&#x27;,&#x27;<span class="subst">&#123;chattime&#125;</span>&#x27; ,&#x27;<span class="subst">&#123;escape_string(content)&#125;</span>&#x27;)&quot;</span></span><br><span class="line">    cur.execute(insert_sql)</span><br><span class="line">conn.commit()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;一共有<span class="subst">&#123;<span class="built_in">len</span>(lines)&#125;</span>条聊天记录&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="聊天记录分词计算词频">聊天记录分词，计算词频</h2>
<p>从数据库中将数据读出，并使用<code>jieba</code>进行分词，统计每个词出现的次数，整理成<code>&#123;'word': str, 'count':number&#125;</code>的格式，并按照词频大小进行排序。</p>
<p>导出为使用<code>;</code>隔开的csv格式</p>
<blockquote>
<p>jieba分词的效果还是不错的，但是其实分析聊天记录的时候更想要的是关于句意吧，所以其实并没有达到我的预期。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接数据库</span></span><br><span class="line">conn = pymysql.connect(</span><br><span class="line">    host=<span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">    user=<span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    password=<span class="string">&#x27;123456&#x27;</span>,</span><br><span class="line">    db=<span class="string">&#x27;wechat_report&#x27;</span>,</span><br><span class="line">    charset=<span class="string">&#x27;utf8mb4&#x27;</span>,</span><br><span class="line">    port=<span class="number">3306</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立游标</span></span><br><span class="line">cur = conn.cursor()</span><br><span class="line"></span><br><span class="line">cur.execute(<span class="string">&quot;select * from log&quot;</span>)</span><br><span class="line">r = cur.fetchall()  <span class="comment"># 获得全部聊天记录</span></span><br><span class="line"></span><br><span class="line">result = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得最长的一句话</span></span><br><span class="line">max_item = <span class="literal">None</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> r:</span><br><span class="line">    content = item[<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">if</span> (max_item <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(content) &gt; <span class="built_in">len</span>(max_item[<span class="number">3</span>])) <span class="keyword">and</span> content.find(<span class="string">&#x27;http&#x27;</span>) == -<span class="number">1</span>:</span><br><span class="line">        max_item = item</span><br><span class="line"><span class="built_in">print</span>(max_item)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行分词</span></span><br><span class="line">word_arr = []</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> r:</span><br><span class="line">    content = item[<span class="number">3</span>]</span><br><span class="line">    seg_list = jieba.cut(content)</span><br><span class="line">    word_arr = word_arr + <span class="built_in">list</span>(seg_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算词频</span></span><br><span class="line">word_count_map = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> word_arr:</span><br><span class="line">    <span class="keyword">if</span> word <span class="keyword">in</span> word_count_map:</span><br><span class="line">        word_count_map[word] = word_count_map[word] + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        word_count_map[word] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 组合成字典</span></span><br><span class="line">word_count_arr = []</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> word_count_map:</span><br><span class="line">    o = &#123;</span><br><span class="line">        <span class="string">&#x27;word&#x27;</span>: word,</span><br><span class="line">        <span class="string">&#x27;count&#x27;</span>: word_count_map[word]</span><br><span class="line">    &#125;</span><br><span class="line">    word_count_arr.append(o)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按词频排序</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">custom_sort</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x[<span class="string">&#x27;count&#x27;</span>] &gt; y[<span class="string">&#x27;count&#x27;</span>]:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> x[<span class="string">&#x27;count&#x27;</span>] &lt; y[<span class="string">&#x27;count&#x27;</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result[<span class="string">&#x27;word&#x27;</span>] = <span class="built_in">sorted</span>(word_count_arr, key=functools.cmp_to_key(custom_sort))</span><br><span class="line"></span><br><span class="line"><span class="comment"># with open(&quot;wechat-report\bin\result.json&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:</span></span><br><span class="line"><span class="comment">#     f.write(</span></span><br><span class="line"><span class="comment">#         json.dumps(result, ensure_ascii=False)</span></span><br><span class="line"><span class="comment">#     )</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用分号隔开写入csv文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;wechat-report\bin\result.csv&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> result[<span class="string">&#x27;word&#x27;</span>]:</span><br><span class="line">        f.write(i[<span class="string">&#x27;word&#x27;</span>]+<span class="string">&#x27;;&#x27;</span>+<span class="built_in">str</span>(i[<span class="string">&#x27;count&#x27;</span>])+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="制作词云">制作词云</h2>
<p>词云的制作利用了一个还不错的网站<a href="https://wordart.com/create">Word Art</a>。</p>
<ol type="1">
<li>words中使用<code>import</code>导入使用分号隔开的csv文件（复制粘贴进来）；</li>
<li>shapes可以选择形状；</li>
<li>fonts中记得导入中文字体，该网站默认仅支持英文字体；</li>
<li>其他的自己探索吧，我也没仔细设置，点击上方中间红色按钮<code>Visualize</code>生成词云，下载项中可以免费下载普通画质的，也还可以了。</li>
</ol>
<h2 id="参考内容">参考内容</h2>
<p><a href="https://github.com/myth984/wechat-report">myth984/wechat-report: 微信聊天记录年度报告 (github.com)</a></p>
<p><a href="https://github.com/BlueMatthew/WechatExporter">BlueMatthew/WechatExporter: Wechat Chat History Exporter 微信聊天记录导出程序 (github.com)</a></p>
<p><a href="https://wordart.com/create">Word Art - Edit - WordArt.com</a></p>
<p><a href="https://izihun.com/zitixiazai-450.html?from_code=10033">沐瑶软笔手写体(Muyao-Softbrush)_TTF字体下载-字魂网 (izihun.com)</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>词云</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo的迁移</title>
    <url>/2021/12/29/hexo%E7%9A%84%E8%BF%81%E7%A7%BB/</url>
    <content><![CDATA[<blockquote>
<p>为了重新开始写点东西，而且换了电脑，所以将博客进行了一次迁移，在此记录一些坑，其实真的很简单！，本质上就是拷贝！</p>
</blockquote>
<span id="more"></span>
<h2 id="安装必备环境">安装必备环境</h2>
<p>有关一些环境的准备在<a href="https://gipbear.github.io/2021/01/05/hexo%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/">hexo 的安装和配置</a>说明过了，当然，这不完全相同，我这次在新电脑中并没有采用yarn来安装，不过这个无所谓。</p>
<p>简单说明一下需要安装<code>git客户端</code>和<code>nodejs</code>，至今的npm一般在安装nodejs中都已经包含了。</p>
<p>安装<code>hexo</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
<h2 id="git关联github">git关联github</h2>
<p>首先，生成本地密钥（如果已经有了则不需要），这会在本地用户的<code>.ssh</code>文件夹中出现一个私钥<code>id_rsa</code>（妥善保管！），以及一个公钥<code>id_rsa.pub</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;example@example.com&quot;</span></span><br></pre></td></tr></table></figure>
<p>然后在个人Github的Settings中找到侧边<a href="https://github.com/settings/keys">SSH and GPG keys</a>，点击<code>New SSH key</code>，将公钥<code>id_rsa.pub</code>中的内容复制到其中即可。</p>
<p>会发个邮件给你的邮箱，点击确认一下。</p>
<p>在git中输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh git@github.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 出现如下内容即可：</span></span><br><span class="line"><span class="comment"># PTY allocation request failed on channel 0</span></span><br><span class="line"><span class="comment"># Hi XXX! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span><br><span class="line"><span class="comment"># Connection to github.com closed.</span></span><br></pre></td></tr></table></figure>
<h2 id="新建空文件夹用来做为博客使用">新建空文件夹用来做为博客使用</h2>
<p>初始化hexo至空文件夹<code>hexo_blog</code>中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init hexo_blog</span><br></pre></td></tr></table></figure>
<p>切换至<code>hexo_blog</code>文件夹中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> hexo_blog</span><br></pre></td></tr></table></figure>
<p>尝试启动hexo</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>很不幸，我出现了一些问题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ERROR Cannot find module <span class="string">&#x27;hexo&#x27;</span> from <span class="string">&#x27;E:\hexo_blog&#x27;</span></span><br><span class="line">ERROR Local hexo loading failed <span class="keyword">in</span> E:\hexo_blog</span><br><span class="line">ERROR Try running: <span class="string">&#x27;rm -rf node_modules &amp;&amp; npm install --force&#x27;</span></span><br></pre></td></tr></table></figure>
<p>于是我按照他的建议，执行了如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm -rf node_modules &amp;&amp; npm install --force</span><br></pre></td></tr></table></figure>
<p>很不幸，又出了问题：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm WARN using --force I sure hope you know what you are doing.</span><br><span class="line">npm WARN deprecated urix@0.1.0: Please see https://github.com/lydell/urix<span class="comment">#deprecated</span></span><br><span class="line">npm WARN deprecated resolve-url@0.2.1: https://github.com/lydell/resolve-url<span class="comment">#deprecated</span></span><br><span class="line">npm ERR! Unexpected end of JSON input <span class="keyword">while</span> parsing near <span class="string">&#x27;...a69f8709d4bd17ffe153b&#x27;</span></span><br><span class="line"></span><br><span class="line">npm ERR! A complete <span class="built_in">log</span> of this run can be found <span class="keyword">in</span>:</span><br><span class="line">npm ERR!     C:\Users\username\AppData\Roaming\npm-cache\_logs\2021-12-29T08_54_26_243Z-debug.log</span><br></pre></td></tr></table></figure>
<p>经查找，发现只需要清除一下npm的cache即可，<a href="https://segmentfault.com/a/1190000015646531">原文在此</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm cache clean --force</span><br></pre></td></tr></table></figure>
<p>接下来再本地<code>hexo s</code>启动一下服务试试看，发现大功告成！</p>
<blockquote>
<p>以上步骤大致如此，不行就删了博客文件夹重来，反正也是空空的！</p>
<p>放心大胆的试吧</p>
</blockquote>
<h2 id="迁移博客">迁移博客</h2>
<p>实际上只需要将原电脑上的文章和一些配置拷贝过来即可，主要是三个文件夹和一个配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scaffolds</span><br><span class="line"><span class="built_in">source</span></span><br><span class="line">themes</span><br><span class="line">_config.yml</span><br></pre></td></tr></table></figure>
<p>首先清除public中的内容，然后重新再生成内容，并发布</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo d</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<h2 id="完成">完成</h2>
<p>OK，至此就完成了，本质上也就是重新搭建博客，然后将配置文件和已经有的内容给拷贝过来就可以了，也没有很麻烦嘛!</p>
<h2 id="关于一些小问题">关于一些小问题</h2>
<p>迁移之后有很多东西可能跟之前不一样了，包括版本，安装的包之类的，所以还需要根据具体情况来自己踩坑，目前我发现了两个。</p>
<blockquote>
<p>插件都是需要自己在新设备上重新安装的，这个没有在上面的步骤中拷贝过来！！</p>
</blockquote>
<h3 id="本地图片上传失败">本地图片上传失败</h3>
<p>原本安装的<code>hexo-asset-image</code>插件不能使用了，重新安装后出现了严重警告和错误，经过查找资料发现是该插件不能用了，所以采用其他方法。参考<a href="https://blog.pakro.top/2021/solve_the_problem_that_after_upgrade_to_hexo5_local_image_cannot_be_displayed_while_deployed/">解决 hexo5 本地图像上传后无法显示的问题</a></p>
<p>首先，卸载安装的<code>hexo-asset-image</code>；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-asset-image --save</span><br></pre></td></tr></table></figure>
<p>然后，同样修改修改博客配置文件<code>_config.yml</code>中的 <code>post_asset_folder</code>为<code>true</code>；</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>最后，安装<code>post_asset_folder</code>。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>在之后在博客中就正常使用原方法传文件即可。</p>
<h3 id="主题中添加搜索功能">主题中添加搜索功能</h3>
<p>安装<code>hexo-generator-searchdb</code>插件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<p>首先修改<strong>博客</strong>配置文件<code>_config.yml</code>，如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>
<p>然后，修改<strong>主题</strong>配置文件<code>_config.yml</code>如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span>  <span class="comment"># trigger若为auto, 通过改变输入触发搜索；trigger若为manual, 通过按下enter键或者点击搜索按钮触发搜索</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span>  <span class="comment"># 展示每篇文章的前n个结果，如果想要展示所有结果，设置为-1</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span>  <span class="comment"># 将html字符串转义为可读的字符串。</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span>  <span class="comment"># 当加载页面时预加载搜索结果</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>STP分析</title>
    <url>/2021/02/25/STP%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p>本文是根据《活用数据|驱动业务的数据分析实战》中的案例进行的学习总结，主要是针对彩电用户的特征和行为，从研究调查问卷组成，以及分析问卷统计用户偏好。</p>
<p>适用于需要结合案例学习数据分析方法的初学者。</p>
</blockquote>
<span id="more"></span>
<h2 id="总体思路">总体思路</h2>
<p>甲保险公司的主要经营业务是车险，为了在激烈的竞争中获胜，决定以精准营销为发展策略，针对车险目标用户开展定制服务。</p>
<p><code>研究目的</code>是其了根据用户的偏好，对用户进行精准营销。由于个体的差异，所有的用户不可能同时喜欢一个产品，即使将全部的用户作为目标市场，也只会获得部分客户购买产品，这样反而付出了巨大的代价，却获得很小的收益。所以需要开展市场细分（Market Segmenting），寻找目标市场（Market Target），进行市场定位（Market Positioning），从而达到精准营销的目的。</p>
<p><code>研究内容</code>主要是对客户按照不同维度进行分类，衡量用户在各个维度上的差异。主要有5种分类维度：</p>
<ul>
<li>自然属性因素：性别、年龄、地域等；</li>
<li>社会特征因素：收入、职业、教育等；</li>
<li>行为特征因素：用户购物行为的五个阶段各个因素（<a href="https://gipbear.github.io/2021/02/21/用户偏好分析案例/">用户偏好分析案例</a>中几个方面）；</li>
<li>态度偏好因素：心理需求、购买动机、使用习惯、使用体验与态度倾向等；</li>
<li>生活状态与个性因素：客户生活方式、价值观和个性特点等。</li>
</ul>
<p>其中前三种属于<code>事前分类维度</code>，这些维度表露在外，接触用户时，企业可以从中凭借经验进行分类，对企业起到<strong>验证性作用</strong>。后两种属于<code>事后分类维度</code>，需要对用户进行深入调研，才能进行了解，体现了用户的<strong>内在本质</strong>，需要根据事后的客户分类项目，从中对用户进行分类，对企业起到<strong>探索性作用</strong>。</p>
<h2 id="调查问卷">调查问卷</h2>
<p>调查问卷从以下几个方面展开：</p>
<ol type="1">
<li>甄别问题：是否购买车险</li>
<li>自然属性因素：性别、年龄、城市</li>
<li>社会属性因素：学历、家庭月收入、职业、汽车价格</li>
<li>行为特征因素：
<ol type="1">
<li>产生需求阶段：决策时间</li>
<li>信息收集阶段：是否收集信息、从什么渠道收集信息</li>
<li>方案比选阶段：投保渠道</li>
<li>购买决策阶段保险公司的选择、<u>保费金额</u></li>
<li>购后行为阶段：索赔经历</li>
</ol></li>
<li>态度偏好因素：<u>一站式服务考虑程度</u>、<u>网上投保考虑程度</u>、<u>产品个性化考虑程度</u>、选择保险公司的考虑因素、满意度</li>
<li>生活状态与个性因素：<u>对自己的生活很满意</u>、<u>为享受而产生的浪费是必要的</u>、<u>买房子前要先有车</u>、<u>不惜金钱和时间装修房子</u>、<u>买衣服都买便宜的</u>、<u>休息时经常进行户外活动</u>、<u>尝试生活充满变化</u>、<u>喜欢独自享受安静的生活</u>、<u>下班后尽快回家</u>。</li>
</ol>
<h2 id="调研计划">调研计划</h2>
<p>与上一篇<a href="https://gipbear.github.io/2021/02/21/用户偏好分析案例/#调研计划">调研计划</a>类似，不再赘述。</p>
<h2 id="数据分析架构">数据分析架构</h2>
<p>分析的架构按照STP分析理论展开，从市场细分、目标市场和市场定位三个方面进行。</p>
<p>数据分析的架构如图所示。</p>
<img src="/2021/02/25/STP%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%9E%B6%E6%9E%84.png" class="" title="image-20210225164041236">
<h3 id="客户细分">客户细分</h3>
<ul>
<li><p>首先需要确定<strong>分类维度</strong>，若选择多个维度，则需要尽量保证维度之间不存在相关性，可以使用因子分析进行处理，并进行标准化处理。</p>
<p>由于事先分类优于事后分类。所以选择客户<u>生活状态的9个问题</u>作为第一个细分维度。由于9个问题之间存在一定的相关性，会使得具有相关性的因素影响扩大，所以使用对数据进行降维。一般会采用<strong>因子分析</strong>，并得到<u>因子类别</u>作为最终的细分维度。</p>
<p>同时，客户的购买行为十分显著的区分客户购买行为，所以选择<u>保费金额</u>作为第二个细分维度。</p>
<p>由于因子类别是分类数据、保费金额是数值数据，两个因素的量纲并不相同，所以使用<strong>标准化统一量纲</strong>，使其具有可比性。</p></li>
<li><p>其次选择合适的<strong>细分方法</strong>。</p>
<p>单一维度的细分直接使用交叉分析就可以完成，直接找到客户在某个因素上的区别。</p>
<p>多个维度则需要使用一些机器学习的方法进行，根据是有监督问题还是无监督问题进行选择。</p></li>
<li><p>最后使用选择的细分方法对客户进行<strong>聚类</strong>。此处无监督的可以使用聚类分析方法进行，获得细分类别。对于聚类效果可以使用方差分析进行<strong>检验</strong>，依旧按照<span class="math inline">\(显著性&lt;0.05\)</span>来判断。之后给通过交叉分析和比较均值，来<strong>刻画</strong>客户在细分类别和保费金额上的区别，并给客户群体<strong>命名</strong>。</p></li>
</ul>
<h4 id="因子分析">因子分析</h4>
<p>对数据进行因子分析之前，要先检验原始因素中是否存在相关性。通过SPSS的<code>分析-降维-因子</code>直接进行因子分析，根据选项会得到各个计算结果。</p>
<ul>
<li>在<code>对话框的“描述”中选择KMO和Bartlett的球形度检验</code>，当<span class="math inline">\(显著性&lt;0.05\)</span>时说明适合做因子分析。</li>
<li>公因子方差表明提取的因子对原始因素的解释能力。总方差解释是将<span class="math inline">\(特征值&gt;1\)</span>的因子作为最后的因子。</li>
<li>成分矩阵存储的是因子载荷，说明提取后的各个因子对原始维度的解释程度。但是可能存在多个因子对同一个原始因素都具有解释性，这与因子分析要剔除相关性冲突，所以需要进行因子旋转，使得最终因子之间的差异最大，可以在<code>对话框的“旋转”中选择最大方差法</code>，使得每个维度上仅有一个最大的因子载荷。</li>
<li>在<code>对话框的“得分”中选择保存为变量和显示因子得分系数矩阵</code>，利用得到的因子得分系数矩阵能够计算各个因子的得分并保存。通过<code>转换-计算变量</code>将4个因子转化为一个变量，即因子类别。</li>
</ul>
<h4 id="聚类分析">聚类分析</h4>
<p>聚类分析一般有两者方法，一种是层次分析，一种迭代聚类。</p>
<ul>
<li>层次聚类：主要思想是逐层合并，按照样本距离，将最近的样本归为一类，接着将形成的类别与较近的样本合并为一类，依次聚成一类，其形状类似于一棵树状图。</li>
<li>迭代聚类：最常见的是K-Means聚类，根据指定的聚类数k，随机选择k个初始点，将用户归为最近的初始点，重新计算聚类后的中心点，并再次聚类，通过不断的迭代计算中心点直至收敛，获得最后的聚类结果。</li>
</ul>
<p>关于其特征和性能上的一些区别：</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>层次聚类</th>
<th>迭代聚类</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>思路</td>
<td>逐层合并</td>
<td>不断迭代</td>
</tr>
<tr class="even">
<td>类别数</td>
<td>未知，得到树状图进行判断</td>
<td>需要指定</td>
</tr>
<tr class="odd">
<td>计算速度</td>
<td>反复计算距离，大样本或多变量时候较慢</td>
<td>计算量小，常用于处理大样本</td>
</tr>
<tr class="even">
<td>聚类对象</td>
<td>记录或变量</td>
<td>仅记录</td>
</tr>
<tr class="odd">
<td>数据类型</td>
<td>连续变量或分类变量</td>
<td>连续变量</td>
</tr>
</tbody>
</table>
<h3 id="目标客户选择">目标客户选择</h3>
<p>这部分和上一节内容类似，主要分为市场吸引力和自身竞争力两部分来考虑。</p>
<ul>
<li><p>首先选择衡量客户吸引力和企业竞争力的<strong>指标</strong>，作为选择客户的标准。通过内部讨论，决定使用客户规模和保费金额来衡量客户吸引力，使用市场份额指标衡量企业竞争力。</p></li>
<li><p>其次根据各类细分客户在这些指标上的表现，计算各类客户<strong>得分</strong>。使用频数统计细分类别获得客户规模，以及均值分析获得保费金额在细分类别上的均值，得分由客户吸引力和企业竞争力加权计算得到。</p></li>
<li><p>最后使用矩阵分析的方法<strong>选择</strong>企业目标客户。根据获得的得分绘制散点图，形成波士顿矩阵。</p></li>
</ul>
<h3 id="目标客户定位">目标客户定位</h3>
<p>确定目标客户之后，需要找出目标客户的<strong>特征</strong>，以及该目标客户对哪种产品具有<strong>需求</strong>。需要进行目标客户特征描述和目标客户需求定位。</p>
<ul>
<li>目标客户的特征描述：首先利用方差分析判断目标客户与其他客户在哪些方面具有显著差异，再将具有差异的因素利用SPSS中的<code>分析-降维-最优标度</code>获得特征上的具体差异。</li>
<li>目标客户需求定位：同样先进行方差分析判断哪些方面具有显著差异，这些分类数据可以使用<code>交叉表</code>来描述具体差异。当得到用户不满意的结论时，需要进一步挖掘用户哪里不满意，进行深入分析。</li>
</ul>
<h2 id="个人收获">个人收获</h2>
<p>通过</p>
]]></content>
      <categories>
        <category>数据分析实战</category>
      </categories>
      <tags>
        <tag>STP</tag>
      </tags>
  </entry>
  <entry>
    <title>用户偏好分析案例</title>
    <url>/2021/02/21/%E7%94%A8%E6%88%B7%E5%81%8F%E5%A5%BD%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<blockquote>
<p>本文是根据《活用数据|驱动业务的数据分析实战》中的案例进行的学习总结，主要是针对彩电用户的特征和行为，从研究调查问卷组成，以及分析问卷，来统计用户偏好。</p>
<p>适用于需要结合案例学习数据分析方法的初学者。</p>
</blockquote>
<span id="more"></span>
<h2 id="总体思路">总体思路</h2>
<p>国内某彩电企业为了摆脱价格战，提高核心竞争力，从用户入手，针对不同用户偏好，展开差异化营销。同样地，我们需要明确研究目的和研究内容。</p>
<p><code>研究目的</code>很简单，就是<strong>开展差异化营销</strong>。差异化营销是使得企业最大限度地满足用户需求，从而提高企业的营业业绩；那么差异化营销在该企业是否可行，就需要考虑多个维度的因素，基于时间思维和结构思维进行分析，将用户偏好分为五个阶段和七个要素。</p>
<p><code>研究内容</code>就围绕五个阶段和七个要素进行展开：</p>
<ul>
<li>产生需求阶段：购买的原因（why）、决策时间（when）、了解程度（how much）</li>
<li>信息收集阶段：获取信息的渠道（where）、关注哪些信息（what）</li>
<li>方案比选阶段：比较时考虑的因素（what）、各因素考虑的程度（how）</li>
<li>购买决策阶段：最终买的是什么（what）</li>
<li>购后行为阶段：如何使用彩电（how）</li>
</ul>
<h2 id="调查问卷">调查问卷</h2>
<p>根据以上的研究内容，设计一份调查问卷，来获得相应的调查数据，来进行定量分析。</p>
<p>问卷结果由以下几个问题组成： 1. 问卷编号 2. 是否购买彩电：S1甄别问题 3. 产生需求阶段：Q1购买原因，Q2决策时间，Q3了解程度 4. 信息收集阶段：Q4信息渠道，Q5关注信息 5. 方案比选阶段：Q6刻录功能考虑程度，Q7耗电量考虑程度，Q8上网功能考虑程度，Q9他人推荐考虑程度，Q10促销活动考虑程度，Q11感兴趣的促销活动 6. 购买决策阶段：Q12品牌，Q13价格，Q14外观，Q15规格，Q16颜色 7. 购后行为阶段：Q17安装方式，Q18摆放位置 8. 用户背景信息：A1性别，A2年龄，A3学历，A4家庭收入，A5住房面积，A6家庭成员</p>
<h2 id="调研计划">调研计划</h2>
<p>完成调查问卷的创建之后，紧接着进行问卷调查，这里需要明确6个问题： * 调查方法：例如中心定点拦截访问（CIL） * 调查对象：某天之后购买过彩电的用户 * 调查地点与样本量： * 项目周期： * 项目成员及职责： * 项目经理：负责整个项目的统筹控制，业务沟通、制定方案、控制进度及质量、团队协调沟通 * 督导员：向项目经理汇报工作进展，招聘和监督访问员，对访问质量直接负责 * 访问员：负责实际访问，向督导员汇报工作进度 * 数据处理人员：调查问卷审核，数据录入，数据检查和对数据质量进行评价 * 数据分析人员：对调查和处理好的数据进行研究分析 * 报告撰写与宣讲人员：撰写分析报告并向相关领导汇报 * 项目质量与进度控制：安排跟访，保证数据真实有效性，并及时汇报和录入数据</p>
<h2 id="数据处理">数据处理</h2>
<p>调查得到的数据是最原始的数据，其中可能会出现很多的问题，所以需要对数据先进行处理，主要分为四个步骤： * 数据集成：将多个数据源的数据进行合并 * 数据转换：对数据进行标准化处理 * 数据消减：对数据进行聚合和降维，减小数据规模 * <strong>数据清洗</strong>：数据筛选、数据去重、填补缺失值和数据纠错。（本案例仅关注数据清洗）</p>
<h3 id="数据编码">数据编码</h3>
<p>其中方案比选阶段的Q6-Q10数据为数值数据，可以直接进行数据分析，而其他数据均为类别数据，需要使用编码格式进行数值转换</p>
<p>针对<strong>不存在大小</strong>的分类数据，可以直接使用set容器去重，再使用map进行<strong>硬编码</strong>，若存在大小的，最好还是手动创建map参数。例如下面非比较类型分类数据的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;A&#x27;</span>:[<span class="string">&#x27;一&#x27;</span>,<span class="string">&#x27;二&#x27;</span>,<span class="string">&#x27;一&#x27;</span>,<span class="string">&#x27;三&#x27;</span>,<span class="string">&#x27;一&#x27;</span>,<span class="string">&#x27;一&#x27;</span>,<span class="string">&#x27;三&#x27;</span>],</span><br><span class="line">                   <span class="string">&#x27;B&#x27;</span>:[<span class="string">&#x27;aa&#x27;</span>,<span class="string">&#x27;bb&#x27;</span>,<span class="string">&#x27;cc&#x27;</span>,<span class="string">&#x27;cc&#x27;</span>,<span class="string">&#x27;bb&#x27;</span>,<span class="string">&#x27;aa&#x27;</span>,<span class="string">&#x27;dd&#x27;</span>],</span><br><span class="line">                   <span class="string">&#x27;C&#x27;</span>:[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]&#125;)</span><br><span class="line"></span><br><span class="line">df_obj= df.select_dtypes(<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line">datamap = []</span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> df_obj.columns:</span><br><span class="line">    datamap.append(&#123;elem: index+<span class="number">1</span> <span class="keyword">for</span> index, elem <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">set</span>(df[col]))&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="数据清洗">数据清洗</h3>
<p>首先通过数据筛选，将<code>S1甄别问题</code>为<code>1</code>的问卷筛选出来，因为购买了彩电的用户才是我们需要分析的用户。</p>
<p>然后对数据进行去重，针对的是问卷编号，保证每个问卷仅出现一次。</p>
<p>再对处理数据中存在的缺失值，可以找到缺失值的位置，找到相应问卷进行查看并填补；若问卷上也不存在，则对数值型数据使用统计值填补，对分类型数据使用众数填补；或者少量数据可以直接删除。</p>
<p>最后进行数据纠错，数据的错误类型主要有两种，一种是非逻辑错误，就是在问卷调查或录入数据的时候出现差错，这需要加强调研的各个环节的质量监控；另一种是逻辑错误，例如，性别男为“1”，女为“2”，但是录入了3，这种属于逻辑错误，需要在数据编码的时候进行控制。</p>
<h2 id="分析架构">分析架构</h2>
<p>用户偏好分析主要分为三个部分：</p>
<ol type="1">
<li>用户基本特征描述：用户的特征不同，结论分析往往不同，可以协助业务方在下结论的时候注意应用对象。</li>
<li>用户整体偏好分析：对于问卷中的数值数据可以使用<strong>均值分析</strong>用户整体偏好，对于非数值数值使用<strong>频数统计</strong>反映用户整体情况。</li>
<li>各类用户偏好分析：将用户偏好和用户基本特征做<strong>比较均值</strong>或<strong>交叉分析</strong>。</li>
</ol>
<blockquote>
<p>在此之前需要利用<strong>方差分析</strong>，检验不同用户之间是否存在<strong>显著差异</strong>，若存在，做差异对比才有意义。</p>
</blockquote>
<h2 id="实例演示">实例演示</h2>
<p>详见我在Github上的<a href="https://github.com/Gipbear/data-analysis/blob/master/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/%E7%94%A8%E6%88%B7%E5%81%8F%E5%A5%BD%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E6%9F%90%E5%BD%A9%E7%94%B5%E4%BC%81%E4%B8%9A%E7%94%A8%E6%88%B7%E5%81%8F%E5%A5%BD%E5%88%86%E6%9E%90/%E6%9F%90%E5%BD%A9%E7%94%B5%E4%BC%81%E4%B8%9A%E7%94%A8%E6%88%B7%E5%81%8F%E5%A5%BD%E5%88%86%E6%9E%90.ipynb">代码</a></p>
<h2 id="分析结果解读">分析结果解读</h2>
<p>最后根据以上得到的各个分析结果，进行可视化图像进行分析比较，得到最终结论。</p>
<p>// todo: 详细的会在之后学习了数据分析经验之后再来分析一下。</p>
<h2 id="个人收获">个人收获</h2>
<p>总体上学到了有几点，首先是学会了如何设计一个比较全面的问卷调查方法，需要考虑需要的各个方面，从需求开始，从分支扩展，按照需要的、可能的、与结论相关的因素进行讨论，由此编写有效的问卷；其次第一次进行编码操作，之前学会的硬编码和热编码并没有使用，所以未知其用途，在这里发现在方差分析的时候，必须使用编码参数进行调用；最后，发现python或许是万能的，但并不是最方便的，这些统计分析之类的，需要自己慢慢编写程序，而在spss中却是及其方便，由此我以后或许可以尝试，使用python进行清洗整理数据以及机器学习相关，使用spss完成统计分析，以及使用tableau实现图表可视化。</p>
]]></content>
      <categories>
        <category>数据分析实战</category>
      </categories>
      <tags>
        <tag>调查问卷</tag>
        <tag>数据编码</tag>
        <tag>方差分析</tag>
        <tag>频数统计</tag>
        <tag>交叉分析</tag>
      </tags>
  </entry>
  <entry>
    <title>快乐Linux学习（六）</title>
    <url>/2021/02/19/%E5%BF%AB%E4%B9%90Linux%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>本文主要是介绍Linux中的正则表达式</p>
<p>适用于需要学习正则表达式的同学。</p>
</blockquote>
<span id="more"></span>
<p>正则表达式是一种符号表示法，用来识别文本模式，与之前使用过的路径通配符有些相似，但是功能更强大。</p>
<p>需要注意的是，很多系统和编程语言的都是具有正则表达式这个规则的，但是并不完全相同，此处仅学习Linux系统下POSIX标准中藐视的正则表达式，之后其他系统触类旁通学习即可。</p>
<h2 id="grep">grep</h2>
<p>主要使用的是grep程序，名字来自于“global regular expression print”，能够在文本文件中查找一个指定的正则表达式，并将匹配到的结果进行输出。</p>
<p>例如先使用ls标准输出/usr/bin的目录名，再通过管道，grep从管道中接受输入，并将匹配结果进行输出。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls /usr/bin | grep zip</span><br></pre></td></tr></table></figure>
<p>不通过管道的表达式如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep [options] regex [file...]</span><br></pre></td></tr></table></figure>
<p>选项options有下列情况：</p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-i</td>
<td>忽略大小写</td>
</tr>
<tr class="even">
<td>-v</td>
<td>获得不匹配项</td>
</tr>
<tr class="odd">
<td>-c</td>
<td>获得匹配的数量</td>
</tr>
<tr class="even">
<td>-l/-L</td>
<td>打印存在匹配/不匹配项的文件夹名</td>
</tr>
<tr class="odd">
<td>-n</td>
<td>打印匹配项的行号和结果</td>
</tr>
</tbody>
</table>
<h2 id="元字符和原义字符">元字符和原义字符</h2>
<p>上面grep后的<code>zip</code>，其中的“z”，“i”，“p”都是按照原本的意思和顺序进行匹配的，这些称为原义字符，需要使用其他规则进行匹配的时候，还包含如下<strong>元字符</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^ $ . [ ] &#123; &#125; - ? * + ( ) | \</span><br></pre></td></tr></table></figure>
<p>其中POSIX 规范的字符集又将元字符又存在两种情况，基本正则表达式（BRE）和扩展的正则表达式（ERE），BRE中支持的是<code>^ $ . [ ] *</code>，ERE在此基础上扩展了<code>( ) &#123; &#125; ? + |</code>，使用的时候需要增加<code>-E</code>选项表示执行ERE标准。</p>
<table>
<thead>
<tr class="header">
<th>元字符</th>
<th>解释</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>.</td>
<td>任何字符</td>
<td>可以用来匹配在某个位置的任意<strong>一个</strong>字符。</td>
</tr>
<tr class="even">
<td>^ / $</td>
<td>锚点</td>
<td>该表达式在文本开头/末尾存在才会被匹配。“^$”组合可以匹配空行。</td>
</tr>
<tr class="odd">
<td>[ ]</td>
<td>指定字符集</td>
<td>从中括号内的指定字符集匹配<strong>一个</strong>字符。元字符在被放置到中括号中后将会失去本身的特殊含义，除了“^”和“-”。</td>
</tr>
<tr class="even">
<td>^</td>
<td>否定</td>
<td>在<strong>中括号内第一个字符</strong>时表示否定，匹配中括号内字符集以外的字符。</td>
</tr>
<tr class="odd">
<td>-</td>
<td>字符范围</td>
<td>例如[a-z]，[B-Y]，[4-9a-h]等。</td>
</tr>
<tr class="even">
<td>|</td>
<td>交替</td>
<td>允许从一系列表达式之间选择匹配项。</td>
</tr>
<tr class="odd">
<td>？</td>
<td></td>
<td>匹配零个或一个元素。</td>
</tr>
<tr class="even">
<td>*</td>
<td></td>
<td>匹配零个或多个元素。</td>
</tr>
<tr class="odd">
<td>+</td>
<td></td>
<td>匹配一个或多个元素。</td>
</tr>
<tr class="even">
<td>{ }</td>
<td></td>
<td>匹配特定个数的元素，n：元素只出现n次，n,m：元素出现[n,m]次，n,：元素出现不少于n次，,m：元素出现不多于m次。</td>
</tr>
</tbody>
</table>
<p>补充一些字符集：[:word:]=[:alnum:]+[_]；[:alnum:]=[:alpha:]+[:digit:]；[:blank:]=空格+tab；[:cntrl:]=0-31和127字符；[:lower:]；[:upper:]；[:punct:]=标点符号；[:print:]=[:graph:]+[:space:]；[:xdigit:]=[0-9A-Fa-f]</p>
<p>其他的基本都可以被视为<strong>原义字符</strong>。元字符也可以被<strong>反斜杠</strong>转义为原义字符。</p>
<blockquote>
<p>所以之前在shell执行的时候，存在的一些元字符等特殊符号会被展开，这时候就可以使用引号阻止其展开。</p>
</blockquote>
<h2 id="应用正则表达式">应用正则表达式</h2>
<h3 id="使用grep匹配">使用grep匹配</h3>
<p>首先使用下列语句生成一个测试的搜索匹配列表，多尝试几次，生成不符合“(nnn) nnn-nnnn”格式的电话号码，以便用来匹配。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for i in &#123;1..10&#125;; do echo &quot;($&#123;RANDOM:0:3&#125;) $&#123;RANDOM:0:3&#125;-$&#123;RANDOM:0:4&#125;&quot; &gt;&gt;phonelist.txt; done</span><br></pre></td></tr></table></figure>
<p>再使用cat和管道连接grep，因为使用了扩展的正则表达式，所以需要使用-E选项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat phonelist.txt | grep -Ev &#x27;^\([0-9]&#123;3&#125;\) [0-9]&#123;3&#125;-[0-9]&#123;4&#125;&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="使用find查找">使用find查找</h3>
<p>查找某个路径下的文件名是否符合满足正则表达式要求，例如查找当前路径下包含空格等不符合规范的路径名。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -regex &#x27;.*[^-\_./0-9a-zA-Z].*&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="利用locate查找文件">利用locate查找文件</h3>
<p>locate支持基本的（--regexp）和扩展的（regex）正则表达式。例如搜索包含指定字符串的路径名。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">locate --regex &#x27;bin/(bz|gz|zip)&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="在lessvim中使用正则表达式">在less/vim中使用正则表达式</h3>
<p>less是使用“<code>/</code>”命令输入正则表达式进行匹配</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">less phonelist.txt</span><br><span class="line">/^\([0-9]&#123;3&#125;\) [0-9]&#123;3&#125;-[0-9]&#123;4&#125;$</span><br></pre></td></tr></table></figure>
<p>vim也类似，不过vim中使用扩展表达式会被认作为文本字符，需要使用反斜杠进行转义为元字符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/([0-9]\&#123;3\&#125;) [0-9]\&#123;3\&#125;-[0-9]\&#123;4\&#125;</span><br></pre></td></tr></table></figure>
<p>默认是没有高亮显示的，想要高亮显示的话可以在命令模式下输入<code>:set hlsearch</code>转化为高亮模式。</p>
<h2 id="个人收获">个人收获</h2>
<p>本章主要学习的是正则表达式，了解到不同系统和语言会具有不完全相同的正则表达式，主要是用于之后的查找和筛选，以及在处理数据的时候能够利用规则直接提取相关信息，比较重要。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>战略分析案例——网上商城</title>
    <url>/2021/02/16/%E6%88%98%E7%95%A5%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<blockquote>
<p>本文是根据《活用数据|驱动业务的数据分析实战》中的案例进行的学习总结，主要是从内外部因素对企业网上商城进行定性和定量分析，并结合波士顿矩阵进行分析。</p>
<p>适用于需要结合案例学习数据分析方法的初学者。</p>
</blockquote>
<span id="more"></span>
<h2 id="总体思路">总体思路</h2>
<p>进行战略分析的分析思路是进行研究目的和研究内容的分解，下面对此分别进行考虑。</p>
<p>首先考虑<code>研究目的</code>，这里是帮助商城进行<strong>战略选择</strong>，选择最适合商城的目标市场。对此我们需要分析两个因素：</p>
<ul>
<li>外部因素——市场吸引力：市场情况如何，是否有希望获得足够的利益；</li>
<li>内部因素——企业竞争力：企业是否有能力进入市场，进入市场后能够获得多少利益。</li>
</ul>
<p>其次分析<code>研究内容</code>，主要是进行环境分析，包括宏观环境、市场环境、竞争环境分析。</p>
<h2 id="环境分析">环境分析</h2>
<h3 id="宏观环境分析">宏观环境分析</h3>
<p>宏观环境是指影响市场的各种宏观原因，可以利益PEST进行概况：</p>
<ul>
<li>政治环境 Political</li>
<li>经济环境 Economic</li>
<li>社会文化环境 Social</li>
<li>技术环境 Technological</li>
</ul>
<p>通过宏观环境分析，企业可以判断出，对某企业而言，哪些因素是机会，哪些因素是威胁，若<strong>机会大于威胁</strong>，则说明该市场具有吸引力。</p>
<h3 id="市场环境分析">市场环境分析</h3>
<p>市场环境是指市场的<strong>具体情况</strong>，需要考虑的因素比较多，比较倾向于市场规模大、利润水平高、增长速度快、成长潜力强、所处生命周期成长期等，这种市场对于企业更具有吸引力。但是大部分市场并不会同时满足以上条件，所以，需要企业按照自身资源和定位情况进行取舍。</p>
<p>通过以上宏观环境和市场环境可以分析得出市场对企业是否具有吸引力，但是并不是具有吸引力的市场，就一定会使得企业获利，因为我们还需要对比企业自身优势进行分析。优势并不是绝对的，而是相对的，其相对于竞争环境，所以需要进行竞争环境分析。</p>
<h3 id="竞争环境分析">竞争环境分析</h3>
<p>企业的竞争环境可以归纳为影响企业生存状况的波特五力，包括供应商、购买者、直接竞争对手、替代品和潜在进入者五个方面的力。</p>
<p>通过对比分析这企业在五力中的情况，如果总体处于上风，则表明企业具有竞争力。</p>
<h2 id="实例演示">实例演示</h2>
<p>本案例是在jupyter上进行的，可以参考我在Github上相应的<a href="https://github.com/Gipbear/data-analysis/blob/master/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/%E8%B4%AD%E7%89%A9%E4%B8%AD%E5%BF%83%E7%BD%91%E4%B8%8A%E5%95%86%E5%9F%8E%E6%88%98%E7%95%A5%E5%88%86%E6%9E%90/%E6%9F%90%E8%B4%AD%E7%89%A9%E4%B8%AD%E5%BF%83%E7%BD%91%E4%B8%8A%E5%95%86%E5%9F%8E%E6%88%98%E7%95%A5%E5%88%86%E6%9E%90.ipynb">代码</a></p>
<ol type="1">
<li><p>首先导入需要使用的依赖包（个人偏好都添加在第一行）;</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> mpl</span><br><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> set_matplotlib_formats</span><br><span class="line"></span><br><span class="line">%matplotlib inline</span><br></pre></td></tr></table></figure></p></li>
<li><p>读取excel表格，依次读取各个sheet中的内外因素评价矩阵;</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df1 = pd.read_excel(<span class="string">&#x27;data/内外因素评价矩阵数据.xlsx&#x27;</span>,sheet_name=<span class="number">0</span>)</span><br><span class="line">col_name = [<span class="string">&#x27;分数&#x27;</span>,<span class="string">&#x27;电商在销售渠道地位凸显&#x27;</span>,<span class="string">&#x27;国内消费者信心指数攀升&#x27;</span>,<span class="string">&#x27;电子商务交易额迅速增长&#x27;</span>,<span class="string">&#x27;通过电商可以掌握用户界面&#x27;</span>,<span class="string">&#x27;国家政策的扶持&#x27;</span>]</span><br><span class="line">df1.columns = col_name</span><br><span class="line"></span><br><span class="line">df2 = pd.read_excel(<span class="string">&#x27;data/内外因素评价矩阵数据.xlsx&#x27;</span>,sheet_name=<span class="number">1</span>)</span><br><span class="line">col_name = [<span class="string">&#x27;分数&#x27;</span>,<span class="string">&#x27;激烈的市场竞争&#x27;</span>,<span class="string">&#x27;电子商务诚信制度未完善&#x27;</span>,<span class="string">&#x27;网络安全缺乏坚实保障&#x27;</span>]</span><br><span class="line">df2.columns = col_name</span><br><span class="line"></span><br><span class="line">df3 = pd.read_excel(<span class="string">&#x27;data/内外因素评价矩阵数据.xlsx&#x27;</span>,sheet_name=<span class="number">2</span>)</span><br><span class="line">col_name = [<span class="string">&#x27;分数&#x27;</span>,<span class="string">&#x27;实力强大&#x27;</span>,<span class="string">&#x27;消费者信誉良好&#x27;</span>,<span class="string">&#x27;良好的企业形象&#x27;</span>,<span class="string">&#x27;透明化贴心服务&#x27;</span>]</span><br><span class="line">df3.columns = col_name</span><br><span class="line"></span><br><span class="line">df4 = pd.read_excel(<span class="string">&#x27;data/内外因素评价矩阵数据.xlsx&#x27;</span>,sheet_name=<span class="number">3</span>)</span><br><span class="line">col_name = [<span class="string">&#x27;分数&#x27;</span>,<span class="string">&#x27;缺乏电商运营经验&#x27;</span>,<span class="string">&#x27;缺乏网购消费者群体&#x27;</span>,<span class="string">&#x27;网站建设不完整&#x27;</span>,<span class="string">&#x27;物流体系未真正建成&#x27;</span>]</span><br><span class="line">df4.columns = col_name</span><br></pre></td></tr></table></figure></p></li>
<li><p>计算权重分为两个步骤：</p>
<ol type="1">
<li><p>计算评分均值：将专家人数作为权重<span class="math inline">\(f\)</span>，对分数<span class="math inline">\(x_i\)</span>求其加权平均值： <span class="math display">\[
 \bar{x} = \frac{\sum{x_i \times f_i}}{\sum{f_i}}
 \]</span></p></li>
<li><p>计算权重：权重的确定方法有很多，大体分为主观赋权法（层次分析法等）和客观赋权法（主成分分析法等），此处采用变异系数方法来计算： <span class="math display">\[
 \text{V} = \frac{\sigma}{\bar{x}} 
 \]</span> 其中<span class="math inline">\(\sigma\)</span>是标准差，<span class="math inline">\(\sigma=\sqrt{\sum{(x_i-x)^2 \times Pi}}\)</span>，而其中<span class="math inline">\(\sum{(x_i-x)^2}\)</span>是该因素的离差平方和，<span class="math inline">\(P_i\)</span>是该因素的频率。</p></li>
</ol>
<blockquote>
<p>在评价体系中，若某个因素的取值差异较大，则说明该因素难以实现，是反映评价对象差距的关键因素，就要赋予更大的权重。</p>
<p>变异系数在数值上等于标准差除以均值，可以表示因素取值的波动情况，因此这里可以使用变异系数来赋权。</p>
</blockquote>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算变异系数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coefficient_variation</span>(<span class="params">df,dfn,num</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    df: 统计矩阵</span></span><br><span class="line"><span class="string">    dfn: 矩阵编号</span></span><br><span class="line"><span class="string">    num: 样本数</span></span><br><span class="line"><span class="string">    res: 样本评分</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    me = df[<span class="string">&#x27;分数&#x27;</span>].dot(df.iloc[:,<span class="number">1</span>:])/num <span class="comment"># 计算评分均值</span></span><br><span class="line">    dfa = df.iloc[:,<span class="number">1</span>:]/num <span class="comment"># 计算分数频率</span></span><br><span class="line">    s = df[<span class="string">&#x27;分数&#x27;</span>]-me[dfn]</span><br><span class="line">    dfb = s*s <span class="comment"># 计算分数离差平方和</span></span><br><span class="line">    dfc = dfb.dot(dfa).apply(np.sqrt) <span class="comment"># 计算标准差</span></span><br><span class="line">    dfd = dfc/me[dfn] <span class="comment"># 计算变异系数</span></span><br><span class="line">    <span class="keyword">return</span> dfd,me</span><br></pre></td></tr></table></figure></p></li>
<li><p>求得变异系数<span class="math inline">\(\text{V}\)</span>之后，使用<span class="math inline">\(W_i=\frac{V_i}{\sum{V_i}}\)</span>求得最终的权重，并计算各个评分均值加权平均数来获得最终的得分。</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算最后得分</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_score</span>(<span class="params">coeVar,me</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    coeVar: 变异系数</span></span><br><span class="line"><span class="string">    me: 评分均值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    weights = coeVar / <span class="built_in">sum</span>(coeVar) <span class="comment"># 计算权重</span></span><br><span class="line">    score = weights.dot(me) <span class="comment"># 计算评分的加权平均数</span></span><br><span class="line">    <span class="keyword">return</span> score</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">coeVar, me= coefficient_variation(df1,<span class="number">0</span>,<span class="number">200</span>)</span><br><span class="line">score1 = get_score(coeVar,me)</span><br><span class="line">coeVar, me= coefficient_variation(df2,<span class="number">1</span>,<span class="number">200</span>)</span><br><span class="line">score2 = get_score(coeVar,me)</span><br><span class="line">coeVar, me= coefficient_variation(df3,<span class="number">2</span>,<span class="number">2000</span>)</span><br><span class="line">score3 = get_score(coeVar,me)</span><br><span class="line">coeVar, me= coefficient_variation(df4,<span class="number">3</span>,<span class="number">2000</span>)</span><br><span class="line">score4 = get_score(coeVar,me)</span><br></pre></td></tr></table></figure></p></li>
<li><p>得到各个优势、劣势、机会和威胁的最终得分之后，计算<span class="math inline">\(\frac{优势}{劣势}\)</span>的比值是否大于1，若大于1则说明优势大于劣势，企业具有竞争力，否则不具有竞争力；计算<span class="math inline">\(\frac{机会}{威胁}\)</span>的比值是否大于1，若大于1则说明机会大于威胁，市场具有吸引力，否则不具有吸引力。</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = score1/score2</span><br><span class="line">y = score3/score4</span><br></pre></td></tr></table></figure></p></li>
<li><p>根据求得的两个比值制作战略选择波士顿矩阵图，进行战略选择分析：</p>
<ol type="1">
<li>SO战略：市场机会多，企业优势明显，属于增长型，利用外部机会和自身优势，创造最大收益；</li>
<li>WO战略：市场机会多，企业劣势明显，属于扭转型，利用外部机会，克服自身劣势，抓住机遇；</li>
<li>ST战略：市场威胁多，企业优势明显，属于多种经营型，依靠自身优势，回避外部威胁，勇敢面对挑战；</li>
<li>WT战略：市场威胁多，企业劣势明显，属于防御型，减少外部威胁和自身劣势，休养生息。</li>
</ol>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">set_matplotlib_formats(<span class="string">&#x27;svg&#x27;</span>)</span><br><span class="line">mpl.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>] <span class="comment"># 中文字体</span></span><br><span class="line"></span><br><span class="line">lim = <span class="built_in">max</span>(<span class="built_in">round</span>(x,<span class="number">1</span>),<span class="built_in">round</span>(y,<span class="number">1</span>)) + <span class="number">0.2</span> <span class="comment"># 坐标区间</span></span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">plt.scatter(x,y,marker=<span class="string">&#x27;o&#x27;</span>,s=<span class="number">100</span>) <span class="comment"># 绘制散点图</span></span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">&#x27;机会最终得分/威胁最终得分&#x27;</span>,fontsize=<span class="number">16</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;优势最终得分/劣势最终得分&#x27;</span>,fontsize=<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">plt.xlim(<span class="number">0</span>,lim)</span><br><span class="line">plt.ylim(<span class="number">0</span>,lim)</span><br><span class="line"></span><br><span class="line">plt.vlines(<span class="number">1</span>,<span class="number">0</span>,lim,colors=<span class="string">&quot;r&quot;</span>,linestyles=<span class="string">&quot;dashed&quot;</span>)</span><br><span class="line">plt.hlines(<span class="number">1</span>,<span class="number">0</span>,lim,colors=<span class="string">&quot;r&quot;</span>,linestyles=<span class="string">&quot;dashed&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.text(x+<span class="number">0.001</span>,y,<span class="string">&#x27;&#123;:.2f&#125; &#123;:.2f&#125;&#x27;</span>.<span class="built_in">format</span>(x,y),ha=<span class="string">&#x27;left&#x27;</span>,va=<span class="string">&#x27;bottom&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.text(<span class="number">0.02</span>,lim-<span class="number">0.12</span>,<span class="string">&#x27;&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;ST战略&#x27;</span>),ha=<span class="string">&#x27;left&#x27;</span>,va=<span class="string">&#x27;bottom&#x27;</span>,color=<span class="string">&quot;w&quot;</span>,fontsize=<span class="number">20</span>).set_bbox(<span class="built_in">dict</span>(facecolor=<span class="string">&#x27;black&#x27;</span>, alpha=<span class="number">0.5</span>))</span><br><span class="line">plt.text(<span class="number">0.02</span>,<span class="number">1</span>-<span class="number">0.12</span>,<span class="string">&#x27;&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;WT战略&#x27;</span>),ha=<span class="string">&#x27;left&#x27;</span>,va=<span class="string">&#x27;bottom&#x27;</span>,color=<span class="string">&quot;w&quot;</span>,fontsize=<span class="number">20</span>).set_bbox(<span class="built_in">dict</span>(facecolor=<span class="string">&#x27;black&#x27;</span>, alpha=<span class="number">0.5</span>))</span><br><span class="line">plt.text(<span class="number">1.02</span>,lim-<span class="number">0.12</span>,<span class="string">&#x27;&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;SO战略&#x27;</span>),ha=<span class="string">&#x27;left&#x27;</span>,va=<span class="string">&#x27;bottom&#x27;</span>,color=<span class="string">&quot;w&quot;</span>,fontsize=<span class="number">20</span>).set_bbox(<span class="built_in">dict</span>(facecolor=<span class="string">&#x27;black&#x27;</span>, alpha=<span class="number">0.5</span>))</span><br><span class="line">plt.text(<span class="number">1.02</span>,<span class="number">1</span>-<span class="number">0.12</span>,<span class="string">&#x27;&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;SWO战略&#x27;</span>),ha=<span class="string">&#x27;left&#x27;</span>,va=<span class="string">&#x27;bottom&#x27;</span>,color=<span class="string">&quot;w&quot;</span>,fontsize=<span class="number">20</span>).set_bbox(<span class="built_in">dict</span>(facecolor=<span class="string">&#x27;black&#x27;</span>, alpha=<span class="number">0.5</span>))</span><br></pre></td></tr></table></figure></p></li>
</ol>
<p>最终得到波士顿矩阵，如图：</p>
<img src="/2021/02/16/%E6%88%98%E7%95%A5%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/%E7%BD%91%E4%B8%8A%E5%95%86%E5%9F%8E%E6%88%98%E7%95%A5%E5%88%86%E6%9E%90%E6%B3%A2%E5%A3%AB%E9%A1%BF%E7%9F%A9%E9%98%B5%E5%9B%BE.svg" class="" title="网上商城战略分析波士顿矩阵图">
<h2 id="结论">结论</h2>
<p>该购物中心网上商城的业务处于SO战略区，市场机会多，自身优势明显，可以充分利用市场机会和自身优势快速发展，创建最佳业务。</p>
<h2 id="个人收获">个人收获</h2>
<p>通过本案例的学习，首先掌握了PEST和波特五力两种分析思路，从宏观和细节上对分析对象进行细化；SWOT定性分析方法将细化后的对象进行内外因素分析，并通过量化方法进行定量分析。该案例有层次的、内外结合的、定性定量的分析，学习了如何进行一次全面的战略分析。</p>
]]></content>
      <categories>
        <category>数据分析实战</category>
      </categories>
      <tags>
        <tag>战略分析</tag>
        <tag>PEST</tag>
        <tag>SWOT</tag>
        <tag>波特五力</tag>
        <tag>波士顿矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>林骥的思维分析模型（一）</title>
    <url>/2021/02/12/%E6%9E%97%E9%AA%A5%E7%9A%84%E6%80%9D%E7%BB%B4%E5%88%86%E6%9E%90%E6%A8%A1%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>本文是在对林骥公众号中的100种思维分析模型（更新中）上进行自我理解。</p>
<p>适用于想要了解多种分析模型的同学，主要是关于模型的一些应用和注意点，并没有具体的模型详解。</p>
</blockquote>
<span id="more"></span>
<h2 id="福格行为模型">福格行为模型</h2>
<p>该模型主要是用来分析<code>用户行为</code>的<u>产生原因</u>和<u>基础心理</u>。</p>
<p><span class="math display">\[
行为 = 动机 \times 能力 \times 触发
\]</span> 用户的行为由三要素决定（例如购物）：</p>
<ol type="1">
<li>用户去做这件事情的动机（why用户购买产品）；</li>
<li>用户完成这件事情的能力（how让用户方便购买）；</li>
<li>触发用户去采取行动的信号（what触发用户想要购买）。</li>
</ol>
<p>在其中也暗含了4p营销理论：产品（Product）、价格（Price）、促销（Promotion）、渠道（Place）</p>
<h2 id="杜邦分析模型">杜邦分析模型</h2>
<p>该模型主要是对关键指标进行分解，在<code>财务分析</code>、<code>销售管理</code>方面有助于深入分析企业的经营业绩。</p>
<p>杜邦分析模型将指标之间的<u>内在联系</u>结合起来，形成一套类似金字塔结构，层次清晰的指标体系，从而暴露出影响业务的关键因素。</p>
<ol type="1">
<li>从核心指标开始，逐层分解各个指标；</li>
<li>制作杜邦分析图，填入相关指标数据；</li>
<li>对比前后期数据，或者横向进行对比。</li>
</ol>
<h2 id="矩阵分析模型">矩阵分析模型</h2>
<p>该模型也称作波士顿矩阵或四象限分析法。通过两个关键指标组成象限即可进行分析。主要是用来分析<code>产品和结构</code>，其中特别关注<strong>销售增长率</strong>和<strong>市场占有率</strong>这两个指标。</p>
<ol type="1">
<li>找出两种最关注的指标（销售增长率A和市场占有率B）；</li>
<li>绘制四象限分析图表（假设增长方向为从左至右和从下至上）；</li>
<li>分析总结并提出建议（AB均低的产品可以逐渐放弃，A高B低是有问题的产品，需要调整策略，A低B高则可以保持现状，AB均高的可以考虑加大投资）；</li>
</ol>
<p>针对不同的象限将产品进行分类，由此来采取不同的发展策略，从而实现产品结构的良性循环。</p>
<h2 id="夏普利值模型">夏普利值模型</h2>
<p>该模型综合考虑各方利益，使得所作和所得相等，保证利益分配的公平合理。主要在分配权力等问题上非常有用。</p>
<ol type="1">
<li>列举角色可能出现的各种分配情况；</li>
<li>判断角色在分配过程是否起作用；</li>
<li>计算分析角色起作用的占比情况。</li>
</ol>
<p>价值并不在于拥有的资源或历史贡献，而是在所有可能的合作中，不可或缺的程度。</p>
<blockquote>
<p>我们的成长也需要提高核心竞争力。</p>
</blockquote>
]]></content>
      <categories>
        <category>他山之石</category>
      </categories>
      <tags>
        <tag>思维方式</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql中位数</title>
    <url>/2021/02/06/mysql%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<blockquote>
<p>本文是在mysql中查询一列<strong>奇数</strong>个数据的中位数。</p>
</blockquote>
<span id="more"></span>
<p>在<a href="https://www.hackerrank.com/dashboard">HackerRank</a>刷题的时候遇到了一道需要查询中位数的题目。</p>
<h2 id="题目">题目</h2>
<p>将中位数定义为：将数据集的上半部分与下半部分分开的数字，也就是仅存在一个中位数。</p>
<p>需要找出某列的中位数。</p>
<h2 id="思路">思路</h2>
<p>Station表中存在奇数个数据，那么我们要查找的LAT_N就是将数据分开后使得：上半部分个数=下半部分个数。</p>
<p>于是我们需要在查询该表Station S的同时，再创建两个相同的Station表来计算上下部分的LAT_N个数，在检查记录的同时比较上下两部分的数量，当数量相同的时候，该S.LAT_N就是需要得到的中位数。</p>
<h2 id="方案">方案</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select round(s.LAT_N,4)</span><br><span class="line">from station s</span><br><span class="line">where (select count(LAT_N)</span><br><span class="line">       from station</span><br><span class="line">       where LAT_N &lt; s.LAT_N) = (</span><br><span class="line">           select count(LAT_N)</span><br><span class="line">           from station</span><br><span class="line">           where (LAT_N &gt; s.LAT_N))</span><br></pre></td></tr></table></figure>
<h2 id="个人收获">个人收获</h2>
<p>当遇到比较抽象的问题的时候，需要学会转换思路，将抽象的中位数定义，转化为现实的，上下部分数量相同问题；也要熟悉mysql中创建新表和原表比较的方法。</p>
]]></content>
      <categories>
        <category>增删改查</category>
      </categories>
      <tags>
        <tag>select</tag>
        <tag>中位数</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>python常用函数</title>
    <url>/2021/02/06/python%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<blockquote>
<p>本文罗列了回顾python时候的一些常用函数</p>
</blockquote>
<span id="more"></span>
<ul>
<li><p><a href="https://www.hackerrank.com/challenges/text-alignment/problem">文字对齐</a>：</p>
<p><code>string.ljust(width,'-')</code>string在左侧；<code>string.center(width,'-')</code>string居中；<code>string.rjust(width,'-')</code>string在右侧</p></li>
<li><p><a href="https://www.hackerrank.com/challenges/text-wrap/problem">文本自动换行</a>：</p>
<p><code>textwrap.wrap(string, width)</code>获得list，使用<code>'\n'.join()</code>进行连接</p></li>
<li><p><a href="https://www.hackerrank.com/challenges/python-string-formatting/problem">矩阵显示多进制</a>：</p>
<p>二进制八进制以及十六进制的格式化显示，矩阵间距为二进制宽度。使用format进行格式化</p></li>
<li></li>
</ul>
<h2 id="个人收获">个人收获</h2>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>幸存者偏差</title>
    <url>/2021/02/05/%E5%B9%B8%E5%AD%98%E8%80%85%E5%81%8F%E5%B7%AE/</url>
    <content><![CDATA[<blockquote>
<p>本文主要解释了幸存者偏差的定义</p>
</blockquote>
<span id="more"></span>
<h2 id="定义">定义</h2>
<p>幸存者偏差（Survivorship bias）是指从筛选之后的<u>“幸存者”样本</u>中得到结论，从而产生的偏差。</p>
<h2 id="偏差影响">偏差影响</h2>
<p>这种偏差属于认知上的偏差，仅考虑了获得的样本，而忽视了未通过筛选的样本。在这种偏差下往往会出现两种常见的错误：<strong>规则推导</strong>和<strong>因果推断</strong>。</p>
<ul>
<li><p>规则推导：现存的事物是曾经唯一存在过的事物。</p>
<p>我们会假设自己所看到是事物是过去唯一的存在，而实际上很多过去的事物并未保存至今。（商朝流只传下青铜器，但是并不表示商朝只用青铜器）</p></li>
<li><p>因果推断：某个机制中幸存下来的事物都会受到该机制的影响。</p>
<p>并不是从该机制中幸存下来说明该机制影响了该事物，而是该事物满足了该机制的条件才得以幸存。</p></li>
</ul>
<h2 id="bi软件调研分析">BI软件调研分析</h2>
<p>假设一家商业智能（BI）软件公司正在开展2周免费使用活动，一周后剩下少数用书仍在使用，并且这些用户都是数据分析师，借助该软件进行了更加复杂的分析。</p>
<p>按照调研的结果，可能会得到两个<strong>错误</strong>的结论：</p>
<ul>
<li><p>BI软件的适用人群是数据分析师。</p>
<p>在下结论之前，同样需要观察那些<u>“非幸存者”</u>（放弃使用的用户），我们并不知道这些用户中是否也有数据分析师。如果我们的调研用户全部是数据分析师，若离开的用户比剩下的用户更多时，那么得出的结论则恰恰相反。</p>
<p>为了得到正确的结论，我们需要分析每一个一开始就加入使用的用户，找到真正能够区分同期群的用户特征。</p></li>
<li><p>BI软件让深入数据分析变得更加容易：</p>
<p>在调研中，我们并没有设置一个对照组来比较用户之间的<strong>分析能力</strong>，这些用户或许是在使用BI软件做最高级的任务，但是或许在其他软件上能够做更高级的事情，也获取用户本身就是资深的数据分析师，无论使用说明软件都能进行深入分析。而不是因为使用了该BI软件才能进行深入分析。</p>
<p>若要衡量该软件的真正价值，则需要先评估用户分析水平，然后对比在相似的分析任务，操作不同软件的表现，从而得到有说服力的结论。</p></li>
</ul>
<h2 id="个人收获">个人收获</h2>
<p>分析所有同期群的用户；衡量产品价值的时候需要和竞争对手的产品进行对比；对比用户使用前后的改变，得到产品带来的因果关系。</p>
]]></content>
      <categories>
        <category>统计学</category>
      </categories>
      <tags>
        <tag>误差</tag>
      </tags>
  </entry>
  <entry>
    <title>快乐Linux学习（五）</title>
    <url>/2021/02/01/%E5%BF%AB%E4%B9%90Linux%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>本文是快乐学习Linux的第五篇，是基于Windows的Linux子系统（WSL）进行操作的。</p>
<p>适用于学习Linux系统中shell环境和vi相关内容的读者。</p>
</blockquote>
<span id="more"></span>
<h2 id="shell环境">shell环境</h2>
<p>shell在shell会话中保存着大量的信息，这些信息被称为shell环境。</p>
<p>一般程序都是通过获取环境中的数据（<strong>环境变量</strong>）或<strong>配置文件</strong>来存储程序的设置，所以我们可以调整环境变量或配置文件来改变程序的行为。</p>
<p>在shell环境中，一般存储两种基本类型的数据，一种是环境变量，一种是shell变量（bash存放的少量数据）。</p>
<ul>
<li>printenv：可以显示环境变量，看到的是环境变量及其对应的数值。</li>
<li>set：可以显示环境变量、shell变量和自定义的shell函数，并且按照首字母排序。</li>
</ul>
<h2 id="shell启动文件">shell启动文件</h2>
<p>登录系统之后会启动bash程序，读取一些列称为启动文件的配置脚本，之后再读取用户home目录的启动文件，这两个启动文件分别定义了全局和个人的shell环境。其中的启动顺序根据shell会话类型来决定。</p>
<ul>
<li><p>登录shell会话</p>
<p>会提示用户输入用户名和密码，读取一个或多个启动文件。</p>
<p>首先是应用于所有用户的全局配置文件：<code>/etc/profile</code>，然后是用户个人的启动文件：在WSL下使用的是：<code>~/.profile</code>，其他的Linux版本可能是<code>~/.bash_profile</code>和<code>~/.bash_login</code>。</p></li>
<li><p>非登录shell会话</p>
<p>一般是在GUI下启动终端会话时出现，读取全局配置文件：<code>/etc/bash.bashrc</code>，以及个人配置文件：<code>~/.bashrc</code>。并会集成父进程的环境设置（一般是一个登录shell进程）。</p></li>
</ul>
<h3 id="修改配置文件">修改配置文件</h3>
<p>修改配置文件的时候，可以使用文本编辑器打开文件，例如使用下面会提到的<strong>vi</strong>进行修改。</p>
<p>修改之前可以对文件进行备份，通常使用扩展名<code>.bak</code>、<code>.sav</code>、<code>.old</code>等方式来备份：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp .bashrc .bashrc.bak</span><br></pre></td></tr></table></figure>
<p>然后修改<code>.bashrc</code>文件，遇到麻烦的时候可以再利用备份文件进行还原。</p>
<p>修改之后使用source来激活配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source .bashrc</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一般来说，添加目录到PATH变量或定义额外的环境变量，需要把修改<code>.profile</code>文件（或替代文件<code>.bash_profile</code>），对于其他的修改则放在<code>.bashrc</code>文件中。</p>
</blockquote>
<h2 id="vi">vi</h2>
<p>在很多Linux系统都预装了vi程序，并且存在另一个高级替代版vim（vi improved），之后我们使用是vi实际上就是vim。vi具有轻量且快速的特点，相比于一些其他并不会在Linux上都预装的文本编辑器，在远程服务器上进行文本修改的时候，vi就显得相当方便了。</p>
<blockquote>
<p>最重要的是：不会的话会被其他Linux使用者嘲笑！所以加油吧:fist_oncoming:！</p>
</blockquote>
<h3 id="打开和退出">打开和退出</h3>
<p>首先最重要的是学会如何打开vi，并关闭它。</p>
<p>WSL已经预装了vim，我们在命令行输入vi或vim命令即可进入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi</span><br></pre></td></tr></table></figure>
<p>会发现显示<code>VIM - Vi IMproved</code>等内容，但实际上这些并不是打开了任何文件的内容，因为在vi中，行编辑最左侧出现了波浪号<code>~</code>说明该行内容为空。此时不要按下键盘上的任何键，因为我们此时处于vi的命令模式，如果我们需要退出的话，输入<code>:q</code>并按下回车就可以退出（出现在屏幕左下角，并且冒号是命令的一部分）。</p>
<blockquote>
<p>命令模式分为普通命令模式和ex模式，ex模式就是有冒号的命令，普通命令模式就是正常的命令，需要注意区分，在下文中，出现冒号的就是ex命令，否则就是普通命令。</p>
</blockquote>
<h3 id="移动光标">移动光标</h3>
<p>在vi的命令模式下，存在大量的移动命令：</p>
<table>
<thead>
<tr class="header">
<th>按键</th>
<th>移动效果</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>k j h l或Alt+方向键</td>
<td>上下左右（方向）移动一个字符</td>
</tr>
<tr class="even">
<td>0</td>
<td>移动到当前行的行首</td>
</tr>
<tr class="odd">
<td>^</td>
<td>当前行第一个非空字符</td>
</tr>
<tr class="even">
<td>$</td>
<td>当前行末尾</td>
</tr>
<tr class="odd">
<td>b w或Shift+方向键</td>
<td>移动到上/下一个单词或标点的开头</td>
</tr>
<tr class="even">
<td>B W或Ctrl+方向键</td>
<td>移动到上/下一个单词的开头</td>
</tr>
<tr class="odd">
<td>G</td>
<td>文件末尾</td>
</tr>
</tbody>
</table>
<p>并且可以使用<strong>数字和命令</strong>来控制移动多少个字符或行，例如<code>5h</code>向左移动5个字符。</p>
<h3 id="编辑文本">编辑文本</h3>
<p>我们使用vi可以直接创建一个新的或打开一个已经存在的文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi foo.txt</span><br></pre></td></tr></table></figure>
<p>执行命令会出现空白界面，我们需要知道的是：<strong>vi是一个模式编辑器</strong>，此时进入的vi的<strong>命令模式</strong>，按下的每一个键都是命令，所以千万不要乱来！</p>
<p>我们按下<code>i</code>键，在左下角会出现<code>-- INSERT --</code>，表示进入了<u>插入</u>模式。此时可以输入一些文本。输入文本之后需要返回，需要使用<code>Esc</code>重新进入命令模式，如果需要<u>保存修改</u>则使用<code>:w</code>或保存并退出<code>:wq</code>，如果不需要保存则使用<code>:q!</code>。</p>
<p>当我们想要<u>撤回</u>的时候，可以使用<code>u</code>来撤回对文本的最后一次<strong>修改</strong>，注意和word中只撤回几个字不一样，这是撤回最后一次<strong>修改</strong>。</p>
<p>当我们再一次进入foo.txt文件时，光标会出现在上次退出的地方，当我们想要在行尾进行插入的时候，发现<code>i</code>只能出现在最后一个字符之前，所以我们使用<code>a</code>进行插入，同样会出现<code>-- INSERT --</code>，表示进入编辑模式，或者<code>A</code>直接到达编辑行的行尾。</p>
<p>当我们需要<u>插入空白行</u>的时候，可以使用命令<code>o</code>在光标下方插入一行，使用命令<code>O</code>在光标上方插入一行。</p>
<h3 id="删除剪切复制和粘贴">删除、剪切、复制和粘贴</h3>
<p>这些操作的命令和移动光标类似</p>
<table>
<thead>
<tr class="header">
<th>按键</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[number]x</td>
<td>删除当前字符，及其后面number-1个字符</td>
</tr>
<tr class="even">
<td>[number]dd</td>
<td>剪切当前行，及其后面number-1行</td>
</tr>
<tr class="odd">
<td>d+移动光标的命令</td>
<td>移动光标决定剪切内容</td>
</tr>
<tr class="even">
<td>[number]yy</td>
<td>复制当前行，及其后面number-1行</td>
</tr>
<tr class="odd">
<td>y+移动光标的命令</td>
<td>移动光标决定复制内容</td>
</tr>
<tr class="even">
<td>P/p</td>
<td>粘贴到光标前/后</td>
</tr>
</tbody>
</table>
<h3 id="查找和替换">查找和替换</h3>
<p>使用<code>/</code>命令来查找匹配的字符。例如<code>/line</code>找到所有line开头的字符，使用n命令重复查询操作（可循环查找）。</p>
<p>替换操作则略显复杂，例如将文本所有的line都替换为Line，需要输入命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:%s/line/Line/gc</span><br></pre></td></tr></table></figure>
<p>%表示行数，省略则是执行当前行；s表示替换；/line/Line是查找与替换的文本；g是全局匹配，省略则是每行第一个匹配的进行替换；c是增加用户确认。</p>
<h3 id="多文件操作">多文件操作</h3>
<p>当我们需要进行多文件编辑的时候，就可以使用vi同时打开多个文本，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi foo.txt ls-output.txt</span><br></pre></td></tr></table></figure>
<p>此时屏幕显示第一个文件，使用<code>:n</code>切换到下一个文件，使用<code>:N</code>切换到上一个文件。也可以使用<code>:buffers</code>来查看打开的文件列表，使用<code>:buffer 编号</code>就可以切换编辑的文件。</p>
<p>当前文件修改而未保存的时候，vi会阻止我们进行跳转，在命令后添加感叹号可以强制跳转。</p>
<p>在打开的文件中，使用<code>:e 文件地址</code>就可以打开新的文件。</p>
<h2 id="个人收获">个人收获</h2>
<p>一些可以直接使用echo显得是命令原来就是shell环境中的变量，像path就和Windows中修改环境变量类似，影响着一些程序的运行，需要在安装一些程序的时候进行修改，例如安装WSL显示GUI界面，需要安装xlaunch，并且之后需要在.bashrc文件中进行一定的配置才能正常运行。</p>
<p>在vi编辑器方便则是学会基本的编辑操作和保存，有一定的认知即可，毕竟学习成本较高，正常情况下本人还是比较喜欢直接在Windows下使用交互式编辑器进行快速编辑。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>快乐Linux学习（四）</title>
    <url>/2021/01/28/%E5%BF%AB%E4%B9%90Linux%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>本文是快乐学习Linux的第四篇，是基于Windows的Linux子系统（WSL）进行操作的。</p>
<p>适用于学习Linux系统中文件权限和进程相关内容的读者。</p>
</blockquote>
<span id="more"></span>
<h2 id="权限">权限</h2>
<p>本系列的博客内容其实是建立在WSL上的，主要是仅给个人用户一个Linux环境，顺便来熟悉Linux系统，所以以下不会涉及太过复杂的权限设置，会覆盖基本的操作。</p>
<p>当我们使用ls -l进行查看的时候，会按照长模式的方式显示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文件访问权限 硬链接数目 文件所属用户 文件所属用户组 文件大小 上次修改日期 文件名</span><br></pre></td></tr></table></figure>
<h3 id="文件访问权限">文件访问权限</h3>
<p>文件访问权限是由两部分组成的，一部分是文件类型，一部分是文件模式。</p>
<p>文件类型有：</p>
<ul>
<li>-：普通文件。</li>
<li>d：目录。</li>
<li>l：符号连接，其显示的文件模式都是虚拟值，真正的文件模式是链接指向的文件决定的。</li>
<li>c：字符设备文件，按照字节流处理数据的设备，例如终端机或者调制解调器。</li>
<li>b：块设备文件，按照数据块处理数据的设备，例如硬盘或者CD-ROM。</li>
</ul>
<p>文件模式由文件所有者、文件组所有者和其他人三种用户的三种基本的：可读r、可写w、可执行x（s、t什么的就不涉及了）组成，共9个字符。</p>
<table>
<thead>
<tr class="header">
<th>属性</th>
<th>文件</th>
<th>目录</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>r</td>
<td>允许打开并读写文件内容</td>
<td>允许列出目录内容，前提是目录设置了x属性</td>
</tr>
<tr class="even">
<td>w</td>
<td>允许写入文件内容。重命名或删除是根据目录属性来的</td>
<td>允许在目录下新建、删除或重命名文件，前提也是目录设置了x属性</td>
</tr>
<tr class="odd">
<td>x</td>
<td>允许将文件作为程序来执行，脚本语言编写的程序必须具备</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="更改文件模式">更改文件模式</h3>
<p>我们可以使用chomd来更改文件模式，更改的方式有两种，一种是八进制数字表示法或符号表示法，由于本人倾向于八进制数字表示法，且确实很nice，所以就不介绍符号表示法了。</p>
<p><strong>八进制数字表示法</strong>是因为1个八进制恰好需要3个二进制位来表示，而3个权限刚好对应3个二进制位，那么3种用户就只需要使用3位八进制数来表示即可（缕一缕这句话，其实挺清楚的）。</p>
<p>例如<code>r--</code>就是100，也就是4，<code>rw-</code>就是110，也就是6，以此类推即可。</p>
<p>那么新建并修改foo.txt权限为<code>rwxrw-r--</code>只需要使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; foo.txt</span><br><span class="line">chmod 764 foo.txt</span><br></pre></td></tr></table></figure>
<h3 id="默认权限">默认权限</h3>
<p>当我们新建文件的时候会自动赋予一个默认权限，这里在<strong>WSL</strong>下，默认的是<code>rw-r--r--</code>，这是由<code>umask</code>进行控制的。</p>
<p>命令行使用<code>umask</code>进行查看，会发现响应的数值是0022，常用的Linux系统还有0002，对应着关闭了哪些权限，2指的就是10，也就是原始文件权限是<code>rw-rw-rw-</code>，根据umask的掩码来<strong>关闭</strong>某些权限，作为最终的默认权限。</p>
<p>一般不用修改，使用系统默认的就可以了。</p>
<h3 id="用户和用户组">用户和用户组</h3>
<p>针对具有多个用户和用户组的情况下，不同用户具有不同的文件的控制权。</p>
<ul>
<li><p>su [-[l]] [user]：是允许我们切换到另一个用户的身份，重新启动一个shell进程。</p>
<p>-l 表示切换shell环境，并更改工作目录到该用户下，没有用户名则默认是root，如下切换至root用户：</p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">su -</span><br></pre></td></tr></table></figure></p>
<p>需要输入切换后用户的密码，登录后超级用户root显示的符号从“<code>$</code>”变为“<code>#</code>”，使用exit退出。</p></li>
<li><p>sudo：是允许一个普通用户以另一个用户的身份执行任务，本质上用户并没有切换，而且输入的密码是用户本身的密码，并且密码可以维持一段时间的信任。</p></li>
</ul>
<p>可以使用<code>chown [owner][:[group]] file</code>对文件的用户和用户组进行更改。</p>
<p>使用<code>passwd</code>可以更改密码。</p>
<h2 id="进程">进程</h2>
<h2 id="个人收获">个人收获</h2>
<p>关于文件和目录权限的内容并不过多赘述，之后存在需求之后再进行补充。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>快乐Linux学习（三）</title>
    <url>/2021/01/27/%E5%BF%AB%E4%B9%90Linux%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>本文是快乐学习Linux的第三篇，是基于Windows的Linux子系统（WSL）进行操作的。</p>
<p>适用于学习Linux系统中shell特性和键盘操作的读者。</p>
</blockquote>
<span id="more"></span>
<h2 id="字符展开">字符展开</h2>
<p>每当我们在bash中输入一串命令，bash就会在执行命令之前将命令进行<code>展开</code>操作。</p>
<p>我们可以使用<code>echo</code>来显示一行文本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo This is a test.</span><br></pre></td></tr></table></figure>
<p>那么不出意外将会输出结果<code>This is a test.</code>，当我们输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo *</span><br></pre></td></tr></table></figure>
<p>就会出现意外了:joy:，结果是根据通配符含义的“<code>*</code>”匹配当前文件夹的任何内容，而不是我们想要打印的“<code>*</code>”，这就意味着我们的命令有了自己的想法，想要按照自身的规则先进行展开成完全态，再执行命令。</p>
<h3 id="路径名展开">路径名展开</h3>
<p>以上这样的展开被称为路径名展开，例如打印当前目录所有的以<code>l</code>开头的文件或目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo l*</span><br></pre></td></tr></table></figure>
<p>但是无法显示隐藏文件的展开路径，但是<code>办法总比困难多</code>。我们进行尝试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo .*</span><br></pre></td></tr></table></figure>
<p>几乎成功了，但是存在了不需要的<code>.</code>和<code>..</code>。换个方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -d .[!.]?* | less</span><br></pre></td></tr></table></figure>
<p>仅展示以<code>.</code>开头，第二个符号不是<code>.</code>，并且至少再包含一个符号，之后可以紧跟任意多个字符。</p>
<blockquote>
<p>我们可以发现，对于文件和目录进行打印输出的时候，使用echo和ls的结果似乎差不多，但是细心的话，我们可以发现，ls文件名之间的间距是根据<code>制表符</code>规定的，而echo每两个文件名之间的间距是<code>一个空格</code>，其中原因也是shell的命令展开。</p>
</blockquote>
<h3 id="算数表达式展开">算数表达式展开</h3>
<p>算术表达式是形如<code>$((expression))</code>，表达式中不在意空格，并且可以嵌套存在，需要注意的是除法“<code>/</code>”，由于表达式仅支持<strong>整数操作</strong>，所以除法操作得到的结果是<strong>舍尾的整数</strong>，想要获得余数可以使用“<code>%</code>”进行操作。</p>
<h3 id="花括号展开">花括号展开</h3>
<p>花括号是为了获得多个具有一定重复规律的字符串而出现的，举个例子:bulb:：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo hello-&#123;R,G,B&#125;-world</span><br></pre></td></tr></table></figure>
<p>则结果会生成<code>hello-R-world hello-G-world hello-B-world</code>，或者想要生成2019-01至2021-12的文件夹来存放相应内容，可以使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir &#123;2019..2021&#125;-0&#123;1..9&#125; &#123;2019..2021&#125;-1&#123;0..2&#125;</span><br></pre></td></tr></table></figure>
<p>其中花括号内可以包含字符串列表，整数区间和字符区间，区间使用<code>..</code>来表示区间范围，其中字符区间全部是大写或全部是小写的时候没有任何问题，但是在大写到小写的区间内，由于<code>ASCII</code>码的原因，会存在几个过度的字符，这需要注意一下。</p>
<p>同样的，花括号也可以<code>嵌套</code>。</p>
<h3 id="参数展开">参数展开</h3>
<p>参数展开在此处简要体提及，之后会在shell脚本中详细阐述。</p>
<p>我们查看一下可以使用的有效参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printenv | less</span><br></pre></td></tr></table></figure>
<p>这些参数可以使用 <code>$</code>符号进行调用，来显示参数对应的值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo $USER</span><br></pre></td></tr></table></figure>
<p><strong>命令替换</strong>功能也能将命令的输出作为一个展开模式来使用，例如将找到cp目录的<strong>结果作为展开的参数</strong>给ls进行打印：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -l $(which cp)</span><br></pre></td></tr></table></figure>
<p>同样的，管道线也适用参数展开，在旧版bash中也可以使用<code>ls -l `which cp`</code>达到同样效果。</p>
<h3 id="引用">引用</h3>
<p>这里的引用指的是一种引用机制，用来有选择的禁止不需要的展开。什么叫做不需要的展开，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo This is a     Test</span><br></pre></td></tr></table></figure>
<p>但是结果是<code>This is a Test</code>，中间想要的空格被自动展开后再进行单词分割（空格、制表符、换行符等界定符）而失去了。再比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo The total price is $100.00</span><br></pre></td></tr></table></figure>
<p>但是结果却是<code>The total price is 00.00</code>，原因是<code>$1</code>被视作名为变量1的参数。</p>
<p>为了禁止这些不需要的展开，所以出现了引用机制，这里有两种类型，一种是<strong>双引号</strong>，一种是<strong>单引号</strong>。</p>
<p>使用双引号的时候，shell使用的一些特殊字符将会失去其特殊含义，<u>单词分割，路径名展开，波浪线展开（用户名）和花括号展开</u>都会被禁止。</p>
<p>例如这个存在空格的破损文件名<code>word count.txt</code>，正常情况下ls的时候会认作两个参数，而使用双引号的时候就会关闭单词分割，从而视作一个参数来正确读取，并且可以使用mv进行重命名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -l &quot;word count.txt&quot;</span><br><span class="line">mv &quot;word count.txt&quot; word_count.txt</span><br></pre></td></tr></table></figure>
<p>再比如打印日历：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo $(cal)</span><br></pre></td></tr></table></figure>
<p>这就是被单词分割的后果！可以尝试加上双引号，一下子好看了有木有:laughing:！</p>
<p>但是对于<code>$，\和`</code>并不会被禁止，也就是意味着参数展开，算术展开和命令替换仍然会被执行。</p>
<p>这就需要使用单引号来<strong>禁止全部展开</strong>，通过以下对比进行说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo text ~/.txt &#123;a,b&#125; \$100 $(echo ~) $((2+2)) $USER `which cp`</span><br><span class="line">echo &quot;text ~/.txt &#123;a,b&#125; \$100 $(echo ~) $((2+2)) $USER `which cp`&quot;</span><br><span class="line">echo &#x27;text ~/.txt &#123;a,b&#125; \$100 $(echo ~) $((2+2)) $USER `which cp`&#x27;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于转义字符“<code>\</code>”有一个很有趣的东西，echo加上<code>-e</code>能够解释转义字符，例如，10秒后响铃:alarm_clock:：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sleep 10; echo -e &quot;Time&#x27;s up \a&quot;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="键盘的高级操作">键盘的高级操作</h2>
<p>这里再附带说一下键盘有关的高级操作，<code>命令行的目标是懒惰</code>，各种简短而丰富的命令是为了更少的敲击键盘和无需使用鼠标，来专注于工作本身。</p>
<p>在命令行中存在很多的按键，来快速编辑，例如：</p>
<table>
<thead>
<tr class="header">
<th>按键</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Ctrl-a</td>
<td>光标移动到行首</td>
</tr>
<tr class="even">
<td>Ctrl-e</td>
<td>光标移动到行尾</td>
</tr>
<tr class="odd">
<td>Alt-f</td>
<td>光标向前移动一个字</td>
</tr>
<tr class="even">
<td>Alt-b</td>
<td>光标向后移动一个字</td>
</tr>
<tr class="odd">
<td>Ctrl-l</td>
<td>清空屏幕，与clear相同</td>
</tr>
<tr class="even">
<td>Alt-l</td>
<td>光标至字尾的字符转化为小写字母</td>
</tr>
<tr class="odd">
<td>Alt-u</td>
<td>光标至字尾的字符转化为大写字母</td>
</tr>
</tbody>
</table>
<h3 id="自动补全">自动补全</h3>
<p>自动补全是shell一个很方便的方法，Linux系统不一样可能机制不同，WSL中是只有一个匹配的则敲击<code>一下tab</code>键即可，存在多个匹配条件，则连续敲击<code>两下tab</code>键显示。</p>
<h3 id="历史命令">历史命令</h3>
<p>使用上下键就可以浏览之前输入过的历史命令，不过还可以使用history进行查看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">history | less</span><br></pre></td></tr></table></figure>
<p>在每个历史命令中，每行会有一个序号，我们在命令行直接输入<code>!80</code>就可以直接执行第80行的命令了。</p>
<p>使用<code>Ctrl-r</code>可以进入搜索模式，输入部分命令内容，继续按下<code>Ctrl-r</code>就可以从<strong>现在</strong>到<strong>过去</strong>进行历史命令匹配了。</p>
<h2 id="个人收获">个人收获</h2>
<p>总之，Linux中的shell是一个很有趣的事物，准确的理解其中展开和引用机制可以很好的发挥shell的能力。对于最后提及的键盘快捷键，暂时来说只是锦上添花，更多的还是关注命令本身。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>快乐Linux学习（零）</title>
    <url>/2021/01/22/%E5%BF%AB%E4%B9%90Linux%E5%AD%A6%E4%B9%A0%EF%BC%88%E9%9B%B6%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>本文是快乐学习Linux的第零篇，是基于Windows的Linux子系统（WSL）进行操作的。</p>
<p>学习中途发现很有意思的东西，就分享在开篇了。</p>
</blockquote>
<span id="more"></span>
<h2 id="linux-可以激发我们的想象">Linux 可以激发我们的想象</h2>
<blockquote>
<p>当我被要求解释 Windows 与 Linux 之间的差异时，我经常拿玩具来作比喻。 Windows 就像一个游戏机。你去商店，买了一个包装在盒子里面的全新的游戏 机。你把它带回家，打开盒子，开始玩游戏。精美的画面，动人的声音。玩了一段 时间之后，你厌倦了它自带的游戏，所以你返回商店，又买了另一个游戏机。这个 过程反复重复。最后，你玩腻了游戏机自带的游戏，你回到商店，告诉售货员，“我 想要一个这样的游戏！”但售货员告诉你没有这样的游戏存在，因为它没有“市场 需求”。然后你说，“但是我只需要修改一下这个游戏！“，售货员又告诉你不能修改 它。所有游戏都被封装在它们的存储器中。到头来，你发现你的玩具只局限于别人 为你规定好的游戏。</p>
<p>另一方面，Linux 就像一个全世界上最大的建造模型。你打开它，发现它只是一 个巨大的部件集合。有许多钢支柱、螺钉、螺母、齿轮、滑轮、发动机和一些怎样 来建造它的说明书。然后你开始摆弄它。你建造了一个又一个样板模型。过了一会 儿，你发现你要建造自己的模型。你不必返回商店，因为你已经拥有了你需要的一 切。建造模型以你构想的形状为模板，搭建你想要的模型。 当然，选择哪一个玩具，是你的事情，那么你觉得哪个玩具更令人满意呢？</p>
</blockquote>
<p>Windows是经典模式，Linux是自定义模式。</p>
<h2 id="个人收获">个人收获</h2>
<p>个人喜好而已，“Just enjoy yourself”。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>快乐Linux学习（二）</title>
    <url>/2021/01/22/%E5%BF%AB%E4%B9%90Linux%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>本文是快乐学习Linux的第二篇，是基于Windows的Linux子系统（WSL）进行操作的。</p>
<p>适用于学习Linux系统查看命令帮助和重定向的读者。</p>
</blockquote>
<span id="more"></span>
<h2 id="linux命令形式">Linux命令形式</h2>
<p>Linux中，命令存在4种形式：</p>
<ul>
<li>type command：使用<code>type</code>命令能够显示命令的类别。</li>
</ul>
<h3 id="可执行程序">可执行程序</h3>
<p>可执行程序位于<code>/usr/bin</code>目录中，是利用编程语言编写程序编译的二进制文件，包括C/C++</p>
<p>、shell和python等编写的脚本。</p>
<ul>
<li>which command：显示<code>可执行程序</code>的位置。普通桌面系统可执行程序一般只有一个版本，但是在大型服务器中可能存在多个可执行程序版本，由此来确定准确位置</li>
<li>command --help：许多可执行文件能够显示其语法和选项说明文档。某些程序可能不支持，但是不妨碍我们尝试一下。</li>
<li>man program：在命令行运行的可执行程序往往会提供一个正式文档，使用man分页程序可以进行查看。man是使用less工具来显示的，所以可以使用less命令进行查看。</li>
<li>apropos program：基于关键字匹配参考手册。是一种粗糙的查询手段，可以获得查询字段的手册页名字和其所在章节。等同于<code>man -k program</code>。</li>
<li>info command：替代man命令程序手册页，类似于网页，链接可跳转。</li>
</ul>
<h3 id="builtins">builtins</h3>
<p>这是shell内部命令，内建于shell自身，例如cd。</p>
<ul>
<li>help command：查看builtins命令的帮助文档</li>
</ul>
<h3 id="shell函数">shell函数</h3>
<p>编写小规模的shell脚本，混合到环境变量中，会在之后详细讨论其编写、配置和使用。</p>
<h3 id="alias别名">alias别名</h3>
<p>自定义自己的命令，建立在其他命令之上。</p>
<p>运行命令的时候可以使用<code>；</code>进行隔开，使得命令可以依次执行。例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr; ls; cd -</span><br></pre></td></tr></table></figure>
<p>之后使用alias进行重命名。首先需要查看该命令的名字是否被占用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type test # 发现已经被占用</span><br><span class="line">type foo # 发现还没有使用</span><br><span class="line">alias # 查看所有创建的alias</span><br></pre></td></tr></table></figure>
<p>利用其创建alias别名，命令字符串需要紧跟<code>=</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alias foo=&#x27;cd /usr; ls; cd -&#x27;</span><br></pre></td></tr></table></figure>
<p>删除别名使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unalias foo</span><br></pre></td></tr></table></figure>
<h2 id="io-重定向">I/O 重定向</h2>
<p>I/O重定向（I/O代表输入/输出）是一个Linux很有意思的一个特性，可以对Linux的输入和输出进行重定向，来获得想要的结果。</p>
<h3 id="标准输入标准输出和错误">标准输入、标准输出和错误</h3>
<p>我们可以发现，在很多命令执行之后会出现一些输出内容，这些内容往往分为两类，一类是程序运行的结果，另一类是程序运行的状态和错误等信息。</p>
<p>与之前提到过的<code>Linux崇尚一切皆文件</code>同理，这些运行的结果就是将输出的结果传送到一个叫做标准输出（stdout）的文件中，然后再输出出来；而状态和错误信息则被传送标准错误（stderr）文件中；默认情况下，标准输入/输出都连接着屏幕，而不需要保存到文件中。至于标准输入（stdin）则是连接键盘，从中得到输入。</p>
<p>而！此处要提到的I/O重定向，可以允许我们<code>更改输出地点和输入来源</code>。仔细想想，会发现其中有很多的操作空间。</p>
<h3 id="标准输出重定向">标准输出重定向</h3>
<p>很简单是使用“<code>&gt;</code>”符号就可以进行标准输出的重定向了。例如直接将ls的内容存储到一个<strong>ls-output.txt</strong>文件中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -l /usr/bin &gt; ls-output.txt</span><br></pre></td></tr></table></figure>
<p>可以发现在当前目录新建了一个<strong>ls-output.txt</strong>文件，可以使用less查看其中的信息。</p>
<p>但是当我们ls一个不存在的目录，就会出现报错的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -l /user/bin &gt; ls-output.txt</span><br></pre></td></tr></table></figure>
<p>此时我们<code>ls -l ls-output.txt</code>，我们很惊喜的发现，该文件是一个<code>0</code>字节的文件，说明了两点事情：第一，标准输出的重定向会在每重定向的时候<strong>覆盖</strong>原本的文件；第二，我们的错误信息并没有重定向到<strong>ls-output.txt</strong>文件中。</p>
<p>对于覆盖问题，若我们想要在文件最后<strong>继续增加</strong>标准输入，而不是直接覆盖文件，则可以使用“<code>&gt;&gt;</code>”符号进行追加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -l /usr/bin &gt;&gt; ls-output.txt</span><br><span class="line">ls -l /usr/bin &gt;&gt; ls-output.txt</span><br></pre></td></tr></table></figure>
<p>重复执行两次之后，我们就会发现，该文件大小扩大了一倍，确实是对内容进行了追加。</p>
<p>同样的，若我们需要<strong>清空</strong>一个文件，则可以简单的使用如下命令即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; ls-output.txt</span><br></pre></td></tr></table></figure>
<h3 id="标准错误重定向">标准错误重定向</h3>
<p>之前提示输入错误的信息，是因为我们此处仅使用了“<code>&gt;</code>”符号重定向了标准输出，而未重定向标准错误。</p>
<p>但是遗憾的是在Linux中没有特定的符号来重定向标准错误，于是需要借用Linux内定义的<strong>文件描述符</strong>，每个文件描述符对应一个标准流，前三个文件描述符0、1、2分别对应标准输入、输入和错误。</p>
<p>所以重定向标准错误的时候只需要使用“<code>2&gt;</code>”即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -l /user/bin 2&gt; ls-error.txt</span><br></pre></td></tr></table></figure>
<p>有的时候，我们想要将错误进行隐藏，我们就可以将其重定向到<code>/dev/null</code>中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -l /user/bin 2&gt; /dev/bin</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用<code>ls -l /dev/null</code>的时候可以发现null的文件属性是<code>c</code>，指的是串行端口设备。</p>
<p>// todo：解释串行端口设备和其他文件属性类型。</p>
</blockquote>
<p>当我们想要将标准输入和错误<strong>联合输入</strong>在同一个文件中，我们有两种方法，一个是旧版的shell中，在标准输出<strong>之后，再</strong>重定向标准错误（文件描述符2）到标准输出（文件描述符1），注意顺序，否则不起作用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -l /bin/usr &gt; ls-output.txt 2&gt;&amp;1</span><br></pre></td></tr></table></figure>
<p>除此以外，现在的bash还提供了新的方法，使用“<code>&amp;&gt;</code>”符号来联合定义输出和错误重定向。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -l /user/bin &amp;&gt; ls-output.txt</span><br></pre></td></tr></table></figure>
<h3 id="标准输入重定向">标准输入重定向</h3>
<p>在标准输入的重定向之前先提一下需要使用标准输入的地方。</p>
<ul>
<li><p>cat [file]：读取一个或多个文件，将其复制到标准输出，直接显示而没有分页，一般用来显示简短的文本。</p>
<p>但是由于其可以读取多个文件的特性，所以就可以利用其来合并文件：</p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat page*.txt &gt; page.txt</span><br></pre></td></tr></table></figure></p>
<p>同时！我们需要注意到。这里的file是使用<code>[]</code>括起来的，表示可以不读取file文件，那么无输入的时候会读取什么文件就值得去发现了。当我们仅输入<code>cat</code>后，直接回车！</p>
<p>结果什么都没有发生:sweat:，仅有一个闪烁的光标。实际上此时cat是在<strong>等待标准输入</strong>，并从中来读取数据，尝试键入一些内容，发现就算按下回车也不会结束输入，此时就需要使用<code>Ctrl和d</code>来终止输入。</p>
<p>为了验证，我们将标准输入再重定向出入到文件中：</p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat &gt; cat-context.txt</span><br><span class="line">This is an interesting context.</span><br></pre></td></tr></table></figure></p>
<p>最后使用<code>Ctrl和d</code>来终止输入，并<code>cat cat-context.txt</code>来查看这简短的文本，发现的确将内容输入到了文件中。</p></li>
</ul>
<p>最后我们使用“<code>&lt;</code>”符号就可以进行标准输入重定向：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat &lt; cat-context.txt</span><br></pre></td></tr></table></figure>
<p>发现结果与直接<code>cat cat-context.txt</code>并无差异，但是这里说明了标准输入重定向是可以将标准输入从键盘更改为文件的，更多应用之后再进行讨论。</p>
<h3 id="管道线">管道线</h3>
<p>管道线具有将命令从一个标准输入读取数据并输送到标准输入的能力。操作符是“<code>|</code>”</p>
<p>例如标准输出ls和接受标准输入的less：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -l /usr/bin | less</span><br></pre></td></tr></table></figure>
<p>这里我们就可以直接将标准输出内容利用接受标准输入的less显示。</p>
<p>管道线一般是用来对内容进行复杂操作的，可以在管道中增加一些复杂操作，比如增加<strong>过滤器</strong>，使用<code>sort</code>对标准输出内容进行一个有序排列，再使用less输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls /bin /usr/bin | sort | less</span><br></pre></td></tr></table></figure>
<p>想要<strong>过滤重复字段</strong>，则可以使用<code>uniq</code>来忽略重复行，想看到重复行的话就使用<code>uniq -d</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls /bin /usr/bin | sort | uniq | less</span><br></pre></td></tr></table></figure>
<p>想统计内容的行数、字数和字节数，则可以使用<code>wc</code>，增加<code>-l</code>选项则只显示行数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls /bin /usr/bin | sort | uniq | wc -l</span><br></pre></td></tr></table></figure>
<p>还有一个强大的匹配方法<code>grep</code>，支持正则表达式进行复杂匹配，并且增加了一些选项，<code>-i</code>忽略大小写，<code>-v</code>只显示不匹配的行，例如搜索包含zip字段的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls /bin /usr/bin | sort | uniq | grep zip</span><br></pre></td></tr></table></figure>
<p>当输入输出内容太多，而只需要查看前几行或后几行内容的时候，就可以使用head/tail来打印，可以直接使用，也可以在管道线中使用，使用<code>-n</code>来指定显示的行数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">head -n 5 ls-output.txt</span><br><span class="line">ls /usr/bin | tail -n 8</span><br></pre></td></tr></table></figure>
<blockquote>
<p>另外提到 tail有一个选项“<code>-f</code>”可以实时浏览文件，来观察日志的变化，例如<code>/var/log/messages</code>，当读取的文件修改之后，相应内容会立即显示在屏幕上。直到按下<code>Ctri+C</code>。但是WSL中似乎没有该文件，此处就不进行实验了。</p>
</blockquote>
<p>最后再提及一个<code>tee</code>命令，这是从标准输入中读取内容，并输出到标准输出中，在管道线中可以作为中间段来<strong>捕捉在管道线中流动的内容</strong>，例如在过滤关键字之前先保存完成的内容到ls.txt中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls /usr/bin | tee ls.txt | grep zip</span><br></pre></td></tr></table></figure>
<h2 id="个人收获">个人收获</h2>
<p>通过这次学习，了解了Linux中命令的区别，之前一直都以为命令都是系统内置的，现在想想一些通过安装的内容确实不是系统内置的，例如之前自己安装的<code>tree</code>命令，就属于可执行命令。最主要学到的是I/O重定向，这是一个很有趣的内容，可以来觉得自己的标准输入/输出，并且有一个管道可以进行复杂的操作，加上各种有趣的命令，完全就是一个自由度极高的DIY玩具呀！让我们继续快乐学习~</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>快乐Linux学习（一）</title>
    <url>/2021/01/19/%E5%BF%AB%E4%B9%90Linux%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>本文是快乐学习Linux的第一篇，是基于Windows的Linux子系统（WSL）进行操作的。</p>
<p>适用于学习Linux系统基础命令和文件系统的读者。</p>
</blockquote>
<span id="more"></span>
<p>Windows下Linux子系统是一个Linux玩家可能看不起的东西，但是作为我们这些新手接触Linux系统的第一步还是一个不错的选择，至于安装等内容在此不再赘述，Google上也有很多教程，之后有机会的话再补上。</p>
<h2 id="文件系统简介">文件系统简介</h2>
<p>首先，让我们来理解一下Linux系统的文件系统。Linux系统是以分层目录来组织所有文件的，组织形式类似于一棵树，目录树的分支是文件或文件目录，其中树根<code>/</code>也被称为根目录，所有的目录和文件都连接在该目录下。Windows的存储设备是相互独立的，具有各自的文件系统，而Linux则全部<code>挂载</code>在目录树上。</p>
<blockquote>
<p>很容易发现在WSL上，Windows下的各个磁盘都被挂载在目录<code>/mnt</code>下。</p>
<p>但是我们在Windows系统中又可以找到WSL的存储目录，<code>C:\Users\username\AppData\Local\Packages\一个关于Ubuntu的文件夹\LocalState\rootfs\mnt\c</code>就是WSL在mnt目录下挂载的C盘，打开发现其中是空的；而且从WSL中按以上路径寻找，发现没有权限进入<code>rootfs</code>文件夹，说明这并不是一个无限套娃的故事，这一点还是比较有趣的。</p>
</blockquote>
<ul>
<li>pwd：显示当前所在目录。</li>
<li>cd：更改当前目录，可以通过绝对路径（从<code>/</code>开始）或相对路径（当前目录开始）进行跳转。
<ul>
<li><code>cd</code> 或<code>cd ~</code>快速到达home目录；<code>cd -</code>快速到达之前所在的目录。</li>
</ul></li>
</ul>
<p>每个目录中都包含父目录和当前目录内容（包括根目录，根目录的父目录还是是根目录，因缺思厅），使用<code>..</code>表示父目录，使用<code>.</code>或省略表示当前目录。</p>
<ul>
<li>ls：罗列处出一个目录包含的文件及其子目录。是一个十分:smiley:的命令，也是初学者最喜欢使用的命令。</li>
</ul>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-l</td>
<td>以长模式的形式，显示出目录信息</td>
</tr>
<tr class="even">
<td>-a</td>
<td>列出所有的文件和目录，包括文件名以<code>.</code>开头的隐藏文件</td>
</tr>
<tr class="odd">
<td>-h</td>
<td>按照human的习惯显示文件大小，可以与l搭配使用</td>
</tr>
<tr class="even">
<td>-r</td>
<td>反序排列显示</td>
</tr>
<tr class="odd">
<td>-t</td>
<td>修改事件排序</td>
</tr>
<tr class="even">
<td>-i</td>
<td>显示文件索引节点信息</td>
</tr>
<tr class="odd">
<td>-d</td>
<td>仅显示目录，而不显示其下文件</td>
</tr>
</tbody>
</table>
<blockquote>
<p>命令行的命令一般是由命令+选项+参数组成，形如：<code>command -options arguments</code>。</p>
<p>表格中的选项一般是上面最近命令的常用搭配，之后不再说明。</p>
</blockquote>
<p>长模式的显示的内容是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文件访问权限 硬链接数目 文件所属用户 文件所属用户组 文件大小 上次修改日期 文件名</span><br></pre></td></tr></table></figure>
<ul>
<li>file filename：显示文件描述</li>
</ul>
<blockquote>
<p>Linux中对于文件的内容，并不是按照文件的后缀名决定的，<code>Linux崇尚一切皆文件</code>。其中，文本文件是只包含简单字符到数字的映射。</p>
</blockquote>
<ul>
<li><p>less filename：快速查看文本文件内容。</p>
<p>此处初学者less之后先不要乱动！不然Windows会一直出现duang！duang！duang！的声音。进去之后先按下<code>h</code>可以查看less操作的帮助文档，可以很有趣的发现很多方法，例如向下滚动，可以使用 <code>e  ^E  j  ^N  CR</code>等按键，默认向下一行，但是可以先输入数字N，来指定向下N行，也可以使用其他按键翻页等不赘述；输入<code>/</code>+正则表达式可以进行搜索匹配内容字符。其他感兴趣的内容可以自行使用help文档查看。</p>
<blockquote>
<p>由于<code>j k</code>紧邻，本人暂时将其作为滚动页面的按键。</p>
<p>所谓的less，其实比more命令功能更多，more只能向下翻页，而less能前后翻页。所谓<strong>色即是空</strong>，果然是有趣的Linux。</p>
</blockquote></li>
</ul>
<h2 id="根目录文件夹">根目录文件夹</h2>
<p>下面罗列出一些根目录下的目录作用，可以自行查看，主要工作和编辑的地方就是home和usr目录下。</p>
<table>
<thead>
<tr class="header">
<th>目录</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>/</td>
<td>根目录</td>
</tr>
<tr class="even">
<td>bin</td>
<td>系统启动和运行必须的二进制程序</td>
</tr>
<tr class="odd">
<td>boot</td>
<td>Linux内核、初始RAM磁盘映像、启动加载程序</td>
</tr>
<tr class="even">
<td>dev</td>
<td>包含设备节点，维护所有设备的列表</td>
</tr>
<tr class="odd">
<td>etc</td>
<td>所有系统层面的配置文件，以及一系列shell脚本（此处的任何文件都应可读）</td>
</tr>
<tr class="even">
<td><code>home</code></td>
<td>在其中有每个用户的目录，普通用户仅在自己目录下写文件</td>
</tr>
<tr class="odd">
<td>lib</td>
<td>核心系统程序使用的共享库文件</td>
</tr>
<tr class="even">
<td>media</td>
<td>现在Linux系统中，可移动介质的挂载点，包括USB驱动器等</td>
</tr>
<tr class="odd">
<td>mnt</td>
<td>早些Linux系统中，可移动介质的挂载点</td>
</tr>
<tr class="even">
<td>opt</td>
<td>安装“可选的”软件</td>
</tr>
<tr class="odd">
<td>proc</td>
<td>Linux内核维护的虚拟文件系统，用来监管计算机</td>
</tr>
<tr class="even">
<td>root</td>
<td>root账户的home目录</td>
</tr>
<tr class="odd">
<td>sbin</td>
<td>系统的二进制文件，完成重大系统任务程序，为超级用户保留</td>
</tr>
<tr class="even">
<td>tmp</td>
<td>存储各种程序创建的临时文件，系统重启会清空该目录</td>
</tr>
<tr class="odd">
<td><code>usr</code></td>
<td>包含普通用户所需的所有程序和文件，很多内容和Windows下的用户目录类似</td>
</tr>
<tr class="even">
<td>var</td>
<td>存放动态文件，例如数据库等。除了tmp和home目录以外，其他目录都是静态的</td>
</tr>
</tbody>
</table>
<h2 id="文件和目录操作">文件和目录操作</h2>
<h3 id="通配符">通配符</h3>
<p>首先介绍一下能够快速指定一组类似文件名的方法——通配符。所有接受文件名作为参数的命令都可以使用通配符进行匹配。</p>
<table>
<thead>
<tr class="header">
<th>通配符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>*</td>
<td>匹配任意多个字符</td>
</tr>
<tr class="even">
<td>？</td>
<td>匹配任意一个字符</td>
</tr>
<tr class="odd">
<td>[characters]</td>
<td>匹配任意一个属于字符集中的字符</td>
</tr>
<tr class="even">
<td>[!characters]</td>
<td>匹配任意一个不属于字符集中的字符</td>
</tr>
<tr class="odd">
<td>[[:class:]]</td>
<td>匹配任意一个属于指定字符类[:class:]中的字符</td>
</tr>
</tbody>
</table>
<p>其中常用的字符类有：[:alnum:]——任意一个字母或数字；[:alpha:]——任意一个字母；[:digit:]——任意一个数字；[:lower:]——匹配任意一个小写字母；[:upper:]——匹配任意一个大写字母。</p>
<h3 id="基本文件操作">基本文件操作</h3>
<ul>
<li><p>mkdir directory...：创建目录</p></li>
<li><p>cp item1 item2：复制文件或目录“item1”到文件或目录"item2"</p></li>
<li><p>cp item... directory：复制多个文件或目录到一个目录下</p>
<blockquote>
<p>可以很有趣的发现，该命令可以自动识别文件或目录，一定程度上页也说明了Linux中一切皆文件的概念。</p>
</blockquote>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-i</td>
<td>复制文件的时候，若文件已经存在，则在被重写之前提示用户确认信息，输入y覆盖，其他字符都保留原文件</td>
</tr>
<tr class="even">
<td>-r</td>
<td>递归复制目录及目录内容，复制目录的时候需要添加。</td>
</tr>
</tbody>
</table></li>
<li><p>mv item1 item2：移动文件，完成操作后原文件不存在，方法和<code>cp</code>类似。当其在相同目录下操作的时候，文件<code>被自身覆盖</code>，且换了一个名字，相当于<code>重命名</code>一个相同的文件。</p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-i</td>
<td>移动文件到新的目录中，若文件存在则提示是否覆盖的信息</td>
</tr>
<tr class="even">
<td>-u</td>
<td>仅移动新目录下不存在的文件</td>
</tr>
</tbody>
</table></li>
<li><p>rm item...：删除文件和目录</p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-i</td>
<td>删除之前提示用户确认信息</td>
</tr>
<tr class="even">
<td>-r</td>
<td>递归删除文件，需要删除目录的时候必须指定</td>
</tr>
<tr class="odd">
<td>-f</td>
<td>即使文件不存在也继续执行，不提示错误信息</td>
</tr>
</tbody>
</table>
<blockquote>
<p>需要注意的是，使用通配符进行删除的时候，需要再三小心，因为Linux删除之后不会进入回收站，所以，最好在删除之前使用ls来查看一下匹配到的项目是否是自己想要删除的。</p>
</blockquote></li>
</ul>
<h2 id="创建链接">创建链接</h2>
<h3 id="硬链接">硬链接</h3>
<ul>
<li>ln file link</li>
</ul>
<p>在Linux中，每个文件都默认会有一个硬链接，而每创建一个硬链接，就相当于创建了一个额外的目录项。硬链接存在两个局限性：一个是不能与链接本身不在同一个磁盘分区的文件；二是不能关联目录。</p>
<p>我们可以假设文件是由两部分组成的：包含文件内容的<code>数据部分</code>和持有文件名的<code>名字部分</code>，那么我们的硬链接就是为实际的文件本身创建额外的名字，并且这些名字都能关联到相同的数据部分。</p>
<p>硬链接就相当于是文件本身，和文件本身没有很大的区别，当硬链接被删除的时候，对文件本身没有影响。</p>
<h3 id="符号链接">符号链接</h3>
<ul>
<li>ln -s item link</li>
</ul>
<p>符号链接是为了克服硬链接的局限性，创建一个特殊类型的文件，该文件包含一个指向文件或目录的文本指针，类似于Windows的快捷方式。</p>
<p>当向符号链接写入内容，那么其指向的文件<code>也会被写入</code>；而当删除符号链接时，仅链接被删除，若文件本身先被删除，那么链接依旧存在，但是指向内容为空，被称为坏链接。</p>
<h2 id="练习场">练习场</h2>
<p>创建一个文件夹来进行以上部分内容的练习。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 切换到home目录下进行实验</span><br><span class="line">cd</span><br><span class="line">mkdir playground</span><br><span class="line">cd playground</span><br><span class="line">mkdir dir1 dir2</span><br></pre></td></tr></table></figure>
<p>简单的复制和移动文件操作，当复制到当前文件夹下，则可以使用“点”来表示当前文件夹；mv文件到同目录下就相当于重命名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp /etc/passwd .</span><br><span class="line">cp -i /etc/passwd .</span><br><span class="line">mv passwd fun # 重命名</span><br><span class="line">mv fun dir1</span><br><span class="line">mv dir1/fun .</span><br></pre></td></tr></table></figure>
<p>创建硬链接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln fun fun-hard</span><br><span class="line">ln fun dir1/fun-hard</span><br><span class="line">ln fun dir2/fun-hard</span><br></pre></td></tr></table></figure>
<p>使用<code>ls -li</code>进行查看的时候，可以发现其中fun和fun-hard的第3个字段是“4”，表示硬链接的数目，可以发现每个文件或目录<code>至少一个</code>硬链接，因为文件名本身就是由硬链接创建的。</p>
<blockquote>
<p>第1个字段是文件内容的索引节点，可以发现硬链接和文件本身都是同一个索引节点，证明是同一个文件。</p>
</blockquote>
<p>创建符号链接，需要按照创建符号链接所在文件或目录的位置来计算链接对象的相对位置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln -s fun fun-sym</span><br><span class="line">ln -s ../fun dir1/fun-sym</span><br><span class="line">ln -s ../fun dir2/fun-sym</span><br><span class="line">ln -s dir1 dir1-sym</span><br></pre></td></tr></table></figure>
<p>使用ls进行观察的时候，很容易发现符号链接文件会有一个指针指向目标文件。在文件大小字段可以发现，符号链接并不显示指向文件的大小，而是指向链接相对路径名称的<code>路径字符数</code>。</p>
<p>此时可以利用tree来看一下目录的全部结构，使用<code>sudo apt install tree</code>进行安装，复制过来没有颜色显示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── dir1</span><br><span class="line">│   ├── fun-hard</span><br><span class="line">│   └── fun-sym -&gt; ../fun</span><br><span class="line">├── dir1-sym -&gt; dir1</span><br><span class="line">├── dir2</span><br><span class="line">│   ├── fun-hard</span><br><span class="line">│   └── fun-sym -&gt; ../fun</span><br><span class="line">├── fun</span><br><span class="line">├── fun-hard</span><br><span class="line">└── fun-sym -&gt; fun</span><br></pre></td></tr></table></figure>
<p>之后尝试删除实验。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm fun-hard</span><br></pre></td></tr></table></figure>
<p>可以发现文件fun的链接数从4变为3，其他硬链接文件不受影响，再删除原文件fun。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm fun</span><br></pre></td></tr></table></figure>
<p>可以发现，硬链接的文件只是链接数从3变成2，其他不受影响，但是可以发现符号链接变成了<strong>红色</strong>，其指向的文件不存在，无法打开。</p>
<blockquote>
<p>大多数文件操作是针对链接的对象，而不是链接本身；而rm是特例，删除链接的时候是删除链接本身，而不是链接的对象。</p>
</blockquote>
<h2 id="个人收获">个人收获</h2>
<p>初步认识了Linux中的基础内容，最主要的是能够熟练查看Linux的一些文件和目录内容，并且会基础的文件操作。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql导出表结构与数据</title>
    <url>/2021/01/18/mysql%E5%AF%BC%E5%87%BA%E8%A1%A8%E7%BB%93%E6%9E%84%E4%B8%8E%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<blockquote>
<p>本文是关于如何将MySQL数据库中某数据库的数据表结构以及表数据导出为<code>.sql</code>文件，以及如何执行<code>.sql</code>文件。</p>
<p>适用于需要简单数据库迁移的读者。</p>
</blockquote>
<span id="more"></span>
<h2 id="导出数据表">导出数据表</h2>
<p>MySQL导出表结构主要是使用<code>mysqldump</code>命令。该命令是在<code>cmd</code>下执行的，而非MySQL命令行中，使用相对路径，会将文件保存在当前目录下。</p>
<ol type="1">
<li><p>导出数据库<code>dbname</code>中全部表结构至<code>db.sql</code>中：</p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p -d dbname &gt;db.sql</span><br></pre></td></tr></table></figure></p></li>
<li><p>导出数据库<code>dbname</code>中某张表<code>tablename</code>结构至<code>db.sql</code>中：</p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p -d dbname tablename &gt;db.sql</span><br></pre></td></tr></table></figure></p></li>
<li><p>导出数据库<code>dbname</code>中全部表结构及其数据至<code>db.sql</code>中（不加-d）：</p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p dbname &gt;db.sql</span><br></pre></td></tr></table></figure></p></li>
<li><p>导出数据库<code>dbname</code>中某张表<code>tablename</code>结构及其数据至<code>db.sql</code>中：</p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p dbname tablename &gt;db.sql</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h2 id="导入数据表">导入数据表</h2>
<p>当我们拥有一个sql文件的时候，我们就可以直接执行sql脚本来完成任务。</p>
<ol type="1">
<li><p>在cmd下执行命令：需要选择MySQL的sever下的目录，如果目录存在空格，则需要使用双引号，若sql文件中存在<code>use 数据库</code>则不需要指定<code>-D数据库</code></p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;C:\Program Files\MySQL\MySQL Server 8.0\bin\mysql&quot; –uroot –p -D dbname &lt; C:\Users\username\Desktop\db.sql</span><br></pre></td></tr></table></figure></p></li>
<li><p>在MySQL命令行中执行命令：sql文件需要是绝对路径</p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source C:\Users\username\Desktop\db.sql</span><br><span class="line">-- 或者推荐下面这个</span><br><span class="line">\. C:\Users\username\Desktop\db.sql</span><br></pre></td></tr></table></figure></p></li>
</ol>
<p>在导入数据库的时候，有可能会出现错误<code>MySQL server has gone away</code>。原因一般是操作sql的时间太长，或者插入数据库的数据量太大，一般来说，可以将数据分批插入，或者修改<code>max_allowed_packet</code>参数的配置。</p>
<p>首先查看max_allowed_packet的值，使用<code>show global variables like 'max_allowed_packet'</code>查看对应的值，之后输入语句进行调整，由于<code>db.sql</code>文件太大，本人这里设置为100M：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> max_allowed_packet<span class="operator">=</span><span class="number">1024</span><span class="operator">*</span><span class="number">1024</span><span class="operator">*</span><span class="number">100</span></span><br></pre></td></tr></table></figure>
<p>接下来再读取sql文件导入数据库的时候问题就不大了</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习小结</title>
    <url>/2021/01/14/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>本文是关于机器学习的一些总结式内容，<strong>暂时</strong>不包含神经网络和深度学习内容；</p>
<p>适用于机器学习相关面试突袭！！！</p>
</blockquote>
<span id="more"></span>
<h2 id="分类">分类</h2>
<h3 id="svm的简要介绍">SVM的简要介绍</h3>
<p>SVM（ support vector machine，支持向量机）是一个面向数据的分类算法，基本模型就是在空间上找到一个<code>超平面</code>来将不同类别的数据划分出来，学习的策略是根据支持向量使得超平面的<code>间隔最大化</code>，最终转化为一个凸优化规划的求解问题。</p>
<h3 id="lr">LR</h3>
<p>LR（Logistic Regression，逻辑回归），逻辑回归虽然被称为是回归，但本质上还是一个二分类模型，名字的逻辑来源于logistic（逻辑斯蒂）分布， <span class="math display">\[
logit(x) = ln(\frac{P(y=1|x)}{P(y=0|x)}) = ln(\frac{P(y=1|x)}{1-P(y=1|x)}) = wx，其中w=\theta_1,\theta_2,\dots,\theta_n
\]</span> 获得概率函数 <span class="math display">\[
P(y=1|x) = \frac{1}{1+e^{-wx}}
\]</span> 逻辑回归求解的话，一般是采用梯度下降算法进行求解，主要方法就是先对目标损失函数<span class="math inline">\(J(w)\)</span>计算梯度（也就是求导），设计一个学习率（步长），向梯度的（负）方向更新回归系数，令损失函数不断减小，直至低于设置的临界门限，此时获得的回归系数就是最终使得损失函数最小的极小值点。</p>
<p>逻辑回归中遇到有很多参数的时候，容易遇到过拟合的问题，此时采用正则化的方式，在经验风险上增加一个正则化项来惩罚过大的参数。</p>
<h3 id="正则化">正则化</h3>
<p>正则化是针对过拟合提出来的，正则化项是模型参数向量的范数，一定程度上也能表现出模型复杂度。一般模型求解是优化最小的经验风险，通过加上正则化项和权重，来控制结构经验风险最优，防止模型结构过于复杂，降低过拟合风险。</p>
<ul>
<li><span class="math inline">\(L_1\)</span>正则化项（lasso回归），参数稀疏，<strong>自动完成特征选择</strong>，去除影响很小的特征；</li>
<li><span class="math inline">\(L_2\)</span>正则化项（岭回归），能够解决过拟合问题。</li>
</ul>
<blockquote>
<p>奥卡姆剃刀：所有的模型中，能够用最简单的方法来解释已知数据的模型是最好的。</p>
</blockquote>
<h3 id="逻辑回归与线性回归">逻辑回归与线性回归</h3>
<p>逻辑回归和线性回归本质上都是广义的线性回归。</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>线性回归</th>
<th>逻辑回归</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>目标函数</td>
<td>最小二乘</td>
<td>似然函数</td>
</tr>
<tr class="even">
<td>敏感度</td>
<td>整个实数域内预测，敏感度一致</td>
<td>Sigmoid函数减小预测范围，提高局部敏感度</td>
</tr>
</tbody>
</table>
<p>逻辑回归本质上在线性回归上增加了一层sigmoid函数，但是这一层函数却改变了预测的敏感度。线性回归在整个数据域中，对数据的敏感度是一致的，在分类的边界往往模糊不清，而sigmoid函数使得逻辑回归的值在<span class="math inline">\([0,1]\)</span>之间，数据在x=0的附近是是十分敏感的，而在远大于或远小于0的部分是非常不敏感的，也就使得在边界的分类更加的准确。</p>
<h3 id="逻辑回归与svm">逻辑回归与SVM</h3>
<p>逻辑回归和SVM都可以处理分类问题，一般用于二分类问题。</p>
<p>区别：</p>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 46%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th style="text-align: left;">LR</th>
<th style="text-align: left;">SVM</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>模型</td>
<td style="text-align: left;">参数模型</td>
<td style="text-align: left;">非参数模型</td>
</tr>
<tr class="even">
<td>损失函数</td>
<td style="text-align: left;">Logistical Loss</td>
<td style="text-align: left;">hinge loss，最小化经验分类错误</td>
</tr>
<tr class="odd">
<td>数据量</td>
<td style="text-align: left;">通过非线性映射，减少离分类面较远的属性权重，增加与分类相关的属性权重</td>
<td style="text-align: left;">仅考虑少数的几个支持向量进行学习，SVM转化为对偶问题之后，仅需要计算少数几个支持向量的距离，在进行复杂的核函数计算时有很大的优势</td>
</tr>
<tr class="even">
<td></td>
<td style="text-align: left;">LR能做的SVM都能</td>
<td style="text-align: left;">准确率上SVM能做的LR不一定能</td>
</tr>
</tbody>
</table>
<h3 id="k-means和knn为何使用欧式距离而不是曼哈顿距离计算">K-means和KNN为何使用欧式距离而不是曼哈顿距离计算</h3>
<p>欧式距离：<span class="math inline">\(d(X,Y) = \sqrt{(x_1-y_1)^2+(x_2-y_2)^2+\dots+(x_n-y_n)^2}=\sqrt{\sum^n_{i=1}(x_i-y_i)^2}\)</span>，欧式距离将不同的属性的量纲视作等同，不适用于对个体具有不同重要性的指标。因此，欧式距离使用之前需要各属性都<strong>标准统一</strong>。</p>
<p>曼哈顿距离：<span class="math inline">\(d(X,Y) = |x_i-x_2|+|y_1-y_2|\)</span>（L1），曼哈顿距离表示的是两线线段对轴产生投影的总和，仅计算垂直或水平距离，依赖坐标系的转度，有维度的限制。</p>
<p>数据点存在于任何空间，欧式距离将会是更可靠的选择。</p>
<h3 id="简单描述特征工程">简单描述特征工程</h3>
<h3 id="过拟合">过拟合</h3>
<ul>
<li>数据上，数据量太少，统计特征使用未来标签</li>
<li>算法上：算法过于复杂</li>
<li>解决方法：1. 数据规范化，增加数据量；2. 利用正则化降低模型复杂度；3. 减少迭代次数；4. 调整学习率；5. 模型融合。</li>
</ul>
<h3 id="朴素贝叶斯">朴素贝叶斯</h3>
<p>所谓朴素，就是假设数据集中所有特征的作用同等重要并相互独立，但是这个假设在这个给世界上很少存在，所以认为他很朴素。</p>
<ul>
<li>条件概率：后验概率<span class="math inline">\(P(B|A)\)</span></li>
<li>边缘概率：先验概率<span class="math inline">\(P(A\)</span></li>
</ul>
<p>那么贝叶斯定理为<span class="math inline">\(P(A|B) = \frac{P(B|A)P(A)}{P(B)}\)</span></p>
<h3 id="为什么要进行归一化">为什么要进行归一化</h3>
<p>概率模型不需要归一化，因为概率模型只关心变量的分布和变量之间的条件概率，例如决策树和RF等模型，而Adaboost、GBDT、XGBoost、SVM、LR、KNN、KMeans之类的最优化问题需要进行归一化</p>
<p>就二维特征而言，当两个数据特征的区间范围相差较大，那么数据特征形成的等高线就会比较窄，使用梯度下降算法进行求解的时候往往会出现“之”字形的下降路线，迭代次数多，时间长。而进行归一化之后，数据特征的取值区间相似，等高线会形成一个较为平滑的圆形，梯度下降的时候能够较快收敛。所以使用梯度下降算法的时候往往就很有归一化的必要。</p>
<p>同时需要计算样本距离的时候，例如KNN中使用欧式距离，就需要将特征域缩放在相同范围，使得特征的权重保持一致。</p>
<ul>
<li><p>线性归一化：适用于数值比较集中的情况。但是当max和min值不稳定的时候容易使得归一化结果不稳定，所以可以使用经验常量进行替代 <span class="math display">\[
x&#39; = \frac{x-min(x)}{max(x)-min(x)}
\]</span></p></li>
<li><p>标准差标准化：使得数据符合正态分布 <span class="math display">\[
x&#39; = \frac{x-\mu}{\sigma}，\mu是样本均值，\sigma是样本标准差
\]</span></p></li>
<li><p>非线性归一化：适用于数据分化较大的场景，常使用log、指数、正切等数学方式，对原始数据进行映射，需要根据实际的数据决定非线性函数曲线。</p></li>
</ul>
<h3 id="完整的机器学习项目过程">完整的机器学习项目过程</h3>
<h4 id="抽象为数学问题">1. 抽象为数学问题</h4>
<p>需要将实际的业务问题转化为数学问题，也就是，我们可以获得什么样的数据，目标是回归还是分类或是聚类问题。</p>
<h4 id="获取数据">2. 获取数据</h4>
<p>数据的价值决定着模型的上限，机器学习算法的优化不过的逼近这个上限。我们所选取的数据需要有代表性，否则就会过拟合。数据也不能偏斜太严重，不同特征之间不要存在数个数量级之间的差距。同时也需要判断需要数据的量级，判断消耗内存或和时间，若数据实在太大，就需要考虑调整算法或利用并行和分布式计算。</p>
<h4 id="特征预处理和特征选择">3. 特征预处理和特征选择</h4>
<p>从良好的数据中选择出良好的特征才能够发挥最大效益。</p>
<p>特征预处理这一步往往能够使得算法的效果和性能得到显著性提高。一般使用的方法有缺失值处理、归一化、离散化、因子化、去除共线性等方法。</p>
<p>进行特征选择需要我们反复理解业务需求，筛选显著特征，去除非显著特征，可以利用相关系数、卡方检验、平均互信息、条件熵、后验概率等方法。</p>
<h4 id="训练模型与调优">4. 训练模型与调优</h4>
<p>这一步就是选择算法对数据进行训练，现在有很多的算法都已经封装好了，例如Python中的sklearn库，真正影响效果的是参数的选择，这需要我们对算法的原理有更好的理解，来进行更好的调度。</p>
<h4 id="模型评估">5. 模型评估</h4>
<p>模型训练之后需要对模型进行评估，首先考虑的是过拟合或欠拟合的问题，一般可以使用交叉验证或绘制学习曲线等方法进行验证，相应的调整数据量或模型复杂度。也可以考虑误差分析，观察误差样本，考虑是参数还是算法的问题，特征还是数据本身问题。不断的修改优化，来达到最优的效果。</p>
<h4 id="模型融合">6. 模型融合</h4>
<p>一般来说，模型的融合都会使得效果有一定的提升。工程上，提升算法准确度的方法一般是在模型建立之前的数据清洗和特征工程上，以及建立模型之后的模型融合上。因为这两点标准可复制，效果也很稳定，细节调参的处理相对来说比较少，因为时间长，代价高，并且效果难以保证。</p>
<h4 id="上线运行">7. 上线运行</h4>
<p>建立的模型投入使用的时候，并不单纯的考虑结果的准确性和误差情况，也需要考虑模型运行的速度、占用内存以及稳定性等情况。</p>
<h3 id="协方差与相关性">协方差与相关性</h3>
<p>协方差是用于衡量两个变量的联合变化程度，也就是同时变化的方向和程度情况。当两个变量之间存在不同的度量，我们会得到无意义的协方差。</p>
<p>相关性是协方差的一个标准化格式，是消除了量纲影响、标准化之后特殊的协方差。 <span class="math display">\[
\rho = \frac{Cov(X,Y)}{\sigma_X\sigma_Y}
\]</span> 量纲对数据造成的变化幅度，使得协方差虽然能够得到两者是同向变化的，但是却不能发现两者变化相似。</p>
<h3 id="xgboost与gbdt">XGBoost与GBDT</h3>
<p>传统GBDT以CART作为基分类器，xgboost还支持线性分类器，这个时候xgboost相当于带L1和L2正则化项的逻辑斯蒂回归（分类问题）或者线性回归（回归问题）。传统GBDT在优化时只用到一阶导数信息，xgboost则对代价函数进行了二阶泰勒展开，同时用到了一阶和二阶导数。顺便提一下，xgboost工具支持自定义代价函数，只要函数可一阶和二阶求导。 xgboost在代价函数里加入了正则项，用于控制模型的复杂度。正则项里包含了树的叶子节点个数、每个叶子节点上输出的score的L2模的平方和。从Bias-variance tradeoff角度来讲，正则项降低了模型的variance，使学习出来的模型更加简单，防止过拟合，这也是xgboost优于传统GBDT的一个特性。 Shrinkage（缩减），相当于学习速率（xgboost中的eta）。xgboost在进行完一次迭代后，会将叶子节点的权重乘上该系数，主要是为了削弱每棵树的影响，让后面有更大的学习空间。实际应用中，一般把eta设置得小一点，然后迭代次数设置得大一点。（补充：传统GBDT的实现也有学习速率） 列抽样（column subsampling）。xgboost借鉴了随机森林的做法，支持列抽样，不仅能降低过拟合，还能减少计算，这也是xgboost异于传统gbdt的一个特性。</p>
<p>对缺失值的处理。对于特征的值有缺失的样本，xgboost可以自动学习出它的分裂方向。 xgboost工具支持并行。boosting不是一种串行的结构吗?怎么并行的？注意xgboost的并行不是tree粒度的并行，xgboost也是一次迭代完才能进行下一次迭代的（第t次迭代的代价函数里包含了前面t-1次迭代的预测值）。xgboost的并行是在特征粒度上的。我们知道，决策树的学习最耗时的一个步骤就是对特征的值进行排序（因为要确定最佳分割点），xgboost在训练之前，预先对数据进行了排序，然后保存为block结构，后面的迭代中重复地使用这个结构，大大减小计算量。这个block结构也使得并行成为了可能，在进行节点的分裂时，需要计算每个特征的增益，最终选增益最大的那个特征去做分裂，那么各个特征的增益计算就可以开多线程进行。可并行的近似直方图算法。树节点在进行分裂时，我们需要计算每个特征的每个分割点对应的增益，即用贪心法枚举所有可能的分割点。当数据无法一次载入内存或者在分布式情况下，贪心算法效率就会变得很低，所以xgboost还提出了一种可并行的近似直方图算法，用于高效地生成候选的分割点。</p>
<h2 id="个人收获">个人收获</h2>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>总结</category>
      </categories>
  </entry>
  <entry>
    <title>Flask | xm-select控件回显</title>
    <url>/2021/01/13/Flask%E4%B8%8B%E6%8E%A7%E4%BB%B6%E5%9B%9E%E6%98%BE%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94xm-select%E6%8E%A7%E4%BB%B6%E5%9B%9E%E6%98%BE/</url>
    <content><![CDATA[<blockquote>
<p>本文适用于Flask + Layui + HTML + JS 的场景，其他场景不保证完全适用。</p>
<p>本文是关于Flask下控件回显问题的解决方案，包括xm-select单选框的回显问题</p>
</blockquote>
<span id="more"></span>
<h2 id="控件回显问题">控件回显问题</h2>
<p>在Flask中调用<code>render_template</code>的时候页面会进行刷新，此时页面的<code>From</code>之类需要输入的控件在刷新后就会显示空白内容，因为刷新等于重新加载一次页面，虽然获取了输入的值，但是并没有保留在原本的控件 value 中。</p>
<h3 id="解决显式控件回显问题方法">解决显式控件回显问题方法</h3>
<p>本文所谓的显式控件是，控件的元素都是在HTML或JS中直接定义的，此事我们只需要找到控件所在的位置，给元素进行赋值，例如：</p>
<p>app.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Hello</span>():</span></span><br><span class="line">        <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">            form_name = request.form[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">	<span class="keyword">return</span> render_template(<span class="string">&#x27;index.html&#x27;</span>,name=form_name)</span><br></pre></td></tr></table></figure>
<p>index.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">from</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">style</span>=<span class="string">&quot;width: 220px&quot;</span>&gt;</span>姓名：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123; name &#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>立即查看<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们这里是将从表单中获取的name值，再次赋值给name，也就是回显。</p>
<p>其实也就是利用 Flask的<code>&#123;&#123; &#125;&#125;</code>进行传参，只不过这里是将参数传给<code>value</code>而已，与之前获取参数一节不过是举一反三。</p>
<h3 id="解决隐式控件回显问题方法">解决隐式控件回显问题方法</h3>
<p>在写小程序的时候，使用了layui框架的扩展插件<code>xm-select</code>，该插件主要是设计了好看的选择控件，例如单选多选等等，之后再开章节细讲。</p>
<p>本人的调用的xm-select控件部分代码如下。</p>
<p>index.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">&quot;layui-form layui-form-pane&quot;</span> <span class="attr">style</span>=<span class="string">&quot;font-family: 微软雅黑&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layui-form-item&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layui-inline layui-col-md6&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&quot;layui-form-label&quot;</span>&gt;</span>小区选择<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layui-input-block&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;sites&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sites&quot;</span> <span class="attr">class</span>=<span class="string">&quot;xm-select-demo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<img src="/2021/01/13/Flask%E4%B8%8B%E6%8E%A7%E4%BB%B6%E5%9B%9E%E6%98%BE%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94xm-select%E6%8E%A7%E4%BB%B6%E5%9B%9E%E6%98%BE/01%E4%B8%8B%E6%8B%89%E6%A1%86%E6%98%BE%E5%BC%8F.png" class="" title="下拉框效果展示">
<p>但是在提交表单之后，界面进行刷新，页面中选择的参数就会消失，此时我们去寻找对应的控件，就傻眼了。</p>
<img src="/2021/01/13/Flask%E4%B8%8B%E6%8E%A7%E4%BB%B6%E5%9B%9E%E6%98%BE%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94xm-select%E6%8E%A7%E4%BB%B6%E5%9B%9E%E6%98%BE/02%E4%B8%8B%E6%8B%89%E6%A1%86%E5%85%83%E7%B4%A0%E4%BB%A3%E7%A0%81.png" class="" title="开发人员工具下拉框元素代码">
<p>我们只能在①处找到自己写的代码，而下拉框②这些都是动态生成的，对于我这个前端新手来说还是很厉害的，所以，我去查找<a href="https://maplemei.gitee.io/xm-select/#/shi-li-fang-fa">说明文档</a>，事实证明说明文档是很重要的。</p>
<p>从中我们得知，在进行<code>xmSelect.render()</code>后会返回一个<code>xmSelect</code>对象，也就是我们的下拉框对象，使用<code>getValue</code>可以获取下拉框的当前值，使用<code>setValue</code>可以设置下拉框的当前值，也就我们所需要的回显，调用格式如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sites_select.setValue([</span><br><span class="line">    &#123;<span class="attr">name</span>: sitesname, <span class="attr">value</span>: sitesname, <span class="attr">selected</span>: <span class="literal">true</span>&#125;</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>
<p>这样就成功完成了控件的回显。</p>
<p>// Todo: 还有一个多选的回显，还为解决。</p>
<h2 id="个人收获">个人收获</h2>
<ol type="1">
<li>学会举一反三，Flask传过来的值在HTML的任何一个位置都可以运用；</li>
<li>当控件是动态显示的时候，一定会存在赋值取值的函数入口，查找说明文档是最快的方法。</li>
</ol>
]]></content>
      <categories>
        <category>轻量Web</category>
      </categories>
      <tags>
        <tag>Flask</tag>
        <tag>layui</tag>
        <tag>xm-select</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask | xm-select控件回显</title>
    <url>/2021/01/13/Flask%20%20xm-select%E6%8E%A7%E4%BB%B6%E5%9B%9E%E6%98%BE/</url>
    <content><![CDATA[<blockquote>
<p>本文适用于Flask + Layui + HTML + JS 的场景，其他场景不保证完全适用。</p>
<p>本文是关于Flask下控件回显问题的解决方案，包括xm-select单选框的回显问题</p>
</blockquote>
<span id="more"></span>
<h2 id="控件回显问题">控件回显问题</h2>
<p>在Flask中调用<code>render_template</code>的时候页面会进行刷新，此时页面的<code>From</code>之类需要输入的控件在刷新后就会显示空白内容，因为刷新等于重新加载一次页面，虽然获取了输入的值，但是并没有保留在原本的控件 value 中。</p>
<h3 id="解决显式控件回显问题方法">解决显式控件回显问题方法</h3>
<p>本文所谓的显式控件是，控件的元素都是在HTML或JS中直接定义的，此事我们只需要找到控件所在的位置，给元素进行赋值，例如：</p>
<p>app.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Hello</span>():</span></span><br><span class="line">        <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">            form_name = request.form[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">	<span class="keyword">return</span> render_template(<span class="string">&#x27;index.html&#x27;</span>,name=form_name)</span><br></pre></td></tr></table></figure>
<p>index.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">from</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">style</span>=<span class="string">&quot;width: 220px&quot;</span>&gt;</span>姓名：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123; name &#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>立即查看<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们这里是将从表单中获取的name值，再次赋值给name，也就是回显。</p>
<p>其实也就是利用 Flask的<code>&#123;&#123; &#125;&#125;</code>进行传参，只不过这里是将参数传给<code>value</code>而已，与之前获取参数一节不过是举一反三。</p>
<h3 id="解决隐式控件回显问题方法">解决隐式控件回显问题方法</h3>
<p>在写小程序的时候，使用了layui框架的扩展插件<code>xm-select</code>，该插件主要是设计了好看的选择控件，例如单选多选等等，之后再开章节细讲。</p>
<p>本人的调用的xm-select控件部分代码如下。</p>
<p>index.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">&quot;layui-form layui-form-pane&quot;</span> <span class="attr">style</span>=<span class="string">&quot;font-family: 微软雅黑&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layui-form-item&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layui-inline layui-col-md6&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&quot;layui-form-label&quot;</span>&gt;</span>小区选择<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layui-input-block&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;sites&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sites&quot;</span> <span class="attr">class</span>=<span class="string">&quot;xm-select-demo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>

<p>但是在提交表单之后，界面进行刷新，页面中选择的参数就会消失，此时我们去寻找对应的控件，就傻眼了。</p>

<p>我们只能在①处找到自己写的代码，而下拉框②这些都是动态生成的，对于我这个前端新手来说还是很厉害的，所以，我去查找<a href="https://maplemei.gitee.io/xm-select/#/shi-li-fang-fa">说明文档</a>，事实证明说明文档是很重要的。</p>
<p>从中我们得知，在进行<code>xmSelect.render()</code>后会返回一个<code>xmSelect</code>对象，也就是我们的下拉框对象，使用<code>getValue</code>可以获取下拉框的当前值，使用<code>setValue</code>可以设置下拉框的当前值，也就我们所需要的回显，调用格式如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sites_select.setValue([</span><br><span class="line">    &#123;<span class="attr">name</span>: sitesname, <span class="attr">value</span>: sitesname, <span class="attr">selected</span>: <span class="literal">true</span>&#125;</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>
<p>这样就成功完成了控件的回显。</p>
<p>// Todo: 还有一个多选的回显，还为解决。</p>
<h2 id="个人收获">个人收获</h2>
<ol type="1">
<li>学会举一反三，Flask传过来的值在HTML的任何一个位置都可以运用；</li>
<li>当控件是动态显示的时候，一定会存在赋值取值的函数入口，查找说明文档是最快的方法。</li>
</ol>
]]></content>
      <categories>
        <category>轻量Web</category>
      </categories>
      <tags>
        <tag>Flask</tag>
        <tag>layui</tag>
        <tag>xm-select</tag>
      </tags>
  </entry>
  <entry>
    <title>A/B Testing</title>
    <url>/2021/01/12/A-B-Testing/</url>
    <content><![CDATA[<blockquote>
<p>本文是理论内容，关于A/B测试的概念、原理、和实际应用等；</p>
<p>适用于需要了解A/B测试基本概念的读者。</p>
</blockquote>
<span id="more"></span>
<h1 id="ab测试">A/B测试</h1>
<p>A/B测试本身是随机对照试验——双盲测试，对不同组进行不同的干预，对照实验效果进行分析。</p>
<p>因为其实验成本不高，所以在互联网公司的应用很多，通过修改某个按钮或入口位置，通过某个指标来观察该策略的好坏程度，由此来提高用户体验。</p>
<p>从统计学上看，是一种假设检验的方法，针对当前方案来<strong>验证哪个方法更优</strong>。</p>
<blockquote>
<p>这句话说明两点：1. A/B测试可以优化方案来进行迭代更新；2. A/B测试不能进行创造创新。</p>
</blockquote>
<h3 id="优势">优势</h3>
<p>互联网产品本身的量级都比较大，随意的改动影响将会非常大，这就可以通过A/B测试进行<strong>小量抽样流量</strong>来对整体进行评估，并且根据实验得到的结论相比于依靠历史经验来说更具有<strong>说服力</strong>；并且对于一些<strong>创新性</strong>想法，可以通过A/B测试进行快速验证，降低创新成本。</p>
<h2 id="统计学基础">统计学基础</h2>
<h3 id="全概率公式">全概率公式</h3>
<p>全概率公式是用于将求解发生复杂事件A的概率问题，分解为求解发生多个简单事件<span class="math inline">\(B_1,B_2,...B_n\)</span>概率的问题，其中。<span class="math inline">\(B_1,B_2,...B_n\)</span>事件构成完备事件组——即两两不互相容，且和为全集。则 <span class="math display">\[
P(A) = P(A|B_1)P(B_1) + P(A|B_n)P(B_n) + \dots + P(A|B_n)P(B_n)
\]</span> 当一个策略针对不同人群产生不同效果的时候，可以利用全概率公式进行预估全局的效果；同时我们发现在全局的效果并不显著的时候，可以进行下钻，找出某个效果显著的人群，或者预估这个人群的占比对整体的影响。</p>
<h3 id="大数定律">大数定律</h3>
<p>当统计的数据量足够大，那么事物出现的频率就无线接近于期望值（Mean，每次可能结果的概率值<span class="math inline">\(\times\)</span>结果的总和，反映随机变量平均取值的大小）。简单来说，重复的次数越多，需要验证的指标均值就会逐步接近于真实值，这也是我们实验能够成立的基础。</p>
<h3 id="中心极限定理">中心极限定理</h3>
<p>中心极限定理是T检验和假设检验成立的基础，也是A/B测试的核心。</p>
<ol type="1">
<li>样本的均值=总体的均值：每次抽样获得的均值总是在整体的均值附近波动。</li>
<li>数据处于任意分布下，总体样本的平均值总会在整体均值附近上下波动并符合正态分布。</li>
</ol>
<p>在没有办法得到全量数据的情况下，我们可以利用样本来估计总体，特别是具备大量用户的互联网行业，需要进行严格的测试和实验，也就是利用中心极限定理，从小量用户进行对照实验，来判断实验的策略对于整体用户的影响。</p>
<h2 id="ab测试应用">A/B测试应用</h2>
<h3 id="置信区间和置信度">置信区间和置信度</h3>
<p>概率论是通过抽样和分布来估计总体的一门学科。A/B测试实验就是希望通过抽样来估计整体，然而预估总是会出现偏差的，因为我们不能站在上帝的视角来直接获得准确的数据，所以我们使用两个预估策略：点估计和区间估计。</p>
<ul>
<li>估计一个班上的男生平均身高为170cm，就是点估计。</li>
<li>估计一个班上的男生平均身高在167cm~174cm之间，就是区间估计。</li>
</ul>
<p>区间估计就在总体参数的点估计上增加一个区间范围，相比于点估计更加严谨。</p>
<p>由此而言，我们估计的时候需要给出一个估计区间的范围，来保证结果的可靠性，但是这个范围不能无限放大，因为我们估计该班上男生的平均身高是0~10米也是完全正确的，但并没有实际意义。</p>
<p>此时我们就需要给定一个足够小的误差范围（<strong>置信区间</strong>），并求得总体均值有多大的概率在此区间内（<strong>置信度或置信水平</strong>）。置信区间并不是完全的置信，而是一个估计区间，需要有一个指标来衡量置信区间的置信水平。</p>
<blockquote>
<p>日常使用的置信水平大部分是95%，是因为95%的置信度在正态分布中，误差范围刚好是两个标准差<span class="math inline">\(\sigma\)</span>，并且误差范围并不大，而且置信水平相对较高。但也可以人为设定其他值来衡量。</p>
</blockquote>
<h3 id="显著性">显著性</h3>
<p>显著性是A/B测试中衡量实验组相比对照组是否有明显差异的另一个一个核心指标，说明了两个测试组观察的指标在实验后差异是否显著，可以是提升显著，也可以是降低显著。</p>
<ol type="1">
<li>同向为正，显著提升：当实验指标提升为正，且置信区间上下限同为正，那么实验结果显著提升。</li>
<li>逆向为负，显著下降：当实验指标提升为负，且置信区间上下限同为负，那么实验结果显著下降。</li>
<li>置信区间一正一负，效果不显著：若置信区间一正一负，那么结果将难以判断是提升还是下降的。</li>
</ol>
<blockquote>
<p>目前的统计学中，通常将阈值发生几率小于5%的事件称之为“不可能事件”，吧<span class="math inline">\(\alpha&lt;0.05\)</span>的概率称为具有显著性。</p>
</blockquote>
<h3 id="实验抽样与用户分层">实验抽样与用户分层</h3>
<p>当我们对很多实验数据的时候，很多情况都是先进行抽样。抽样需要符合几个原则：</p>
<ol type="1">
<li>均匀：抽样样本对象要尽可能分布均匀，属性一致；</li>
<li>随机：保证样本呢均匀的和实验需求的前提下，应尽可能保持抽样的随机性；</li>
<li>样本充足：样本过小会导致实验数据波动较大且实验周期较长。</li>
</ol>
<p>抽样之后进行实验，当实验用户分层只有一层，那就只能同时进行很少的实验，为了提高实验效率，就需要增加用户分层。</p>
<p>实验分层方式：</p>
<p>根据业务需求可以有多种划分方法，理论上可以划分N层</p>
<ol type="1">
<li>正交分层：各层用户均匀分布至其他各个实验层，达到用户“正交”的效果。`<code>实际上是上一层每一个实验的影响均匀分不到下一层里，使得效果相互抵消，而不影响下一层的实验评估效果</code>，从而只需要考虑单层策略的影响效果。</li>
<li>逻辑互斥：不同的业务逻辑需要在不同的层，相同的业务逻辑只能在同一层。若一个用户在两层都是有关样式调整的实验，那么会产生逻辑干扰，导致结果逻辑混乱。</li>
</ol>
<h3 id="单一因素原则">单一因素原则</h3>
<p>最后需要注意的是，在进行A/B实验的时候，需要保证每一个实验的评估对象都只有一个，即每次实验指考虑一个因素的影响，否则难以区分实验的效果是哪一个因素影响的。</p>
]]></content>
      <categories>
        <category>统计学</category>
      </categories>
  </entry>
  <entry>
    <title>测量HTML元素长度</title>
    <url>/2021/01/10/%E6%B5%8B%E9%87%8FHTML%E5%85%83%E7%B4%A0%E9%95%BF%E5%BA%A6/</url>
    <content><![CDATA[<blockquote>
<p>这次要推荐是提升html页面布局效率的chrome插件。</p>
<p>适用于有 HTML + CSS 进行页面设计需求的人群。</p>
</blockquote>
<span id="more"></span>
<h2 id="page-ruler-redux">Page Ruler Redux</h2>
<p>该插件是<a href="https://chrome.google.com/webstore/detail/page-ruler-redux/giejhjebcalaheckengmchjekofhhmal">Page Ruler Redux</a>，直接点击链接就可以在<code>Chrome</code>应用商店进行下载了。</p>
<p>下载完成并进行安装，使用<code>ALT + P</code>快捷键就可以将插件打开，戍边点击选择需要测量的区域即可。</p>
<p>当然，这样直接点击有的时候会选的不太准确，可以打开元素模式，自动选择边界框，在调试的时候就可以自动选择元素边界，准确进行设计。</p>
<img src="/2021/01/10/%E6%B5%8B%E9%87%8FHTML%E5%85%83%E7%B4%A0%E9%95%BF%E5%BA%A6/01.png" class="" title="打开元素模式">
<h2 id="ctrlshifti">Ctrl+Shift+I</h2>
<p>2021年1月13日 更新：</p>
<p>利用上面的插件来显示页面元素的width和height感觉是很方便，但我觉得更重要的应该是可以看到left和top等边距参数，这样可以准确控制页面的布局。</p>
<p>同时当页面元素可以拖动和缩放的时候，我们打开插件进行测量，则页面可能会重新刷新，这个时候就比较不方便了，这时需要查看width和height的话，通过浏览器自带的<code>开发人员工具</code>，点击左上角的小箭头即可。将该页面独立出来，就可以直接查看页面元素的大小了。</p>
<blockquote>
<p>其实这个开发人员工具我用的很熟悉，但是当时想要测量页面元素却一时忘记，今天才反应过来，这可能就是灯下黑吧:joy:。</p>
</blockquote>
]]></content>
      <categories>
        <category>插件</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask | JS获取python中的JSON数据</title>
    <url>/2021/01/10/Flask%E2%80%94%E2%80%94JS%E8%8E%B7%E5%8F%96python%E4%B8%AD%E7%9A%84JSON%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p>这是本博客第一篇正式文章，博客站点还没完全优化好，但是已经有值得记录的就先记录下来了。</p>
<blockquote>
<p>本文适用于 Flask + Pandas + HTML + JS 的场景，其他场景不保证完全适用。</p>
<p>主要解决关于Flask传递JSON数据到JS出现‘&amp;#34’的问题</p>
</blockquote>
<span id="more"></span>
<h2 id="json数据简介">JSON数据简介</h2>
<p>// Todo：关于JSON数据的简介</p>
<p>JSON的全称是”<code>JavaScript Object Notation</code>”，意思是JavaScript对象表示法，它是一种基于文本，独立于语言的轻量级数据交换格式。</p>
<h2 id="js获取flask的数据">JS获取Flask的数据</h2>
<p>Flask框架允许我们在HTML中直接获得python文件中传递过来的参数，如下：</p>
<p>app.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Hello</span>():</span></span><br><span class="line">	<span class="keyword">return</span> render_template(<span class="string">&#x27;index.html&#x27;</span>,name=<span class="string">&#x27;hello word!&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>index.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; name &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样在html页面中就可以直接显示传递过来的数据了，在前端某些需要后端计算返回数据的时候还是比较实用的。</p>
<p>在Pandas下使用<code>DataFrame.to_json()</code>，将数据转化为JSON格式，我们可以使用type观察一下其类型，容易发现他本质上是一个字符串，所以将其传递给JS的时候，他就认为这是一个字符串类型的数据，所以，我们需要在JS文件中使用的时候，需要将<code>string</code>类型的JSON变量转化为<code>object</code>类型的JSON对象。</p>
<p>此处存在三种常用的方法进行<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<ul>
<li><code>var json = JSON.parse(str);</code></li>
<li><code>var json = eval("(" + str + ")");</code></li>
<li><code>var json = (new Function("return " + str))();</code></li>
</ul>
<p>但是我们在Flask中传递参数过来之，在利用以上方法进行解析的时候却出现了问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sitePos形如 &#x27;[[obj00,obj01],[obj10,obj11],[obj20,obj21]&#x27;</span></span><br><span class="line"><span class="keyword">var</span> sitePos = &#123;&#123; sitePos &#125;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sitePos)</span><br><span class="line">sitePos = <span class="built_in">JSON</span>.parse(sitePos)</span><br><span class="line"><span class="built_in">console</span>.log(sitePos)</span><br></pre></td></tr></table></figure>
<p>当我的数据是两列<code>数字类型</code>的JSON格式的时候，完全没问题，程序顺利运行！</p>
<h3 id="报错json字符串在js中引号转义为34">报错：JSON字符串在JS中引号转义为‘&amp;#34’</h3>
<p>但是当我加入一列<code>字符串类型</code>的数据时就出现问题了！第4行报错：<code>Uncaught SyntaxError: Unexpected token &amp; in JSON at position 1</code>，仔细一看第2行的log，发现字符串类型的数据中，双引号被转义为<code>&amp;#34;</code>，我一拍脑袋就想到解决办法了🤪</p>
<ul>
<li>错误方法1：在python中使用<code>to_json()</code>获得JSON字符串之后，利用<code>replace('\"','')</code>，直接将引号删除。好家伙，照样报错<code>Uncaught SyntaxError: Unexpected token N in JSON at position 1</code>，报错到了字符串内容而已，本质问题相同。</li>
<li>错误方法2：将双引号转化为单引号。。。不愧是我，继续错。</li>
<li>错误方法3：在JS中使用ajax获取，这个就不展开将了，可以成功获取，但是不知道什么原因不能稳定显示，总之不靠谱，以及浪费了大量时间。（赤裸裸的给我希望，但是让我绝望——我太菜）。</li>
</ul>
<p>知道后来我遇到了这个男人[^ 2]，我终于悟了，这是因为JS出于对数据的安全考虑，将其进行转义，之前还看到一个不靠谱的文章说将安全保护关了。</p>
<p>正确解法：在HTML使用容器来获得数据，之后再在JS中利用DOM获得数据。将样式设置为<code>style="display:none"</code>是为了不让该元素容器显示，只作为媒介存在。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;dataid&quot;</span> <span class="attr">d</span>=<span class="string">&quot;&#123;&#123;sitePos&#125;&#125;&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display:none&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> sitePos = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;dataid&#x27;</span>).getAttribute(<span class="string">&#x27;d&#x27;</span>);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>JS和HTML其实都可以通过 来获得Python中传递的数据。</p>
</blockquote>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p><a href="https://segmentfault.com/a/1190000007368846">js字符串转化成json对象，使用JSON.parse()需要注意的地方</a> [^ 2]:<a href="https://blog.csdn.net/wangqing008/article/details/39352867">Flask python 传输数据到前台 js 出问题 “' "”</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>轻量Web</category>
        <category>数据格式</category>
      </categories>
      <tags>
        <tag>Flask</tag>
        <tag>JS</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 的安装和配置</title>
    <url>/2021/01/05/hexo%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="缘">缘</h2>
<p>时隔一年多的时间，再次将拾起写博客的习惯。最早的时候是在大一接触了 Hexo，那时候有人跟我分享了他的刚搭建好的博客，但是我并没有看懂，于是就没有太在意，想来自己还是错过了最初变强的机会，而那个人已经是南大的研究生了。后来自己搭建博客是在大三了，主要内容还是编程问题、平时课程的收获和周记等心得类的，之后由于考研的缘故又放下了博客。这次再拿出来干脆重新开始搭建，这次以数据分析内容为主，记录在此算是一种自我督促吧。</p>
<h2 id="建议">建议</h2>
<p>安装 Hexo 的时候，包括安装其他软件，希望读者可以将<strong>全文都看一遍</strong>，再多看几篇其他的教程再下手，尤其是这种自由度比较高的东西，配置多，步骤多，涉及的内容也比较多。</p>
<p>本文是针对：<code>Hexo 5.3 + GitHub Pages</code>进行搭建的，使用<code>&lt;GitHub name&gt;.github.io</code>作为域名，主题是<code>Next</code>。</p>
<span id="more"></span>
<h2 id="hexo环境准备">Hexo环境准备</h2>
<p>本文的面向 Windows 10 的。</p>
<p>Hexo 安装之前需要的准备工作有：</p>
<ul>
<li><a href="https://git-scm.com/download/win">Git 下载</a>，以及安装的<a href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git">中文说明文档</a>。</li>
<li><a href="https://nodejs.org/en/download/">Nodejs 下载</a>，本人的 Node.js 是 Anaconda 中安装某个包的时候装的，具体忘记了，反正在电脑上是有的:smiley:。</li>
<li>（可选）<a href="https://classic.yarnpkg.com/en/docs/install">yarn</a>，Node.js 是自带 npm 包管理器的，但是因为某些原因<del>感到不爽</del>而使用 yarn ，它本质上还是利用 npm 进行安装的，至于 cnpm 还是不推荐的。</li>
</ul>
<p>此处不是重点，就不一一赘述安装步骤了。</p>
<p>除此之外还需要一个 GitHub 账号，打开<a href="https://github.com/">GitHub官网</a>，注册并登录，并且新建一个项目，如下：</p>
<img src="/2021/01/05/hexo%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/01new.png" class="" title="01new.png">
<p>需要注意的是，repository 的 name 一定是 &lt;GitHub name&gt;.github.io，这也是之后直接访问的免费域名。本人这里是因为已经创建过了，所以显示错误。</p>
<img src="/2021/01/05/hexo%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/02repository.png" class="" title="hexo的安装和配置">
<p>创建好了之后就到下一步吧，一会儿回过头来再使用。</p>
<h2 id="hexo-安装">Hexo 安装</h2>
<p>接下来就开始 Hexo 的安装：</p>
<h3 id="安装-hexo-依赖包">安装 Hexo 依赖包</h3>
<ul>
<li><p>选择合适的地方新建一个文件夹（下面称为<strong>根目录</strong>），作为 Hexo 博客的主文件夹，建议命名为<code>&lt;GitHub name&gt;.github.io</code>。</p></li>
<li><p>在新建的博客文件夹（再强调一次，下面称为<strong>根目录</strong>）内右击打开 Git Bash，输入<code>yarn global add hexo-cli</code>，在全局安装 Hexo。</p>
<blockquote>
<p>此处应该是不会在该文件夹产生任何内容的，不出意外的话，应该是在<code>&lt;yarn安装目录&gt;\Data\global\node_modules</code>中</p>
</blockquote></li>
<li><p>随后在博客的根目录内输入<code>hexo init</code>，对 Hexo 进行初始化，该文件夹下不能有任何文件，否则会报错。</p></li>
</ul>
<h3 id="关联-github-pages">关联 GitHub Pages</h3>
<p>到这里，已经将 Hexo 安装到本地了，接下来需要将 Hexo 与 GitHub Pages 进行关联，使得 Hexo 可以部署在 GitHub 上。</p>
<ul>
<li><p>打开之前建立的 repository，复制该 repository 的 ssh 链接。</p>
<p><img src="/2021/01/05/hexo%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/03sshaddress.png" class="" title="03sshaddress.png"></p></li>
<li><p>在博客根目录下找到<code>_config.yml</code>配置文件，使用记事本或VS code等软件打开，在最下面找到</p>
<p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">上一步复制的ssh链接</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意配置文件的冒号之后都是有<strong>空格</strong>的。</p>
</blockquote></li>
<li><p>再进入博客的根目录，输入的邮箱和用户名。</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.email <span class="string">&quot;自己的邮箱&quot;</span></span><br><span class="line">git config --global user.name <span class="string">&quot;自己的用户名&quot;</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>输入<code>yarn add hexo-deployer-git</code>，安装 Git 部署依赖项，就大功告成了。</p></li>
</ul>
<h2 id="启动-hexo">启动 Hexo</h2>
<p>这时候让我们来启动一下看看我们的博客，同样在根目录下输入命令：</p>
<ul>
<li><code>hexo clean</code>：清除 public 文件夹内的内容，也就是清理缓存建议每次更新的时候运行一下。</li>
<li><code>hexo generate</code>：生成文件，生成发布的 public 文件，可简写为<code>hexo g</code>。</li>
<li><code>hexo server</code>：启动本地服务器，可以通过 <a href="http://localhost:4000">http://localhost:4000</a> 进行访问，此步成功就说明博客搭建成功了，可简写为<code>hexo s</code></li>
<li><code>hexo deploy</code>：部署博客，可简写为 <code>hexo g</code>。</li>
</ul>
<h3 id="跳过输入github-密码">跳过输入GitHub 密码</h3>
<p>到这里为止，在 deploy 的时候，会发现每次都需要输入密码，十分的麻烦，所以使用 ssh-keygen 来生成密钥：</p>
<ul>
<li>同样在根目录输入<code>ssh-keygen -t rsa -C "自己的邮箱"</code>。</li>
<li>连续敲击三下回车，后面两下是输入密码，直接回车就表示不输入密码。</li>
<li>成功之后会在用户目录下生成<code>.shh</code>文件夹，打开其中的<code>id_rsa.pub</code>文件，右击记事本打开就可以，复制其中的完整内容。</li>
<li>在 GitHub 的<a href="https://github.com/settings/keys">设置-&gt; SSH keys</a>中，点击<code>New SSH key</code>，Title 任意，Key 则是将复制的内容粘贴进去即可。</li>
</ul>
<p>至此一个可以成功部署的最初 Hexo 博客就搭建完成了，后续就是优化内容了。</p>
<h2 id="tagscategoriesabout">tags、categories、about</h2>
<p>默认在导航栏会有首页、归档、关于三个选项，还可以添加标签、分类和关于三个模块，之后就可以在文章中对文章添加分类或标签了，关于模块是自我介绍类的，也可以作为自己的主页，写一些自我介绍的一些内容。</p>
<ul>
<li><p>在博客根目录下打开<code>_config.yml</code>配置文件，找到menu，去除tags、categories、about对应的注释。</p></li>
<li><p>在博客根目录下执行指令，来新建文件夹：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page <span class="string">&quot;tags&quot;</span></span><br><span class="line">hexo new page <span class="string">&quot;categories&quot;</span></span><br><span class="line">hexo new page <span class="string">&quot;about&quot;</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>这些文件夹在根目录的 source 下，其中都会有<code>index.md</code>文件，打开之后分别增加<code>type</code>属性：</p>
<p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">标签</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2021-01-06 08:24:26</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;tags&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">categories</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2021-01-06 08:24:22</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;categories&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">about</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2021-01-06 08:24:28</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;about&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>重新部署 Hexo 就可以生效。</p></li>
</ul>
<h2 id="主题优化">主题优化</h2>
<p>主题的话，我这里选择爆款的 <a href="https://github.com/theme-next/hexo-theme-next">Next 主题</a>，想要尝试更多主题可以在<a href="https://hexo.io/themes/">Hexo Themes</a>中自己选择。</p>
<table>
<thead>
<tr class="header">
<th>版本</th>
<th>年份</th>
<th>仓库</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>v5.1.4 或更低</td>
<td>2014 ~ 2017</td>
<td><a href="https://github.com/iissnan/hexo-theme-next">https://github.com/iissnan/hexo-theme-next</a></td>
</tr>
<tr class="even">
<td>v6.0.0 ~ v7.8.0</td>
<td>2018 ~ 2019</td>
<td><a href="https://github.com/theme-next/hexo-theme-next">https://github.com/theme-next/hexo-theme-next</a></td>
</tr>
<tr class="odd">
<td>v8.0.0 或更高</td>
<td>2020</td>
<td><a href="https://github.com/next-theme/hexo-theme-next">https://github.com/next-theme/hexo-theme-next</a></td>
</tr>
</tbody>
</table>
<p>iissnan 已经停止维护了，不推荐，其他两个根据 Hexo 版本进行选择，克隆下来的主题就在 themes/next 文件夹内，其中的<code>_config.yml</code>配置文件是之后操作主题的地方，需要和之前根目录下 Hexo 的配置区分开。</p>
<blockquote>
<p>注意，有的时候配置完部署后未生效，一般 hexo s 一下，成功的话，再部署一次或多次就生效了，很神奇！！！记得每次都 clean 一下。</p>
</blockquote>
<h3 id="主题样式">主题样式</h3>
<ul>
<li>在主题文件夹中打开<code>_config.yml</code>配置文件，找到 scheme 属性。</li>
<li>可以选择 Muse、Mist、Pisces 和 Gemini 四种主题类型。</li>
</ul>
<h3 id="图片显示问题">图片显示问题</h3>
<p>通过之前的配置之后，发现我们的图片居然无法上传，又担心使用图床容易崩塌，所以，使用插件来将本地图片上传。</p>
<ul>
<li>在博客根目录下输入<code>yarn add https://github.com/7ym0n/hexo-asset-image</code>，安装该插件，注意直接安装 hexo-asset-image 的时候会出现图片<strong>时间无法映射</strong>的问题。</li>
<li>在主题下打开<code>_config.yml</code>配置文件，找到 <code>post_asset_folder</code> 设置为 true，这样生成新的md文件的时候，就会得到一个同名的的文件夹，在其中存放对应博文所需要的图片。</li>
<li>最后就可以在博客中引用图片了，可以是<code>![]()</code>或者 html 形式的（主要是可以缩放），</li>
</ul>
<h3 id="头像设置">头像设置</h3>
<ul>
<li><p>在主题下打开<code>_config.yml</code>配置文件，找到 avatar 字段</p>
<p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Sidebar Avatar</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="comment"># Replace the default image and set the url here.</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/images/avatar.gif</span>  <span class="comment"># avatar.gif 是自己喜欢的头像，放在\themes\next\source\images下</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="string">ture</span>            <span class="comment"># 是否圆形显示头像 true | false</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="string">ture</span>            <span class="comment"># 光标移到头像上后头像是否旋转 true | false</span></span><br></pre></td></tr></table></figure></p></li>
</ul>
<h3 id="网站图标">网站图标</h3>
<p>同时设置一下网站的图标。</p>
<p>将<code>themes\next\source\images</code>文件夹下的<code>apple-touch-icon-next.png</code>，<code>favicon-16x16-next.png</code>和<code>favicon-32x32-next.png</code>图片替换成同样名称和大小的图片即可。</p>
<h3 id="将文章链接修改颜色">将文章链接修改颜色</h3>
<p>在<code>themes\next\source\css\_common\components\post\</code>下打开<code>post.styl</code>文件，添加字段</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">p</span> <span class="selector-tag">a</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#0593d3</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: none;</span><br><span class="line">  &amp;<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#0477ab</span>;</span><br><span class="line">    <span class="attribute">text-decoration</span>: underline;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最好在末尾添加，便于和原配置进行区分。</p>
<h3 id="主页部分显示">主页部分显示</h3>
<p>Next 版本 7 以上已经不支持 auto_excerpt，因为摘要本身是博客的内容，而非主题负责的内容，官方推荐使用<code>&lt;!-- more --&gt;</code>来手动设置。</p>
<h3 id="添加-github-角标">添加 GitHub 角标</h3>
<ul>
<li>在<a href="https://github.blog/2008-12-19-github-ribbons/">GitHub Ribbons</a>中选择喜欢的角标形式，并复制代码。</li>
<li>打开<code>themes/next/layout/_layout.swig</code>文件，在<code>&lt;div class="headband"&gt;&lt;/div&gt;</code>下粘贴代码。</li>
<li>将代码中的<code>href</code>替换为自己的 GitHub 主页</li>
</ul>
<h3 id="删除版本信息">删除版本信息</h3>
<p>在主题配置文件中找到<code>powered</code>字段，修改为false即可。</p>
<h3 id="社交链接">社交链接</h3>
<p>在侧边栏添加一些社交链接，可以使用的图标可以在<a href="http://www.fontawesome.com.cn/faicons/">Font Awesome</a>查看，然后在主题配置文件中找到<code>social</code>字段，并进行配置，例如：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">GitHub:</span> <span class="string">https://github.com/Gipbear</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-github</span></span><br><span class="line">  <span class="attr">E-Mail:</span> <span class="string">mailto:1099048889@qq.com</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-envelope</span></span><br></pre></td></tr></table></figure>
<p>但是一些没有的图标，比如B站，就需要使用自定义方法进行配置。这里我们使用阿里的<a href="https://www.iconfont.cn/search/index?q=bilibili">iconfont</a>来查找，找到B站的图标，点击图标上的<strong>添加入库</strong>，再点击右上方<strong>购物车</strong>图标，点击<strong>下载代码</strong>获得一个压缩文件，解压得到一个<code>iconfont.css</code>文件，将其复制到<code>themes\next\source\lib\font-awesome\css\all.min.css</code>后面，最后在social中添加即可：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">bilibili:</span> <span class="string">https://space.bilibili.com/B站id</span> <span class="string">||</span> <span class="string">iconfont</span> <span class="string">icon-bilibili-line</span></span><br></pre></td></tr></table></figure>
<h3 id="添加文章权利声明">添加文章权利声明</h3>
<p>emmm，虽然也没有特别大的利益相关，但是还是正式点比较好。</p>
<p>在主题配置文件中找到<code>creative_commons</code>字段，将<code>post</code>修改为<code>true</code>即可。</p>
<h3 id="代码样式">代码样式</h3>
<p>修改代码的样式主题，在主题配置文件中找到<code>codeblock</code>字段，将<code>highlight_theme</code>修改为想要主题即可。</p>
<p>同时打开<code>copy_button</code>按钮，使得代码可以直接复制。</p>
<h3 id="加载显示进度条">加载显示进度条</h3>
<p>进度条需要<a href="https://github.com/theme-next/theme-next-pace">下载插件</a>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注意：进入主题文件夹的不是指 themes，而是指 next！</span></span><br><span class="line"><span class="built_in">cd</span> themes/next</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/theme-next-pace <span class="built_in">source</span>/lib/pace</span><br></pre></td></tr></table></figure>
<p>之后打开主题配置文件，找到<code>pace</code>属性，设置<code>enable: true</code>，并选择自己喜欢的形式，可以在<a href="https://codebyzach.github.io/pace/">Pace</a>预览。</p>
<h3 id="文章结束标记">文章结束标记</h3>
<ol type="1">
<li><p>在<code>themes/next/layout/_macro/</code>下新建<code>passage-end-tag.swig</code>文件，并输入</p>
<p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;% <span class="keyword">if</span> not is_index %&#125;</span><br><span class="line">    &lt;div style=<span class="string">&quot;text-align:center;color: #ccc;font-size:14px;&quot;</span>&gt;------ 本文结束------&lt;/div&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p></li>
<li><p>再打开附近的<code>post.swig</code>文件，在注释<code>END POST BODY</code>字段之前增加</p>
<p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;% <span class="keyword">if</span> not is_index %&#125;</span><br><span class="line">    &#123;% include <span class="string">&#x27;passage-end-tag.swig&#x27;</span> %&#125;    </span><br><span class="line">  &#123;% endif %&#125; </span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p></li>
<li><p>最后打开主题配置文件，在<code>Post Setting</code>下增加如下即可。</p>
<p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文章末尾添加“本文结束”标记</span></span><br><span class="line"><span class="attr">passage_end_tag:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p></li>
</ol>
<h3 id="小代码格式">小代码格式</h3>
<p>本人这里设置的颜色类似于 Typora 的 OrangeHeart颜色，打开<code>themes\next\source\css\_variables\base.styl</code>文件，修改:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 加入自定义颜色</span><br><span class="line">$my-codeblock-foreground = <span class="selector-id">#9966FF</span>     // 用``围出的代码块字体颜色</span><br><span class="line">$my-codeblock-<span class="attribute">background</span> = <span class="selector-id">#f5f5f5</span>;    // 用``围出的代码块字体颜色</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// <span class="selector-tag">Code</span> &amp; <span class="selector-tag">Code</span> Blocks</span><br><span class="line">// --------------------------------------------------</span><br><span class="line">$<span class="selector-tag">code</span>-<span class="attribute">font-family</span>               = $<span class="attribute">font-family</span>-monospace;</span><br><span class="line">$<span class="selector-tag">code</span>-foreground                = $my-codeblock-foreground </span><br><span class="line">$<span class="selector-tag">code</span>-<span class="attribute">background</span>                = $my-codeblock-<span class="attribute">background</span> </span><br></pre></td></tr></table></figure>
<h3 id="阅读次数统计">阅读次数统计</h3>
<p>Hexo 有很多可以进行阅读次数等内容的方法，这里选择使用不蒜子进行统计。</p>
<ol type="1">
<li><p>打开主题配置站点，将<code>busuanzi_count</code>设置为true。</p></li>
<li><p>同时找到主题文件夹中的<code>busuanzi-counter.swig</code>文件夹，这个路径好像不同的教程都不太一样，自己找一下吧，在将原本的对应配置修改如下，其中第三行不蒜子的 url 需要修改，<a href="http://busuanzi.ibruce.info/">原因</a>实属七牛天坑：</p>
<p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;%- <span class="keyword">if</span> theme.busuanzi_count.enable %&#125;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;busuanzi-count&quot;</span>&gt;</span><br><span class="line">  <span class="xml">&lt;script&#123;&#123; pjax &#125;&#125; async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">  &#123;%- <span class="keyword">if</span> theme.busuanzi_count.total_visitors %&#125;</span><br><span class="line">    &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;post-meta-item&quot;</span> id=<span class="string">&quot;busuanzi_container_site_uv&quot;</span> style=<span class="string">&quot;display: none;&quot;</span>&gt;</span><br><span class="line">      &lt;!--<span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-icon&quot;</span>&gt;</span>--&gt;</span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!--&lt;i class=&quot;fa fa-&#123;&#123; theme.busuanzi_count.total_visitors_icon &#125;&#125;&quot;&gt;&lt;/i&gt;--&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="comment">&lt;!--&lt;/span&gt;</span></span>--&gt;</span><br><span class="line">      我的第</span><br><span class="line">      &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;site-uv&quot;</span> title=<span class="string">&quot;&#123;&#123; __(&#x27;footer.total_visitors&#x27;) &#125;&#125;&quot;</span>&gt;</span><br><span class="line">        <span class="xml"><span class="comment">&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;</span></span></span><br><span class="line">      &lt;/span&gt;</span><br><span class="line">      位朋友</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">  &#123;%- endif %&#125;</span><br><span class="line"></span><br><span class="line">  &#123;%- <span class="keyword">if</span> theme.busuanzi_count.total_visitors and theme.busuanzi_count.total_views %&#125;</span><br><span class="line">    &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;post-meta-divider&quot;</span>&gt;|&lt;/span&gt;</span><br><span class="line">  &#123;%- endif %&#125;</span><br><span class="line"></span><br><span class="line">  &#123;%- <span class="keyword">if</span> theme.busuanzi_count.total_views %&#125;</span><br><span class="line">    &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;post-meta-item&quot;</span> id=<span class="string">&quot;busuanzi_container_site_pv&quot;</span> style=<span class="string">&quot;display: none;&quot;</span>&gt;</span><br><span class="line">      &lt;!--<span class="xml"><span class="comment">&lt;span class=&quot;post-meta-item-icon&quot;&gt;--&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!--&lt;i class=&quot;fa fa-&#123;&#123; theme.busuanzi_count.total_views_icon &#125;&#125;&quot;&gt;&lt;/i&gt;--&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="comment">&lt;!--&lt;/span&gt;</span></span>--&gt;</span><br><span class="line">      历经</span><br><span class="line">      &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;site-pv&quot;</span> title=<span class="string">&quot;&#123;&#123; __(&#x27;footer.total_views&#x27;) &#125;&#125;&quot;</span>&gt;</span><br><span class="line">        <span class="xml"><span class="comment">&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;</span></span></span><br><span class="line">      &lt;/span&gt;</span><br><span class="line">      次回眸才与你相遇</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">  &#123;%- endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&#123;%- endif %&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p></li>
</ol>
<h3 id="网站字数统计">网站字数统计</h3>
<p>安装<code>hexo-symbols-count-time</code>插件，并在主题配置中找到<code>symbols_count_time</code>字段，修改为</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">item_text_post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">awl:</span> <span class="number">4</span></span><br><span class="line">  <span class="attr">wpm:</span> <span class="number">275</span></span><br></pre></td></tr></table></figure>
<h3 id="全局搜索">全局搜索</h3>
<p>这个是在博客上创建一个可以全局搜索的入口，使得可以快速搜索博客内容。</p>
<ol type="1">
<li><p>首先需要安装<code>hexo-generator-searchdb</code>插件。</p></li>
<li><p>打开站点配置文件，在<code>Extensions</code>下添加</p>
<p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>最后再将主题配置中的<code>local_search</code>功能设置为<code>true</code>即可。</p></li>
</ol>
<h4 id="修改文章底部标签">修改文章底部标签</h4>
<p>默认的标签是用<strong>#</strong>表示的，这里修改一下使用图标tag来替换。打开<code>/themes/next/layout/_macro/post.swig</code>文件，找到<code>rel="tag"&gt;</code>，将后面的<code>&#123;&#123; tag_indicate &#125;&#125;</code>替换为<code>&lt;i class="fa fa-tag"&gt;&lt;/i&gt;</code>即可。</p>
<h4 id="鼠标点击特效">鼠标点击特效</h4>
<p>在<code>hexo\themes\next\source\js\</code>目录或<code>hexo\themes\next\source\jsrc\</code>目录下（后者我没有）新建一个<code>love.js</code>文件，粘贴下方的内容</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params">e, t, a</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">n</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        c(<span class="string">&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#x27;&#x27;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;</span>), o(), r()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">r</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> e = <span class="number">0</span>; e &lt; d.length; e++)</span><br><span class="line">            d[e].alpha &lt;= <span class="number">0</span> ? (t.body.removeChild(d[e].el), d.splice(e, <span class="number">1</span>)) : (d[e].y--, d[e].scale += <span class="number">.004</span>, d[e].alpha -= <span class="number">.013</span>, d[e].el.style.cssText = <span class="string">&quot;left:&quot;</span> + d[e].x + <span class="string">&quot;px;top:&quot;</span> + d[e].y + <span class="string">&quot;px;opacity:&quot;</span> + d[e].alpha + <span class="string">&quot;;transform:scale(&quot;</span> + d[e].scale + <span class="string">&quot;,&quot;</span> + d[e].scale + <span class="string">&quot;) rotate(45deg);background:&quot;</span> + d[e].color + <span class="string">&quot;;z-index:99999&quot;</span>);</span><br><span class="line">        requestAnimationFrame(r)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> t = <span class="string">&quot;function&quot;</span> == <span class="keyword">typeof</span> e.onclick &amp;&amp; e.onclick;</span><br><span class="line">        e.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">            t &amp;&amp; t(), i(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">i</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a = t.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">        a.className = <span class="string">&quot;heart&quot;</span>, d.push(&#123;</span><br><span class="line">            <span class="attr">el</span>: a,</span><br><span class="line">            <span class="attr">x</span>: e.clientX - <span class="number">5</span>,</span><br><span class="line">            <span class="attr">y</span>: e.clientY - <span class="number">5</span>,</span><br><span class="line">            <span class="attr">scale</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">alpha</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">color</span>: s()</span><br><span class="line">        &#125;), t.body.appendChild(a)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a = t.createElement(<span class="string">&quot;style&quot;</span>);</span><br><span class="line">        a.type = <span class="string">&quot;text/css&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            a.appendChild(t.createTextNode(e))</span><br><span class="line">        &#125; <span class="keyword">catch</span> (t) &#123;</span><br><span class="line">            a.styleSheet.cssText = e</span><br><span class="line">        &#125;</span><br><span class="line">        t.getElementsByTagName(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>].appendChild(a)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">s</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;rgb(&quot;</span> + ~~(<span class="number">255</span> * <span class="built_in">Math</span>.random()) + <span class="string">&quot;,&quot;</span> + ~~(<span class="number">255</span> * <span class="built_in">Math</span>.random()) + <span class="string">&quot;,&quot;</span> + ~~(<span class="number">255</span> * <span class="built_in">Math</span>.random()) + <span class="string">&quot;)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> d = [];</span><br><span class="line">    e.requestAnimationFrame = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">setTimeout</span>(e, <span class="number">1e3</span> / <span class="number">60</span>)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;(), n()</span><br><span class="line">&#125;(<span class="built_in">window</span>, <span class="built_in">document</span>);</span><br></pre></td></tr></table></figure>
<p>保存文件，并在<code>hexo\themes\next\layout\_layout.swing</code>文件底部<code>&lt;body&gt;</code>上增加：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 页面点击小红心 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/js/love.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意修改<code>src</code>为<code>love.js</code>所在的路径。</p>
</blockquote>
<h3 id="浏览器网页标题恶搞">浏览器网页标题恶搞</h3>
<p>离开博客页面会在标签页出现恶搞文字表情，也可以自定义。在<code>\themes\next\source\js</code>下新建一个<code>FunnyTitle.js</code>文件，写入如下内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!--浏览器搞笑标题--&gt;</span><br><span class="line"> <span class="keyword">var</span> OriginTitle = <span class="built_in">document</span>.title;</span><br><span class="line"> <span class="keyword">var</span> titleTime;</span><br><span class="line"> <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;visibilitychange&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">document</span>.hidden) &#123;</span><br><span class="line">         <span class="built_in">document</span>.title = <span class="string">&#x27;ヽ(●-`Д´-)ノ你丑你就走！&#x27;</span>;</span><br><span class="line">         <span class="built_in">clearTimeout</span>(titleTime);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="built_in">document</span>.title = <span class="string">&#x27;ヾ(Ő∀Ő3)ノ你帅就回来！&#x27;</span> + OriginTitle;</span><br><span class="line">         titleTime = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">             <span class="built_in">document</span>.title = OriginTitle;</span><br><span class="line">         &#125;, <span class="number">2000</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
<p>并在<code>hexo\themes\next\layout\_layout.swing</code>文件底部<code>&lt;body&gt;</code>上增加：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--浏览器搞笑标题--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;\js\FunnyTitle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="诚挚感谢">诚挚感谢</h2>
<p><a href="https://lvxuefei.top/%E5%88%A9%E7%94%A8Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%89%EF%BC%89-%E4%BC%98%E5%8C%96-%E5%90%84%E7%A7%8Dtips%E3%80%81%E9%BB%91%E7%A7%91%E6%8A%80%EF%BC%8C%E4%B8%8D%E6%96%AD%E6%9B%B4%E6%96%B0/"><strong>槐雪</strong></a></p>
<p><a href="https://www.itfanr.cc/2018/11/12/busuanzi-counter-error/">Hexo博客Next主题解决不蒜子统计不显示问题</a></p>
<p><a href="http://www.sylan215.com/hexo-next-hongxin.html">next 主题下点击后出现红心效果</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/69211731">Hexo 博客美化合集（不断更新）</a></p>
]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
